"""
## Aliyun ROS ECS Construct Library

This module is part of the AliCloud ROS Cloud Development Kit (ROS CDK) project.

```python
# Example automatically generated without compilation. See https://github.com/aws/jsii/issues/826
import alicloud.ros_cdk_ecs as ECS
```
"""
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from ._jsii import *

import ros_cdk_core


class AssignIpv6Addresses(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.AssignIpv6Addresses",
):
    """A ROS resource type:  ``ALIYUN::ECS::AssignIpv6Addresses``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "AssignIpv6AddressesProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::AssignIpv6Addresses``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(AssignIpv6Addresses, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrIpv6Addresses")
    def attr_ipv6_addresses(self) -> typing.Any:
        """
        :Attribute: Ipv6Addresses: Assigned IPv6 addresses.
        """
        return jsii.get(self, "attrIpv6Addresses")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrIpv6AddressIds")
    def attr_ipv6_address_ids(self) -> typing.Any:
        """
        :Attribute: Ipv6AddressIds: Assigned IPv6 address IDs.
        """
        return jsii.get(self, "attrIpv6AddressIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrNetworkInterfaceId")
    def attr_network_interface_id(self) -> typing.Any:
        """
        :Attribute: NetworkInterfaceId: Elastic network interface ID.
        """
        return jsii.get(self, "attrNetworkInterfaceId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.AssignIpv6AddressesProps",
    jsii_struct_bases=[],
    name_mapping={
        "network_interface_id": "networkInterfaceId",
        "ipv6_address_count": "ipv6AddressCount",
        "ipv6_addresses": "ipv6Addresses",
    },
)
class AssignIpv6AddressesProps:
    def __init__(
        self,
        *,
        network_interface_id: builtins.str,
        ipv6_address_count: typing.Optional[jsii.Number] = None,
        ipv6_addresses: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::AssignIpv6Addresses``.

        :param network_interface_id: 
        :param ipv6_address_count: 
        :param ipv6_addresses: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "network_interface_id": network_interface_id,
        }
        if ipv6_address_count is not None:
            self._values["ipv6_address_count"] = ipv6_address_count
        if ipv6_addresses is not None:
            self._values["ipv6_addresses"] = ipv6_addresses

    @builtins.property
    def network_interface_id(self) -> builtins.str:
        """
        :Property: networkInterfaceId: Elastic network interface ID.
        """
        result = self._values.get("network_interface_id")
        assert result is not None, "Required property 'network_interface_id' is missing"
        return result

    @builtins.property
    def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        ipv6AddressCount: IPv6 addresses specified number of randomly generated interfaces elasticity.
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        """
        result = self._values.get("ipv6_address_count")
        return result

    @builtins.property
    def ipv6_addresses(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property:

        ipv6Addresses: Specify one or more IPv6 addresses for the elastic NIC. Currently, the maximum list size is 1. Example value: 2001:db8:1234:1a00::*** .
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        """
        result = self._values.get("ipv6_addresses")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AssignIpv6AddressesProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AssignPrivateIpAddresses(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.AssignPrivateIpAddresses",
):
    """A ROS resource type:  ``ALIYUN::ECS::AssignPrivateIpAddresses``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "AssignPrivateIpAddressesProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::AssignPrivateIpAddresses``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(AssignPrivateIpAddresses, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrNetworkInterfaceId")
    def attr_network_interface_id(self) -> typing.Any:
        """
        :Attribute: NetworkInterfaceId: The ID of the ENI.
        """
        return jsii.get(self, "attrNetworkInterfaceId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateIpAddresses")
    def attr_private_ip_addresses(self) -> typing.Any:
        """
        :Attribute: PrivateIpAddresses: Assigned private ip addresses.
        """
        return jsii.get(self, "attrPrivateIpAddresses")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.AssignPrivateIpAddressesProps",
    jsii_struct_bases=[],
    name_mapping={
        "network_interface_id": "networkInterfaceId",
        "private_ip_addresses": "privateIpAddresses",
        "secondary_private_ip_address_count": "secondaryPrivateIpAddressCount",
    },
)
class AssignPrivateIpAddressesProps:
    def __init__(
        self,
        *,
        network_interface_id: builtins.str,
        private_ip_addresses: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
        secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::AssignPrivateIpAddresses``.

        :param network_interface_id: 
        :param private_ip_addresses: 
        :param secondary_private_ip_address_count: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "network_interface_id": network_interface_id,
        }
        if private_ip_addresses is not None:
            self._values["private_ip_addresses"] = private_ip_addresses
        if secondary_private_ip_address_count is not None:
            self._values["secondary_private_ip_address_count"] = secondary_private_ip_address_count

    @builtins.property
    def network_interface_id(self) -> builtins.str:
        """
        :Property: networkInterfaceId: The ID of the ENI.
        """
        result = self._values.get("network_interface_id")
        assert result is not None, "Required property 'network_interface_id' is missing"
        return result

    @builtins.property
    def private_ip_addresses(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property:

        privateIpAddresses: One or multiple secondary private IP addresses selected from the CIDR block of the VSwitch that hosts the ENI.
        Valid values of number of private ip addresses:
        When the ENI is in the Available state: 1 to 10.
        When the ENI is in the InUse state: limited by the instance type.
        For more information, see Instance type families.
        You must specify either the PrivateIpAddresses parameter or the SecondaryPrivateIpAddressCount parameter to assign secondary private IP addresses.
        """
        result = self._values.get("private_ip_addresses")
        return result

    @builtins.property
    def secondary_private_ip_address_count(self) -> typing.Optional[jsii.Number]:
        """
        :Property: secondaryPrivateIpAddressCount: The specified number of private IP addresses to be assigned by the ECS instance.
        """
        result = self._values.get("secondary_private_ip_address_count")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AssignPrivateIpAddressesProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AutoProvisioningGroup(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.AutoProvisioningGroup",
):
    """A ROS resource type:  ``ALIYUN::ECS::AutoProvisioningGroup``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "AutoProvisioningGroupProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::AutoProvisioningGroup``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(AutoProvisioningGroup, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrAutoProvisioningGroupId")
    def attr_auto_provisioning_group_id(self) -> typing.Any:
        """
        :Attribute: AutoProvisioningGroupId: The ID of the auto provisioning group.
        """
        return jsii.get(self, "attrAutoProvisioningGroupId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.AutoProvisioningGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "launch_template_id": "launchTemplateId",
        "total_target_capacity": "totalTargetCapacity",
        "auto_provisioning_group_name": "autoProvisioningGroupName",
        "auto_provisioning_group_type": "autoProvisioningGroupType",
        "default_target_capacity_type": "defaultTargetCapacityType",
        "description": "description",
        "excess_capacity_termination_policy": "excessCapacityTerminationPolicy",
        "launch_template_config": "launchTemplateConfig",
        "launch_template_version": "launchTemplateVersion",
        "max_spot_price": "maxSpotPrice",
        "pay_as_you_go_allocation_strategy": "payAsYouGoAllocationStrategy",
        "pay_as_you_go_target_capacity": "payAsYouGoTargetCapacity",
        "spot_allocation_strategy": "spotAllocationStrategy",
        "spot_instance_interruption_behavior": "spotInstanceInterruptionBehavior",
        "spot_instance_pools_to_use_count": "spotInstancePoolsToUseCount",
        "spot_target_capacity": "spotTargetCapacity",
        "terminate_instances": "terminateInstances",
        "terminate_instances_with_expiration": "terminateInstancesWithExpiration",
        "valid_from": "validFrom",
        "valid_until": "validUntil",
    },
)
class AutoProvisioningGroupProps:
    def __init__(
        self,
        *,
        launch_template_id: builtins.str,
        total_target_capacity: builtins.str,
        auto_provisioning_group_name: typing.Optional[builtins.str] = None,
        auto_provisioning_group_type: typing.Optional[builtins.str] = None,
        default_target_capacity_type: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        excess_capacity_termination_policy: typing.Optional[builtins.str] = None,
        launch_template_config: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosAutoProvisioningGroup.LaunchTemplateConfigProperty"]]]] = None,
        launch_template_version: typing.Optional[builtins.str] = None,
        max_spot_price: typing.Optional[jsii.Number] = None,
        pay_as_you_go_allocation_strategy: typing.Optional[builtins.str] = None,
        pay_as_you_go_target_capacity: typing.Optional[builtins.str] = None,
        spot_allocation_strategy: typing.Optional[builtins.str] = None,
        spot_instance_interruption_behavior: typing.Optional[builtins.str] = None,
        spot_instance_pools_to_use_count: typing.Optional[jsii.Number] = None,
        spot_target_capacity: typing.Optional[builtins.str] = None,
        terminate_instances: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        terminate_instances_with_expiration: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        valid_from: typing.Optional[builtins.str] = None,
        valid_until: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::AutoProvisioningGroup``.

        :param launch_template_id: 
        :param total_target_capacity: 
        :param auto_provisioning_group_name: 
        :param auto_provisioning_group_type: 
        :param default_target_capacity_type: 
        :param description: 
        :param excess_capacity_termination_policy: 
        :param launch_template_config: 
        :param launch_template_version: 
        :param max_spot_price: 
        :param pay_as_you_go_allocation_strategy: 
        :param pay_as_you_go_target_capacity: 
        :param spot_allocation_strategy: 
        :param spot_instance_interruption_behavior: 
        :param spot_instance_pools_to_use_count: 
        :param spot_target_capacity: 
        :param terminate_instances: 
        :param terminate_instances_with_expiration: 
        :param valid_from: 
        :param valid_until: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "launch_template_id": launch_template_id,
            "total_target_capacity": total_target_capacity,
        }
        if auto_provisioning_group_name is not None:
            self._values["auto_provisioning_group_name"] = auto_provisioning_group_name
        if auto_provisioning_group_type is not None:
            self._values["auto_provisioning_group_type"] = auto_provisioning_group_type
        if default_target_capacity_type is not None:
            self._values["default_target_capacity_type"] = default_target_capacity_type
        if description is not None:
            self._values["description"] = description
        if excess_capacity_termination_policy is not None:
            self._values["excess_capacity_termination_policy"] = excess_capacity_termination_policy
        if launch_template_config is not None:
            self._values["launch_template_config"] = launch_template_config
        if launch_template_version is not None:
            self._values["launch_template_version"] = launch_template_version
        if max_spot_price is not None:
            self._values["max_spot_price"] = max_spot_price
        if pay_as_you_go_allocation_strategy is not None:
            self._values["pay_as_you_go_allocation_strategy"] = pay_as_you_go_allocation_strategy
        if pay_as_you_go_target_capacity is not None:
            self._values["pay_as_you_go_target_capacity"] = pay_as_you_go_target_capacity
        if spot_allocation_strategy is not None:
            self._values["spot_allocation_strategy"] = spot_allocation_strategy
        if spot_instance_interruption_behavior is not None:
            self._values["spot_instance_interruption_behavior"] = spot_instance_interruption_behavior
        if spot_instance_pools_to_use_count is not None:
            self._values["spot_instance_pools_to_use_count"] = spot_instance_pools_to_use_count
        if spot_target_capacity is not None:
            self._values["spot_target_capacity"] = spot_target_capacity
        if terminate_instances is not None:
            self._values["terminate_instances"] = terminate_instances
        if terminate_instances_with_expiration is not None:
            self._values["terminate_instances_with_expiration"] = terminate_instances_with_expiration
        if valid_from is not None:
            self._values["valid_from"] = valid_from
        if valid_until is not None:
            self._values["valid_until"] = valid_until

    @builtins.property
    def launch_template_id(self) -> builtins.str:
        """
        :Property:

        launchTemplateId: The ID of the instance launch template associated with the auto provisioning group.
        You can call the DescribeLaunchTemplates operation to query available instance launch templates.
        An auto provisioning group can be associated with only one instance launch template.
        But you can configure multiple extended configurations for the launch template through
        the LaunchTemplateConfig parameter.
        """
        result = self._values.get("launch_template_id")
        assert result is not None, "Required property 'launch_template_id' is missing"
        return result

    @builtins.property
    def total_target_capacity(self) -> builtins.str:
        """
        :Property:

        totalTargetCapacity: The total target capacity of the auto provisioning group. The target capacity consists
        of the following three parts:
        The target capacity of pay-as-you-go instances specified by the PayAsYouGoTargetCapacity parameter
        The target capacity of preemptible instances specified by the SpotTargetCapacity parameter
        The supplemental capacity besides PayAsYouGoTargetCapacity and SpotTargetCapacity
        """
        result = self._values.get("total_target_capacity")
        assert result is not None, "Required property 'total_target_capacity' is missing"
        return result

    @builtins.property
    def auto_provisioning_group_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        autoProvisioningGroupName: The name of the auto provisioning group to be created. It must be 2 to 128 characters
        in length. It must start with a letter but cannot start with http:// or https://.
        It can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        """
        result = self._values.get("auto_provisioning_group_name")
        return result

    @builtins.property
    def auto_provisioning_group_type(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        autoProvisioningGroupType: The type of the auto provisioning group. Valid values:
        request: One-time delivery. After the auto provisioning group is started, it only attempts
        to create an instance cluster once. If the cluster fails to be created, the group
        does not try again.
        maintain: The continuous delivery and maintain capacity type. After the auto provisioning group
        is started, it continuously attempts to create and maintain the instance cluster.
        The auto provisioning group compares the real-time and target capacity of the cluster.
        If the cluster does not meet the target capacity, the group will create instances
        until the cluster meets the target capacity.
        Default value: maintain
        """
        result = self._values.get("auto_provisioning_group_type")
        return result

    @builtins.property
    def default_target_capacity_type(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        defaultTargetCapacityType: The type of supplemental instances. When the total value of PayAsYouGoTargetCapacity and SpotTargetCapacity is smaller than the value of TotalTargetCapacity, the auto provisioning group will create instances of the specified type to meet
        the capacity requirements. Valid values:
        PayAsYouGo: Pay-as-you-go instances.
        Spot: Preemptible instances.
        Default value: Spot
        """
        result = self._values.get("default_target_capacity_type")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: The description of the auto provisioning group.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def excess_capacity_termination_policy(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        excessCapacityTerminationPolicy: The shutdown policy for excess preemptible instances followed when the capacity of
        the auto provisioning group exceeds the target capacity. Valid values:
        no-termination: Excess preemptible instances are not shut down.
        termination: Excess preemptible instances are to be shut down. The action to be performed on these
        shutdown instances is specified by the SpotInstanceInterruptionBehavior parameter.
        Default value: no-termination
        """
        result = self._values.get("excess_capacity_termination_policy")
        return result

    @builtins.property
    def launch_template_config(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosAutoProvisioningGroup.LaunchTemplateConfigProperty"]]]]:
        """
        :Property: launchTemplateConfig:
        """
        result = self._values.get("launch_template_config")
        return result

    @builtins.property
    def launch_template_version(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        launchTemplateVersion: The version of the instance launch template associated with the auto provisioning
        group. You can call the DescribeLaunchTemplateVersions operation to query the versions of available instance launch templates.
        """
        result = self._values.get("launch_template_version")
        return result

    @builtins.property
    def max_spot_price(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        maxSpotPrice: The global maximum price for preemptible instances in the auto provisioning group.
        If both the MaxSpotPrice and LaunchTemplateConfig.N.MaxPrice parameters are specified, the maximum price is the lower value of the two.
        """
        result = self._values.get("max_spot_price")
        return result

    @builtins.property
    def pay_as_you_go_allocation_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        payAsYouGoAllocationStrategy: The scale-out policy for pay-as-you-go instances. Valid values:
        lowest-price: The cost optimization policy the auto provisioning group follows to select instance
        types of the lowest cost to create instances.
        prioritized: The priority-based policy the auto provisioning group follows to create instances.
        The priority of an instance type is specified by the LaunchTemplateConfig.N.Priority parameter.
        Default value: lowest-price
        """
        result = self._values.get("pay_as_you_go_allocation_strategy")
        return result

    @builtins.property
    def pay_as_you_go_target_capacity(self) -> typing.Optional[builtins.str]:
        """
        :Property: payAsYouGoTargetCapacity: The target capacity of pay-as-you-go instances in the auto provisioning group.
        """
        result = self._values.get("pay_as_you_go_target_capacity")
        return result

    @builtins.property
    def spot_allocation_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        spotAllocationStrategy: The scale-out policy for preemptible instances. Valid values:
        lowest-price: The cost optimization policy the auto provisioning group follows to select instance
        types of the lowest cost to create instances.
        diversified: The distribution balancing policy the auto provisioning group follows to evenly create
        instances across zones specified in multiple extended template configurations.
        Default value: lowest-price
        """
        result = self._values.get("spot_allocation_strategy")
        return result

    @builtins.property
    def spot_instance_interruption_behavior(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        spotInstanceInterruptionBehavior: The default behavior after preemptible instances are shut down. Value values:
        stop: stops preemptible instances.
        terminate: releases preemptible instances.
        Default value: stop
        """
        result = self._values.get("spot_instance_interruption_behavior")
        return result

    @builtins.property
    def spot_instance_pools_to_use_count(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        spotInstancePoolsToUseCount: This parameter takes effect when the SpotAllocationStrategy parameter is set to lowest-price. The auto provisioning group selects instance types of the lowest cost to create
        instances.
        """
        result = self._values.get("spot_instance_pools_to_use_count")
        return result

    @builtins.property
    def spot_target_capacity(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotTargetCapacity: The target capacity of preemptible instances in the auto provisioning group.
        """
        result = self._values.get("spot_target_capacity")
        return result

    @builtins.property
    def terminate_instances(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        terminateInstances: Specifies whether to release instances of the auto provisioning group. Valid values:
        true
        false
        Default: false
        """
        result = self._values.get("terminate_instances")
        return result

    @builtins.property
    def terminate_instances_with_expiration(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        terminateInstancesWithExpiration: The shutdown policy for preemptible instances when the auto provisioning group expires.
        Valid values:
        true: shuts down preemptible instances. The action to be performed on these shutdown instances
        is specified by the SpotInstanceInterruptionBehavior parameter.
        false: does not shut down preemptible instances.
        Default: false
        """
        result = self._values.get("terminate_instances_with_expiration")
        return result

    @builtins.property
    def valid_from(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        validFrom: The time when the auto provisioning group is started. The period of time between this
        point in time and the point in time specified by the ValidUntil parameter is the effective time period of the auto provisioning group.
        By default, an auto provisioning group is immediately started after creation.
        """
        result = self._values.get("valid_from")
        return result

    @builtins.property
    def valid_until(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        validUntil: The time when the auto provisioning group expires. The period of time between this
        point in time and the point in time specified by the ValidFrom parameter is the effective time period of the auto provisioning group.
        By default, an auto provisioning group never expires.
        """
        result = self._values.get("valid_until")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AutoProvisioningGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AutoSnapshotPolicy(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.AutoSnapshotPolicy",
):
    """A ROS resource type:  ``ALIYUN::ECS::AutoSnapshotPolicy``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "AutoSnapshotPolicyProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::AutoSnapshotPolicy``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(AutoSnapshotPolicy, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrAutoSnapshotPolicyId")
    def attr_auto_snapshot_policy_id(self) -> typing.Any:
        """
        :Attribute: AutoSnapshotPolicyId: The automatic snapshot policy ID.
        """
        return jsii.get(self, "attrAutoSnapshotPolicyId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.AutoSnapshotPolicyProps",
    jsii_struct_bases=[],
    name_mapping={
        "repeat_weekdays": "repeatWeekdays",
        "retention_days": "retentionDays",
        "time_points": "timePoints",
        "auto_snapshot_policy_name": "autoSnapshotPolicyName",
        "disk_ids": "diskIds",
    },
)
class AutoSnapshotPolicyProps:
    def __init__(
        self,
        *,
        repeat_weekdays: typing.Union[typing.List[jsii.Number], ros_cdk_core.IResolvable],
        retention_days: jsii.Number,
        time_points: typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable],
        auto_snapshot_policy_name: typing.Optional[builtins.str] = None,
        disk_ids: typing.Optional[typing.List[builtins.str]] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::AutoSnapshotPolicy``.

        :param repeat_weekdays: 
        :param retention_days: 
        :param time_points: 
        :param auto_snapshot_policy_name: 
        :param disk_ids: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "repeat_weekdays": repeat_weekdays,
            "retention_days": retention_days,
            "time_points": time_points,
        }
        if auto_snapshot_policy_name is not None:
            self._values["auto_snapshot_policy_name"] = auto_snapshot_policy_name
        if disk_ids is not None:
            self._values["disk_ids"] = disk_ids

    @builtins.property
    def repeat_weekdays(
        self,
    ) -> typing.Union[typing.List[jsii.Number], ros_cdk_core.IResolvable]:
        """
        :Property:

        repeatWeekdays: The automatic snapshot repetition dates. The unit of measurement is day and the repeating cycle is a week. Value range: [1, 7], which represents days starting from Monday to Sunday, for example 1 indicates Monday. When you want to schedule multiple automatic snapshot tasks for a disk in a week, you can set the RepeatWeekdays to an array.
        A maximum of seven time points can be selected.
        The format is a list of [1, 2, ..., 7] and the time points are separated by commas (,).
        """
        result = self._values.get("repeat_weekdays")
        assert result is not None, "Required property 'repeat_weekdays' is missing"
        return result

    @builtins.property
    def retention_days(self) -> jsii.Number:
        """
        :Property:

        retentionDays: The snapshot retention time, and the unit of measurement is day. Optional values:
        -1: The automatic snapshots are retained permanently.
        [1, 65536]: The number of days retained.
        Default value: -1.
        """
        result = self._values.get("retention_days")
        assert result is not None, "Required property 'retention_days' is missing"
        return result

    @builtins.property
    def time_points(
        self,
    ) -> typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]:
        """
        :Property:

        timePoints: The automatic snapshot creation schedule, and the unit of measurement is hour. Value range: [0, 23], which represents from 00:00 to 24:00, for example 1 indicates 01:00. When you want to schedule multiple automatic snapshot tasks for a disk in a day, you can set the TimePoints to an array.
        A maximum of 24 time points can be selected.
        The format is a list of [0, 1, ..., 23] and the time points are separated by commas (,).
        """
        result = self._values.get("time_points")
        assert result is not None, "Required property 'time_points' is missing"
        return result

    @builtins.property
    def auto_snapshot_policy_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        autoSnapshotPolicyName: The name of the automatic snapshot policy.
        It can consist of [2, 128] English or Chinese characters.
        Must begin with an uppercase or lowercase letter or a Chinese character. Can contain numbers, periods (.), colons (:), underscores (_), and hyphens (-).
        Cannot start with http:// or https://.
        Default value: null.
        """
        result = self._values.get("auto_snapshot_policy_name")
        return result

    @builtins.property
    def disk_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        """
        :Property: diskIds: The disk ID. When you want to apply the automatic snapshot policy to multiple disks, you can set the DiskIds to an array. The format is list of ["d-xxxxxxxxx", "d-yyyyyyyyy", ..., "d-zzzzzzzzz"] and the IDs are separated by commas (,).
        """
        result = self._values.get("disk_ids")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AutoSnapshotPolicyProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class BandwidthPackage(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.BandwidthPackage",
):
    """A ROS resource type:  ``ALIYUN::ECS::BandwidthPackage``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "BandwidthPackageProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::BandwidthPackage``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(BandwidthPackage, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrBandwidthPackageId")
    def attr_bandwidth_package_id(self) -> typing.Any:
        """
        :Attribute: BandwidthPackageId: The bandwidth package id of created Bandwidth package.
        """
        return jsii.get(self, "attrBandwidthPackageId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrBandwidthPackageIps")
    def attr_bandwidth_package_ips(self) -> typing.Any:
        """
        :Attribute: BandwidthPackageIps: The allocated public IPs.
        """
        return jsii.get(self, "attrBandwidthPackageIps")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.BandwidthPackageProps",
    jsii_struct_bases=[],
    name_mapping={
        "bandwidth": "bandwidth",
        "ip_count": "ipCount",
        "nat_gateway_id": "natGatewayId",
        "bandwidth_package_name": "bandwidthPackageName",
        "description": "description",
        "internet_charge_type": "internetChargeType",
        "zone_id": "zoneId",
    },
)
class BandwidthPackageProps:
    def __init__(
        self,
        *,
        bandwidth: jsii.Number,
        ip_count: jsii.Number,
        nat_gateway_id: builtins.str,
        bandwidth_package_name: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        internet_charge_type: typing.Optional[builtins.str] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::BandwidthPackage``.

        :param bandwidth: 
        :param ip_count: 
        :param nat_gateway_id: 
        :param bandwidth_package_name: 
        :param description: 
        :param internet_charge_type: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "bandwidth": bandwidth,
            "ip_count": ip_count,
            "nat_gateway_id": nat_gateway_id,
        }
        if bandwidth_package_name is not None:
            self._values["bandwidth_package_name"] = bandwidth_package_name
        if description is not None:
            self._values["description"] = description
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def bandwidth(self) -> jsii.Number:
        """
        :Property: bandwidth: Bandwidth, [5-5000]M for PayByBandwidth, [5-50]M for PayByTraffic.
        """
        result = self._values.get("bandwidth")
        assert result is not None, "Required property 'bandwidth' is missing"
        return result

    @builtins.property
    def ip_count(self) -> jsii.Number:
        """
        :Property: ipCount: Total internet IPs of this Bandwidth package, [1-5]
        """
        result = self._values.get("ip_count")
        assert result is not None, "Required property 'ip_count' is missing"
        return result

    @builtins.property
    def nat_gateway_id(self) -> builtins.str:
        """
        :Property: natGatewayId: Create bandwidth package for specified NAT gateway
        """
        result = self._values.get("nat_gateway_id")
        assert result is not None, "Required property 'nat_gateway_id' is missing"
        return result

    @builtins.property
    def bandwidth_package_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: bandwidthPackageName: Display name of the bandwidth package, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("bandwidth_package_name")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the bandwidth package, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def internet_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: internetChargeType: Nat Gateway internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByTraffic
        """
        result = self._values.get("internet_charge_type")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: zoneId: The availability zone where the bandwidth package will be created.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BandwidthPackageProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Command(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.Command",
):
    """A ROS resource type:  ``ALIYUN::ECS::Command``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "CommandProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::Command``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(Command, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrCommandId")
    def attr_command_id(self) -> typing.Any:
        """
        :Attribute: CommandId: The id of command created.
        """
        return jsii.get(self, "attrCommandId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.CommandProps",
    jsii_struct_bases=[],
    name_mapping={
        "type": "type",
        "command_content": "commandContent",
        "description": "description",
        "enable_parameter": "enableParameter",
        "name": "name",
        "timeout": "timeout",
        "working_dir": "workingDir",
    },
)
class CommandProps:
    def __init__(
        self,
        *,
        type: builtins.str,
        command_content: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        enable_parameter: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        name: typing.Optional[builtins.str] = None,
        timeout: typing.Optional[jsii.Number] = None,
        working_dir: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::Command``.

        :param type: 
        :param command_content: 
        :param description: 
        :param enable_parameter: 
        :param name: 
        :param timeout: 
        :param working_dir: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if command_content is not None:
            self._values["command_content"] = command_content
        if description is not None:
            self._values["description"] = description
        if enable_parameter is not None:
            self._values["enable_parameter"] = enable_parameter
        if name is not None:
            self._values["name"] = name
        if timeout is not None:
            self._values["timeout"] = timeout
        if working_dir is not None:
            self._values["working_dir"] = working_dir

    @builtins.property
    def type(self) -> builtins.str:
        """
        :Property: type: The type of command.
        """
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return result

    @builtins.property
    def command_content(self) -> typing.Optional[builtins.str]:
        """
        :Property: commandContent: The content of command. Content requires base64 encoding. Maximum size support 16KB.
        """
        result = self._values.get("command_content")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: The description of command.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def enable_parameter(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        enableParameter: Specifies whether the script contains custom parameters.
        Default value: false
        """
        result = self._values.get("enable_parameter")
        return result

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """
        :Property: name: The name of command.
        """
        result = self._values.get("name")
        return result

    @builtins.property
    def timeout(self) -> typing.Optional[jsii.Number]:
        """
        :Property: timeout: Total timeout when the command is executed in the instance. Input the time unit as second. Default is 60s.
        """
        result = self._values.get("timeout")
        return result

    @builtins.property
    def working_dir(self) -> typing.Optional[builtins.str]:
        """
        :Property: workingDir: The path where command will be executed in the instance.
        """
        result = self._values.get("working_dir")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CommandProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CopyImage(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.CopyImage",
):
    """A ROS resource type:  ``ALIYUN::ECS::CopyImage``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "CopyImageProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::CopyImage``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(CopyImage, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrImageId")
    def attr_image_id(self) -> typing.Any:
        """
        :Attribute: ImageId: ID of the source custom image.
        """
        return jsii.get(self, "attrImageId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.CopyImageProps",
    jsii_struct_bases=[],
    name_mapping={
        "destination_region_id": "destinationRegionId",
        "image_id": "imageId",
        "destination_description": "destinationDescription",
        "destination_image_name": "destinationImageName",
        "encrypted": "encrypted",
        "kms_key_id": "kmsKeyId",
        "tag": "tag",
    },
)
class CopyImageProps:
    def __init__(
        self,
        *,
        destination_region_id: builtins.str,
        image_id: builtins.str,
        destination_description: typing.Optional[builtins.str] = None,
        destination_image_name: typing.Optional[builtins.str] = None,
        encrypted: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        kms_key_id: typing.Optional[builtins.str] = None,
        tag: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, ros_cdk_core.RosTag]]]] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::CopyImage``.

        :param destination_region_id: 
        :param image_id: 
        :param destination_description: 
        :param destination_image_name: 
        :param encrypted: 
        :param kms_key_id: 
        :param tag: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "destination_region_id": destination_region_id,
            "image_id": image_id,
        }
        if destination_description is not None:
            self._values["destination_description"] = destination_description
        if destination_image_name is not None:
            self._values["destination_image_name"] = destination_image_name
        if encrypted is not None:
            self._values["encrypted"] = encrypted
        if kms_key_id is not None:
            self._values["kms_key_id"] = kms_key_id
        if tag is not None:
            self._values["tag"] = tag

    @builtins.property
    def destination_region_id(self) -> builtins.str:
        """
        :Property: destinationRegionId: ID of the region to where the destination custom image belongs.
        """
        result = self._values.get("destination_region_id")
        assert result is not None, "Required property 'destination_region_id' is missing"
        return result

    @builtins.property
    def image_id(self) -> builtins.str:
        """
        :Property: imageId: ID of the source custom image.
        """
        result = self._values.get("image_id")
        assert result is not None, "Required property 'image_id' is missing"
        return result

    @builtins.property
    def destination_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: destinationDescription: The description of the destination custom image.It cannot begin with http:// or https://.  Default value: null.
        """
        result = self._values.get("destination_description")
        return result

    @builtins.property
    def destination_image_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: destinationImageName: Name of the destination custom image.The name is a string of 2 to 128 characters. It must begin with an English or a Chinese character. It can contain A-Z, a-z, Chinese characters, numbers, periods (.), colons (:), underscores (_), and hyphens (-).  Default value: null.
        """
        result = self._values.get("destination_image_name")
        return result

    @builtins.property
    def encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: encrypted: Whether to encrypt the image.
        """
        result = self._values.get("encrypted")
        return result

    @builtins.property
    def kms_key_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: kmsKeyId: The ID of the key used to encrypt the image.
        """
        result = self._values.get("kms_key_id")
        return result

    @builtins.property
    def tag(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, ros_cdk_core.RosTag]]]]:
        """
        :Property: tag:
        """
        result = self._values.get("tag")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CopyImageProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CustomImage(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.CustomImage",
):
    """A ROS resource type:  ``ALIYUN::ECS::CustomImage``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: typing.Optional["CustomImageProps"] = None,
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::CustomImage``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(CustomImage, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrImageId")
    def attr_image_id(self) -> typing.Any:
        """
        :Attribute: ImageId: Image ID
        """
        return jsii.get(self, "attrImageId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.CustomImageProps",
    jsii_struct_bases=[],
    name_mapping={
        "architecture": "architecture",
        "description": "description",
        "disk_device_mapping": "diskDeviceMapping",
        "image_name": "imageName",
        "instance_id": "instanceId",
        "platform": "platform",
        "resource_group_id": "resourceGroupId",
        "snapshot_id": "snapshotId",
        "tag": "tag",
    },
)
class CustomImageProps:
    def __init__(
        self,
        *,
        architecture: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        disk_device_mapping: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosCustomImage.DiskDeviceMappingProperty"]]]] = None,
        image_name: typing.Optional[builtins.str] = None,
        instance_id: typing.Optional[builtins.str] = None,
        platform: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        snapshot_id: typing.Optional[builtins.str] = None,
        tag: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, ros_cdk_core.RosTag]]]] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::CustomImage``.

        :param architecture: 
        :param description: 
        :param disk_device_mapping: 
        :param image_name: 
        :param instance_id: 
        :param platform: 
        :param resource_group_id: 
        :param snapshot_id: 
        :param tag: 
        """
        self._values: typing.Dict[str, typing.Any] = {}
        if architecture is not None:
            self._values["architecture"] = architecture
        if description is not None:
            self._values["description"] = description
        if disk_device_mapping is not None:
            self._values["disk_device_mapping"] = disk_device_mapping
        if image_name is not None:
            self._values["image_name"] = image_name
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if platform is not None:
            self._values["platform"] = platform
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if snapshot_id is not None:
            self._values["snapshot_id"] = snapshot_id
        if tag is not None:
            self._values["tag"] = tag

    @builtins.property
    def architecture(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        architecture: After specifying the data disk snapshot as the mirrored system disk, you need to determine the system architecture of the system disk through Architecture. Ranges:
        I386
        X86_64 (default)
        """
        result = self._values.get("architecture")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        description: The description of the image.
        It can be [0, 256] letters in length.
        It cannot begin with http:// or https://.
        Default value: null.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_device_mapping(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosCustomImage.DiskDeviceMappingProperty"]]]]:
        """
        :Property: diskDeviceMapping:
        """
        result = self._values.get("disk_device_mapping")
        return result

    @builtins.property
    def image_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        imageName: Image name.
        Can contain [2, 128] characters in length. Must begin with an English letter or Chinese character. Can contain digits, colons (:), underscores (_), or hyphens (-).
        Cannot begin with http:// or https://.
        """
        result = self._values.get("image_name")
        return result

    @builtins.property
    def instance_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceId: Instance ID.
        """
        result = self._values.get("instance_id")
        return result

    @builtins.property
    def platform(self) -> typing.Optional[builtins.str]:
        """
        :Property: platform: After specifying the data disk snapshot as the mirrored system disk, you need to determine the operating system release of the system disk through Platform.
        """
        result = self._values.get("platform")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: The enterprise resource group ID where the custom image is located.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def snapshot_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: snapshotId: The snapshot ID. A custom image is created from the specified snapshot.
        """
        result = self._values.get("snapshot_id")
        return result

    @builtins.property
    def tag(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, ros_cdk_core.RosTag]]]]:
        """
        :Property: tag:
        """
        result = self._values.get("tag")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CustomImageProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DedicatedHost(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.DedicatedHost",
):
    """A ROS resource type:  ``ALIYUN::ECS::DedicatedHost``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "DedicatedHostProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::DedicatedHost``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(DedicatedHost, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrDedicatedHostIds")
    def attr_dedicated_host_ids(self) -> typing.Any:
        """
        :Attribute: DedicatedHostIds: The host id list of created hosts
        """
        return jsii.get(self, "attrDedicatedHostIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> typing.Any:
        """
        :Attribute: OrderId: The order id list of created instance.
        """
        return jsii.get(self, "attrOrderId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.DedicatedHostProps",
    jsii_struct_bases=[],
    name_mapping={
        "dedicated_host_type": "dedicatedHostType",
        "action_on_maintenance": "actionOnMaintenance",
        "auto_placement": "autoPlacement",
        "auto_release_time": "autoReleaseTime",
        "auto_renew": "autoRenew",
        "auto_renew_period": "autoRenewPeriod",
        "charge_type": "chargeType",
        "dedicated_host_name": "dedicatedHostName",
        "description": "description",
        "network_attributes_slb_udp_timeout": "networkAttributesSlbUdpTimeout",
        "network_attributes_udp_timeout": "networkAttributesUdpTimeout",
        "period": "period",
        "period_unit": "periodUnit",
        "quantity": "quantity",
        "resource_group_id": "resourceGroupId",
        "tags": "tags",
        "zone_id": "zoneId",
    },
)
class DedicatedHostProps:
    def __init__(
        self,
        *,
        dedicated_host_type: builtins.str,
        action_on_maintenance: typing.Optional[builtins.str] = None,
        auto_placement: typing.Optional[builtins.str] = None,
        auto_release_time: typing.Optional[builtins.str] = None,
        auto_renew: typing.Optional[builtins.str] = None,
        auto_renew_period: typing.Optional[jsii.Number] = None,
        charge_type: typing.Optional[builtins.str] = None,
        dedicated_host_name: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        network_attributes_slb_udp_timeout: typing.Optional[jsii.Number] = None,
        network_attributes_udp_timeout: typing.Optional[jsii.Number] = None,
        period: typing.Optional[jsii.Number] = None,
        period_unit: typing.Optional[builtins.str] = None,
        quantity: typing.Optional[jsii.Number] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::DedicatedHost``.

        :param dedicated_host_type: 
        :param action_on_maintenance: 
        :param auto_placement: 
        :param auto_release_time: 
        :param auto_renew: 
        :param auto_renew_period: 
        :param charge_type: 
        :param dedicated_host_name: 
        :param description: 
        :param network_attributes_slb_udp_timeout: 
        :param network_attributes_udp_timeout: 
        :param period: 
        :param period_unit: 
        :param quantity: 
        :param resource_group_id: 
        :param tags: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "dedicated_host_type": dedicated_host_type,
        }
        if action_on_maintenance is not None:
            self._values["action_on_maintenance"] = action_on_maintenance
        if auto_placement is not None:
            self._values["auto_placement"] = auto_placement
        if auto_release_time is not None:
            self._values["auto_release_time"] = auto_release_time
        if auto_renew is not None:
            self._values["auto_renew"] = auto_renew
        if auto_renew_period is not None:
            self._values["auto_renew_period"] = auto_renew_period
        if charge_type is not None:
            self._values["charge_type"] = charge_type
        if dedicated_host_name is not None:
            self._values["dedicated_host_name"] = dedicated_host_name
        if description is not None:
            self._values["description"] = description
        if network_attributes_slb_udp_timeout is not None:
            self._values["network_attributes_slb_udp_timeout"] = network_attributes_slb_udp_timeout
        if network_attributes_udp_timeout is not None:
            self._values["network_attributes_udp_timeout"] = network_attributes_udp_timeout
        if period is not None:
            self._values["period"] = period
        if period_unit is not None:
            self._values["period_unit"] = period_unit
        if quantity is not None:
            self._values["quantity"] = quantity
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if tags is not None:
            self._values["tags"] = tags
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def dedicated_host_type(self) -> builtins.str:
        """
        :Property: dedicatedHostType: The instance type of host.
        """
        result = self._values.get("dedicated_host_type")
        assert result is not None, "Required property 'dedicated_host_type' is missing"
        return result

    @builtins.property
    def action_on_maintenance(self) -> typing.Optional[builtins.str]:
        """
        :Property: actionOnMaintenance: The policy used to migrate the instances from the dedicated hostwhen the dedicated host fails or needs to be repaired online.Valid values: Migrate: Instances are migrated to another physical server and restarted.If the dedicated host is attached with disks that are not local disks, the default value is Migrate.Stop: Instances on the dedicated host are stopped. If the dedicated host cannot be repaired,the instances are migrated to another physical server and restarted.If the dedicated host is attached with local disks, the default value is Stop.
        """
        result = self._values.get("action_on_maintenance")
        return result

    @builtins.property
    def auto_placement(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoPlacement: Specifies whether the dedicated host is added to the resource pool for automatic deployment. If you do not specify the DedicatedHostId parameter when you create an instance on a dedicated host, Alibaba Cloud automatically selects a dedicated host from the resource pool to host the instance. For more information, see Automatic deployment. Valid values:on: The dedicated host is added to the resource pool for automatic deployment.off: The dedicated host is not added to the resource pool for automatic deployment.Default value: on.Note When you create a dedicated host: If you do not specify this parameter, the dedicated host is added to the automatic deployment resource pool.If you do not want to add the dedicated host to the automatic deployment resource pool, set the value to off.
        """
        result = self._values.get("auto_placement")
        return result

    @builtins.property
    def auto_release_time(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoReleaseTime: Auto release time for created host, Follow ISO8601 standard using UTC time. format is 'yyyy-MM-ddTHH:mm:ssZ'. Not bigger than 3 years from this day onwards
        """
        result = self._values.get("auto_release_time")
        return result

    @builtins.property
    def auto_renew(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoRenew: Whether renew the fee automatically? When the parameter InstanceChargeType is PrePaid, it will take effect. Range of value:True: automatic renewal.False: no automatic renewal. Default value is False.
        """
        result = self._values.get("auto_renew")
        return result

    @builtins.property
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.
        """
        result = self._values.get("auto_renew_period")
        return result

    @builtins.property
    def charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: chargeType: Instance Charge type, allowed value: Prepaid and Postpaid. If specified Prepaid, please ensure you have sufficient balance in your account. Or instance creation will be failure. Default value is Postpaid.
        """
        result = self._values.get("charge_type")
        return result

    @builtins.property
    def dedicated_host_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: dedicatedHostName: The name of the dedicated host, [2, 128] English or Chinese characters. It must begin with an uppercase/lowercase letter or a Chinese character, and may contain numbers, '_' or '-'. It cannot begin with http:// or https://.
        """
        result = self._values.get("dedicated_host_name")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: The description of host.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def network_attributes_slb_udp_timeout(self) -> typing.Optional[jsii.Number]:
        """
        :Property: networkAttributesSlbUdpTimeout: The duration of UDP timeout for sessions between Server Load Balancer (SLB) and the dedicated host. Unit: seconds. Valid values: 15 to 310.
        """
        result = self._values.get("network_attributes_slb_udp_timeout")
        return result

    @builtins.property
    def network_attributes_udp_timeout(self) -> typing.Optional[jsii.Number]:
        """
        :Property: networkAttributesUdpTimeout: The duration of UDP timeout for sessions between users and instances on the dedicated host. Unit: seconds. Valid values: 15 to 310.
        """
        result = self._values.get("network_attributes_udp_timeout")
        return result

    @builtins.property
    def period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: period: Prepaid time period. Unit is month, it could be from 1 to 9 or 12, 24, 36, 48, 60. Default value is 1.
        """
        result = self._values.get("period")
        return result

    @builtins.property
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month/Year. Default value is Month.
        """
        result = self._values.get("period_unit")
        return result

    @builtins.property
    def quantity(self) -> typing.Optional[jsii.Number]:
        """
        :Property: quantity: The number of dedicated hosts that you want to create. Valid values: 1 to 100.Default value: 1.
        """
        result = self._values.get("quantity")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: The ID of the resource group. If this is left blank, the system automatically fills in the ID of the default resource group.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property: tags: Tags to attach to DedicatedHost. Max support 20 tags to add during create DedicatedHost. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: zoneId: The zone to create the host.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DedicatedHostProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DeploymentSet(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.DeploymentSet",
):
    """A ROS resource type:  ``ALIYUN::ECS::DeploymentSet``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: typing.Optional["DeploymentSetProps"] = None,
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::DeploymentSet``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(DeploymentSet, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrDeploymentSetId")
    def attr_deployment_set_id(self) -> typing.Any:
        """
        :Attribute: DeploymentSetId: The ID of the deployment set.
        """
        return jsii.get(self, "attrDeploymentSetId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.DeploymentSetProps",
    jsii_struct_bases=[],
    name_mapping={
        "deployment_set_name": "deploymentSetName",
        "description": "description",
        "on_unable_to_redeploy_failed_instance": "onUnableToRedeployFailedInstance",
    },
)
class DeploymentSetProps:
    def __init__(
        self,
        *,
        deployment_set_name: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        on_unable_to_redeploy_failed_instance: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::DeploymentSet``.

        :param deployment_set_name: 
        :param description: 
        :param on_unable_to_redeploy_failed_instance: 
        """
        self._values: typing.Dict[str, typing.Any] = {}
        if deployment_set_name is not None:
            self._values["deployment_set_name"] = deployment_set_name
        if description is not None:
            self._values["description"] = description
        if on_unable_to_redeploy_failed_instance is not None:
            self._values["on_unable_to_redeploy_failed_instance"] = on_unable_to_redeploy_failed_instance

    @builtins.property
    def deployment_set_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        deploymentSetName: The name of the deployment set. It must be 2 to 128 characters in length. It must
        start with a letter and cannot start with http:// or https://. It can contain letters,
        digits, colons (:), underscores (_), and hyphens (-).
        """
        result = self._values.get("deployment_set_name")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        description: The description of the deployment set. It must be 2 to 256 characters in length. It
        cannot start with http:// or https://.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def on_unable_to_redeploy_failed_instance(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        onUnableToRedeployFailedInstance: The emergency solution to redeploy failed instances in the deployment set. Valid values:
        CancelMembershipAndStart: restarts the instances immediately after they are shut down
        and migrated to other deployment sets. This is the default value.
        KeepStopped: keeps the instances shut down and restarts them after the deployment
        set is replenished.
        """
        result = self._values.get("on_unable_to_redeploy_failed_instance")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DeploymentSetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Disk(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.Disk",
):
    """A ROS resource type:  ``ALIYUN::ECS::Disk``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "DiskProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::Disk``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(Disk, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrDiskId")
    def attr_disk_id(self) -> typing.Any:
        """
        :Attribute: DiskId: Id of created disk.
        """
        return jsii.get(self, "attrDiskId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrStatus")
    def attr_status(self) -> typing.Any:
        """
        :Attribute: Status: Created disk status.
        """
        return jsii.get(self, "attrStatus")


class DiskAttachment(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.DiskAttachment",
):
    """A ROS resource type:  ``ALIYUN::ECS::DiskAttachment``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "DiskAttachmentProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::DiskAttachment``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(DiskAttachment, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrDevice")
    def attr_device(self) -> typing.Any:
        """
        :Attribute: Device: The device where the volume is exposed on ecs instance.
        """
        return jsii.get(self, "attrDevice")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrDiskId")
    def attr_disk_id(self) -> typing.Any:
        """
        :Attribute: DiskId: The disk id of created disk
        """
        return jsii.get(self, "attrDiskId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrStatus")
    def attr_status(self) -> typing.Any:
        """
        :Attribute: Status: The disk status now.
        """
        return jsii.get(self, "attrStatus")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.DiskAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "disk_id": "diskId",
        "instance_id": "instanceId",
        "delete_auto_snapshot": "deleteAutoSnapshot",
        "delete_with_instance": "deleteWithInstance",
        "device": "device",
    },
)
class DiskAttachmentProps:
    def __init__(
        self,
        *,
        disk_id: builtins.str,
        instance_id: builtins.str,
        delete_auto_snapshot: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        delete_with_instance: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        device: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::DiskAttachment``.

        :param disk_id: 
        :param instance_id: 
        :param delete_auto_snapshot: 
        :param delete_with_instance: 
        :param device: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "disk_id": disk_id,
            "instance_id": instance_id,
        }
        if delete_auto_snapshot is not None:
            self._values["delete_auto_snapshot"] = delete_auto_snapshot
        if delete_with_instance is not None:
            self._values["delete_with_instance"] = delete_with_instance
        if device is not None:
            self._values["device"] = device

    @builtins.property
    def disk_id(self) -> builtins.str:
        """
        :Property: diskId: The disk id to attached.
        """
        result = self._values.get("disk_id")
        assert result is not None, "Required property 'disk_id' is missing"
        return result

    @builtins.property
    def instance_id(self) -> builtins.str:
        """
        :Property: instanceId: The instanceId to attach the disk.
        """
        result = self._values.get("instance_id")
        assert result is not None, "Required property 'instance_id' is missing"
        return result

    @builtins.property
    def delete_auto_snapshot(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deleteAutoSnapshot: Whether the auto snapshot is released with the disk. Default to true.
        """
        result = self._values.get("delete_auto_snapshot")
        return result

    @builtins.property
    def delete_with_instance(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deleteWithInstance: If property is true, the disk will be deleted while instance is deleted, if property is false, the disk will be retain after instance is deleted.
        """
        result = self._values.get("delete_with_instance")
        return result

    @builtins.property
    def device(self) -> typing.Optional[builtins.str]:
        """
        :Property: device: The device where the volume is exposed on the instance. could be /dev/xvd[b-z]. If not specification, will use default value.
        """
        result = self._values.get("device")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DiskAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.DiskProps",
    jsii_struct_bases=[],
    name_mapping={
        "zone_id": "zoneId",
        "auto_snapshot_policy_id": "autoSnapshotPolicyId",
        "delete_auto_snapshot": "deleteAutoSnapshot",
        "description": "description",
        "disk_category": "diskCategory",
        "disk_name": "diskName",
        "encrypted": "encrypted",
        "kms_key_id": "kmsKeyId",
        "performance_level": "performanceLevel",
        "resource_group_id": "resourceGroupId",
        "size": "size",
        "snapshot_id": "snapshotId",
        "storage_set_id": "storageSetId",
        "storage_set_partition_number": "storageSetPartitionNumber",
        "tags": "tags",
    },
)
class DiskProps:
    def __init__(
        self,
        *,
        zone_id: builtins.str,
        auto_snapshot_policy_id: typing.Optional[builtins.str] = None,
        delete_auto_snapshot: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        description: typing.Optional[builtins.str] = None,
        disk_category: typing.Optional[builtins.str] = None,
        disk_name: typing.Optional[builtins.str] = None,
        encrypted: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        kms_key_id: typing.Optional[builtins.str] = None,
        performance_level: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        size: typing.Optional[jsii.Number] = None,
        snapshot_id: typing.Optional[builtins.str] = None,
        storage_set_id: typing.Optional[builtins.str] = None,
        storage_set_partition_number: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::Disk``.

        :param zone_id: 
        :param auto_snapshot_policy_id: 
        :param delete_auto_snapshot: 
        :param description: 
        :param disk_category: 
        :param disk_name: 
        :param encrypted: 
        :param kms_key_id: 
        :param performance_level: 
        :param resource_group_id: 
        :param size: 
        :param snapshot_id: 
        :param storage_set_id: 
        :param storage_set_partition_number: 
        :param tags: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "zone_id": zone_id,
        }
        if auto_snapshot_policy_id is not None:
            self._values["auto_snapshot_policy_id"] = auto_snapshot_policy_id
        if delete_auto_snapshot is not None:
            self._values["delete_auto_snapshot"] = delete_auto_snapshot
        if description is not None:
            self._values["description"] = description
        if disk_category is not None:
            self._values["disk_category"] = disk_category
        if disk_name is not None:
            self._values["disk_name"] = disk_name
        if encrypted is not None:
            self._values["encrypted"] = encrypted
        if kms_key_id is not None:
            self._values["kms_key_id"] = kms_key_id
        if performance_level is not None:
            self._values["performance_level"] = performance_level
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if size is not None:
            self._values["size"] = size
        if snapshot_id is not None:
            self._values["snapshot_id"] = snapshot_id
        if storage_set_id is not None:
            self._values["storage_set_id"] = storage_set_id
        if storage_set_partition_number is not None:
            self._values["storage_set_partition_number"] = storage_set_partition_number
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def zone_id(self) -> builtins.str:
        """
        :Property: zoneId: The availability zone in which the volume will be created.
        """
        result = self._values.get("zone_id")
        assert result is not None, "Required property 'zone_id' is missing"
        return result

    @builtins.property
    def auto_snapshot_policy_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoSnapshotPolicyId: Auto snapshot policy ID.
        """
        result = self._values.get("auto_snapshot_policy_id")
        return result

    @builtins.property
    def delete_auto_snapshot(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deleteAutoSnapshot: Whether the auto snapshot is released with the disk. Default to false.
        """
        result = self._values.get("delete_auto_snapshot")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the disk, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: diskCategory: The disk category, now support cloud/cloud_ssd/cloud_essd/cloud_efficiency/san_ssd/san_efficiency, depends the region.
        """
        result = self._values.get("disk_category")
        return result

    @builtins.property
    def disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: diskName: Display name of the disk, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("disk_name")
        return result

    @builtins.property
    def encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: encrypted: Whether disk is encrypted, default to false.
        """
        result = self._values.get("encrypted")
        return result

    @builtins.property
    def kms_key_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: kmsKeyId: KMS key ID used by the cloud disk.
        """
        result = self._values.get("kms_key_id")
        return result

    @builtins.property
    def performance_level(self) -> typing.Optional[builtins.str]:
        """
        :Property: performanceLevel: The performance level you select for an ESSD.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
        """
        result = self._values.get("performance_level")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def size(self) -> typing.Optional[jsii.Number]:
        """
        :Property: size: The size of the disk unit in GB.
        """
        result = self._values.get("size")
        return result

    @builtins.property
    def snapshot_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: snapshotId: If specified, the backup used as the source to create disk.
        """
        result = self._values.get("snapshot_id")
        return result

    @builtins.property
    def storage_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: storageSetId: Storage set ID.
        """
        result = self._values.get("storage_set_id")
        return result

    @builtins.property
    def storage_set_partition_number(self) -> typing.Optional[jsii.Number]:
        """
        :Property: storageSetPartitionNumber: The number of storage set partitions.
        """
        result = self._values.get("storage_set_partition_number")
        return result

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property: tags: Tags to attach to disk. Max support 20 tags to add during create disk. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DiskProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ForwardEntry(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.ForwardEntry",
):
    """A ROS resource type:  ``ALIYUN::ECS::ForwardEntry``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "ForwardEntryProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::ForwardEntry``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(ForwardEntry, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrForwardEntryId")
    def attr_forward_entry_id(self) -> typing.Any:
        """
        :Attribute: ForwardEntryId: The id of created forward entry.
        """
        return jsii.get(self, "attrForwardEntryId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.ForwardEntryProps",
    jsii_struct_bases=[],
    name_mapping={
        "external_ip": "externalIp",
        "external_port": "externalPort",
        "forward_table_id": "forwardTableId",
        "internal_ip": "internalIp",
        "internal_port": "internalPort",
        "ip_protocol": "ipProtocol",
    },
)
class ForwardEntryProps:
    def __init__(
        self,
        *,
        external_ip: builtins.str,
        external_port: builtins.str,
        forward_table_id: builtins.str,
        internal_ip: builtins.str,
        internal_port: builtins.str,
        ip_protocol: builtins.str,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::ForwardEntry``.

        :param external_ip: 
        :param external_port: 
        :param forward_table_id: 
        :param internal_ip: 
        :param internal_port: 
        :param ip_protocol: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "external_ip": external_ip,
            "external_port": external_port,
            "forward_table_id": forward_table_id,
            "internal_ip": internal_ip,
            "internal_port": internal_port,
            "ip_protocol": ip_protocol,
        }

    @builtins.property
    def external_ip(self) -> builtins.str:
        """
        :Property: externalIp: Source IP, must belongs to bandwidth package internet IP
        """
        result = self._values.get("external_ip")
        assert result is not None, "Required property 'external_ip' is missing"
        return result

    @builtins.property
    def external_port(self) -> builtins.str:
        """
        :Property: externalPort: Source port, now support [1-65535]|Any
        """
        result = self._values.get("external_port")
        assert result is not None, "Required property 'external_port' is missing"
        return result

    @builtins.property
    def forward_table_id(self) -> builtins.str:
        """
        :Property: forwardTableId: Create forward entry in specified forward table.
        """
        result = self._values.get("forward_table_id")
        assert result is not None, "Required property 'forward_table_id' is missing"
        return result

    @builtins.property
    def internal_ip(self) -> builtins.str:
        """
        :Property: internalIp: Destination IP, must belong to VPC private IP
        """
        result = self._values.get("internal_ip")
        assert result is not None, "Required property 'internal_ip' is missing"
        return result

    @builtins.property
    def internal_port(self) -> builtins.str:
        """
        :Property: internalPort: Destination port, now support [1-65535]|Any
        """
        result = self._values.get("internal_port")
        assert result is not None, "Required property 'internal_port' is missing"
        return result

    @builtins.property
    def ip_protocol(self) -> builtins.str:
        """
        :Property: ipProtocol: Supported protocol, Now support 'TCP|UDP|Any'
        """
        result = self._values.get("ip_protocol")
        assert result is not None, "Required property 'ip_protocol' is missing"
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ForwardEntryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class HpcCluster(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.HpcCluster",
):
    """A ROS resource type:  ``ALIYUN::ECS::HpcCluster``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "HpcClusterProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::HpcCluster``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(HpcCluster, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrHpcClusterId")
    def attr_hpc_cluster_id(self) -> typing.Any:
        """
        :Attribute: HpcClusterId: The ID of the HPC cluster.
        """
        return jsii.get(self, "attrHpcClusterId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrName")
    def attr_name(self) -> typing.Any:
        """
        :Attribute: Name: The name of the HPC cluster.
        """
        return jsii.get(self, "attrName")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.HpcClusterProps",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "description": "description"},
)
class HpcClusterProps:
    def __init__(
        self,
        *,
        name: builtins.str,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::HpcCluster``.

        :param name: 
        :param description: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if description is not None:
            self._values["description"] = description

    @builtins.property
    def name(self) -> builtins.str:
        """
        :Property:

        name: The name of the HPC cluster. The name must be 2 to 128 characters in length. It must
        start with a letter but cannot start with http:// or https://. It can contain letters,
        digits, colons (:), underscores (_), and hyphens (-).
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        description: The description of the HPC cluster. The description must be 2 to 256 characters in
        length. It cannot start with http:// or https://. Default value: empty string.
        """
        result = self._values.get("description")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "HpcClusterProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Instance(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.Instance",
):
    """A ROS resource type:  ``ALIYUN::ECS::Instance``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "InstanceProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::Instance``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(Instance, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrHostName")
    def attr_host_name(self) -> typing.Any:
        """
        :Attribute: HostName: Host name of created instance.
        """
        return jsii.get(self, "attrHostName")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInnerIp")
    def attr_inner_ip(self) -> typing.Any:
        """
        :Attribute: InnerIp: Inner IP address of the specified instance. Only for classical instance.
        """
        return jsii.get(self, "attrInnerIp")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInstanceId")
    def attr_instance_id(self) -> typing.Any:
        """
        :Attribute: InstanceId: The instance id of created ecs instance
        """
        return jsii.get(self, "attrInstanceId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrimaryNetworkInterfaceId")
    def attr_primary_network_interface_id(self) -> typing.Any:
        """
        :Attribute: PrimaryNetworkInterfaceId: Primary network interface id of created instance.
        """
        return jsii.get(self, "attrPrimaryNetworkInterfaceId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateIp")
    def attr_private_ip(self) -> typing.Any:
        """
        :Attribute: PrivateIp: Private IP address of created ecs instance. Only for VPC instance.
        """
        return jsii.get(self, "attrPrivateIp")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPublicIp")
    def attr_public_ip(self) -> typing.Any:
        """
        :Attribute: PublicIp: Public IP address of created ecs instance.
        """
        return jsii.get(self, "attrPublicIp")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrZoneId")
    def attr_zone_id(self) -> typing.Any:
        """
        :Attribute: ZoneId: Zone id of created instance.
        """
        return jsii.get(self, "attrZoneId")


class InstanceClone(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.InstanceClone",
):
    """A ROS resource type:  ``ALIYUN::ECS::InstanceClone``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "InstanceCloneProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::InstanceClone``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(InstanceClone, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrHostName")
    def attr_host_name(self) -> typing.Any:
        """
        :Attribute: HostName: Host name of created instance.
        """
        return jsii.get(self, "attrHostName")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInnerIp")
    def attr_inner_ip(self) -> typing.Any:
        """
        :Attribute: InnerIp: Inner IP address of the specified instance. Only for classical instance.
        """
        return jsii.get(self, "attrInnerIp")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInstanceId")
    def attr_instance_id(self) -> typing.Any:
        """
        :Attribute: InstanceId: The instance id of created ecs instance
        """
        return jsii.get(self, "attrInstanceId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrimaryNetworkInterfaceId")
    def attr_primary_network_interface_id(self) -> typing.Any:
        """
        :Attribute: PrimaryNetworkInterfaceId: Primary network interface id of created instance.
        """
        return jsii.get(self, "attrPrimaryNetworkInterfaceId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateIp")
    def attr_private_ip(self) -> typing.Any:
        """
        :Attribute: PrivateIp: Private IP address of created ecs instance. Only for VPC instance.
        """
        return jsii.get(self, "attrPrivateIp")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPublicIp")
    def attr_public_ip(self) -> typing.Any:
        """
        :Attribute: PublicIp: Public IP address of created ecs instance.
        """
        return jsii.get(self, "attrPublicIp")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrZoneId")
    def attr_zone_id(self) -> typing.Any:
        """
        :Attribute: ZoneId: Zone id of created instance.
        """
        return jsii.get(self, "attrZoneId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.InstanceCloneProps",
    jsii_struct_bases=[],
    name_mapping={
        "source_instance_id": "sourceInstanceId",
        "backend_server_weight": "backendServerWeight",
        "deletion_protection": "deletionProtection",
        "description": "description",
        "disk_mappings": "diskMappings",
        "image_id": "imageId",
        "instance_charge_type": "instanceChargeType",
        "instance_name": "instanceName",
        "internet_max_bandwidth_in": "internetMaxBandwidthIn",
        "key_pair_name": "keyPairName",
        "load_balancer_id_to_attach": "loadBalancerIdToAttach",
        "password": "password",
        "period": "period",
        "ram_role_name": "ramRoleName",
        "resource_group_id": "resourceGroupId",
        "security_group_id": "securityGroupId",
        "spot_price_limit": "spotPriceLimit",
        "spot_strategy": "spotStrategy",
        "tags": "tags",
        "zone_id": "zoneId",
    },
)
class InstanceCloneProps:
    def __init__(
        self,
        *,
        source_instance_id: builtins.str,
        backend_server_weight: typing.Optional[jsii.Number] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        description: typing.Optional[builtins.str] = None,
        disk_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceClone.DiskMappingsProperty"]]]] = None,
        image_id: typing.Optional[builtins.str] = None,
        instance_charge_type: typing.Optional[builtins.str] = None,
        instance_name: typing.Optional[builtins.str] = None,
        internet_max_bandwidth_in: typing.Optional[jsii.Number] = None,
        key_pair_name: typing.Optional[builtins.str] = None,
        load_balancer_id_to_attach: typing.Optional[builtins.str] = None,
        password: typing.Optional[builtins.str] = None,
        period: typing.Optional[jsii.Number] = None,
        ram_role_name: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        spot_price_limit: typing.Optional[builtins.str] = None,
        spot_strategy: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::InstanceClone``.

        :param source_instance_id: 
        :param backend_server_weight: 
        :param deletion_protection: 
        :param description: 
        :param disk_mappings: 
        :param image_id: 
        :param instance_charge_type: 
        :param instance_name: 
        :param internet_max_bandwidth_in: 
        :param key_pair_name: 
        :param load_balancer_id_to_attach: 
        :param password: 
        :param period: 
        :param ram_role_name: 
        :param resource_group_id: 
        :param security_group_id: 
        :param spot_price_limit: 
        :param spot_strategy: 
        :param tags: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "source_instance_id": source_instance_id,
        }
        if backend_server_weight is not None:
            self._values["backend_server_weight"] = backend_server_weight
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if description is not None:
            self._values["description"] = description
        if disk_mappings is not None:
            self._values["disk_mappings"] = disk_mappings
        if image_id is not None:
            self._values["image_id"] = image_id
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if internet_max_bandwidth_in is not None:
            self._values["internet_max_bandwidth_in"] = internet_max_bandwidth_in
        if key_pair_name is not None:
            self._values["key_pair_name"] = key_pair_name
        if load_balancer_id_to_attach is not None:
            self._values["load_balancer_id_to_attach"] = load_balancer_id_to_attach
        if password is not None:
            self._values["password"] = password
        if period is not None:
            self._values["period"] = period
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if spot_price_limit is not None:
            self._values["spot_price_limit"] = spot_price_limit
        if spot_strategy is not None:
            self._values["spot_strategy"] = spot_strategy
        if tags is not None:
            self._values["tags"] = tags
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def source_instance_id(self) -> builtins.str:
        """
        :Property: sourceInstanceId: Source ecs instance used to copy properties to clone new ecs instance. It will copy the InstanceType, ImageId, InternetChargeType, InternetMaxBandwidthIn, InternetMaxBandwidthOut and the system disk and data disk configurations. If the instance network is VPC, it will also clone the relative properties. If specified instance with more than one security group, it will use the first security group to create instance. you can also specify the SecurityGroupId to override it.
        """
        result = self._values.get("source_instance_id")
        assert result is not None, "Required property 'source_instance_id' is missing"
        return result

    @builtins.property
    def backend_server_weight(self) -> typing.Optional[jsii.Number]:
        """
        :Property: backendServerWeight: The weight of backend server of load balancer. From 0 to 100, 0 means offline. Default is 100.
        """
        result = self._values.get("backend_server_weight")
        return result

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deletionProtection: Whether an instance can be released manually through the console or API, deletion protection only support postPaid instance
        """
        result = self._values.get("deletion_protection")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceClone.DiskMappingsProperty"]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.
        """
        result = self._values.get("disk_mappings")
        return result

    @builtins.property
    def image_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        result = self._values.get("image_id")
        return result

    @builtins.property
    def instance_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceChargeType: Instance Charge type, allowed value: Prepaid and Postpaid. If specified Prepaid, please ensure you have sufficient balance in your account. Or instance creation will be failure. Default value is Postpaid.
        """
        result = self._values.get("instance_charge_type")
        return result

    @builtins.property
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("instance_name")
        return result

    @builtins.property
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        result = self._values.get("internet_max_bandwidth_in")
        return result

    @builtins.property
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.
        """
        result = self._values.get("key_pair_name")
        return result

    @builtins.property
    def load_balancer_id_to_attach(self) -> typing.Optional[builtins.str]:
        """
        :Property: loadBalancerIdToAttach: After the instance is created. Automatic attach it to the load balancer.
        """
        result = self._values.get("load_balancer_id_to_attach")
        return result

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        result = self._values.get("password")
        return result

    @builtins.property
    def period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: period: Prepaid time period. Unit is month, it could be from 1 to 9 or 12, 24, 36, 48, 60. Default value is 1.
        """
        result = self._values.get("period")
        return result

    @builtins.property
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        result = self._values.get("ram_role_name")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def spot_price_limit(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotPriceLimit: The hourly price threshold of a instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Three decimals is allowed at most.
        """
        result = self._values.get("spot_price_limit")
        return result

    @builtins.property
    def spot_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotStrategy: The spot strategy of a Pay-As-You-Go instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Value range: "NoSpot: A regular Pay-As-You-Go instance", "SpotWithPriceLimit: A price threshold for a spot instance, ""SpotAsPriceGo: A price that is based on the highest Pay-As-You-Go instance. "Default value: NoSpot.
        """
        result = self._values.get("spot_strategy")
        return result

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InstanceCloneProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class InstanceGroup(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.InstanceGroup",
):
    """A ROS resource type:  ``ALIYUN::ECS::InstanceGroup``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "InstanceGroupProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::InstanceGroup``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(InstanceGroup, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrHostNames")
    def attr_host_names(self) -> typing.Any:
        """
        :Attribute: HostNames: Host names of created instance.
        """
        return jsii.get(self, "attrHostNames")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInnerIps")
    def attr_inner_ips(self) -> typing.Any:
        """
        :Attribute: InnerIps: Inner IP address list of the specified instance. Only for classical instance.
        """
        return jsii.get(self, "attrInnerIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInstanceIds")
    def attr_instance_ids(self) -> typing.Any:
        """
        :Attribute: InstanceIds: The instance id list of created ecs instance
        """
        return jsii.get(self, "attrInstanceIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> typing.Any:
        """
        :Attribute: OrderId: The order id list of created instance.
        """
        return jsii.get(self, "attrOrderId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateIps")
    def attr_private_ips(self) -> typing.Any:
        """
        :Attribute: PrivateIps: Private IP address list of created ecs instance. Only for VPC instance.
        """
        return jsii.get(self, "attrPrivateIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPublicIps")
    def attr_public_ips(self) -> typing.Any:
        """
        :Attribute: PublicIps: Public IP address list of created ecs instance.
        """
        return jsii.get(self, "attrPublicIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrZoneIds")
    def attr_zone_ids(self) -> typing.Any:
        """
        :Attribute: ZoneIds: Zone id of created instance.
        """
        return jsii.get(self, "attrZoneIds")


class InstanceGroupClone(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.InstanceGroupClone",
):
    """A ROS resource type:  ``ALIYUN::ECS::InstanceGroupClone``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "InstanceGroupCloneProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::InstanceGroupClone``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(InstanceGroupClone, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrHostNames")
    def attr_host_names(self) -> typing.Any:
        """
        :Attribute: HostNames: Host names of created instance.
        """
        return jsii.get(self, "attrHostNames")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInnerIps")
    def attr_inner_ips(self) -> typing.Any:
        """
        :Attribute: InnerIps: Inner IP address list of the specified instance. Only for classical instance.
        """
        return jsii.get(self, "attrInnerIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInstanceIds")
    def attr_instance_ids(self) -> typing.Any:
        """
        :Attribute: InstanceIds: The instance id list of created ecs instance
        """
        return jsii.get(self, "attrInstanceIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> typing.Any:
        """
        :Attribute: OrderId: The order id list of created instance.
        """
        return jsii.get(self, "attrOrderId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateIps")
    def attr_private_ips(self) -> typing.Any:
        """
        :Attribute: PrivateIps: Private IP address list of created ecs instance. Only for VPC instance.
        """
        return jsii.get(self, "attrPrivateIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPublicIps")
    def attr_public_ips(self) -> typing.Any:
        """
        :Attribute: PublicIps: Public IP address list of created ecs instance.
        """
        return jsii.get(self, "attrPublicIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrZoneIds")
    def attr_zone_ids(self) -> typing.Any:
        """
        :Attribute: ZoneIds: Zone id of created instance.
        """
        return jsii.get(self, "attrZoneIds")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.InstanceGroupCloneProps",
    jsii_struct_bases=[],
    name_mapping={
        "max_amount": "maxAmount",
        "source_instance_id": "sourceInstanceId",
        "auto_release_time": "autoReleaseTime",
        "auto_renew": "autoRenew",
        "auto_renew_period": "autoRenewPeriod",
        "backend_server_weight": "backendServerWeight",
        "deletion_protection": "deletionProtection",
        "deployment_set_id": "deploymentSetId",
        "description": "description",
        "disk_mappings": "diskMappings",
        "eni_mappings": "eniMappings",
        "hpc_cluster_id": "hpcClusterId",
        "image_id": "imageId",
        "instance_name": "instanceName",
        "internet_max_bandwidth_in": "internetMaxBandwidthIn",
        "internet_max_bandwidth_out": "internetMaxBandwidthOut",
        "ipv6_address_count": "ipv6AddressCount",
        "ipv6_addresses": "ipv6Addresses",
        "key_pair_name": "keyPairName",
        "launch_template_id": "launchTemplateId",
        "launch_template_name": "launchTemplateName",
        "launch_template_version": "launchTemplateVersion",
        "load_balancer_id_to_attach": "loadBalancerIdToAttach",
        "password": "password",
        "password_inherit": "passwordInherit",
        "period": "period",
        "period_unit": "periodUnit",
        "ram_role_name": "ramRoleName",
        "resource_group_id": "resourceGroupId",
        "security_group_id": "securityGroupId",
        "security_group_ids": "securityGroupIds",
        "spot_price_limit": "spotPriceLimit",
        "spot_strategy": "spotStrategy",
        "system_disk_auto_snapshot_policy_id": "systemDiskAutoSnapshotPolicyId",
        "system_disk_category": "systemDiskCategory",
        "system_disk_description": "systemDiskDescription",
        "system_disk_disk_name": "systemDiskDiskName",
        "tags": "tags",
        "zone_id": "zoneId",
    },
)
class InstanceGroupCloneProps:
    def __init__(
        self,
        *,
        max_amount: jsii.Number,
        source_instance_id: builtins.str,
        auto_release_time: typing.Optional[builtins.str] = None,
        auto_renew: typing.Optional[builtins.str] = None,
        auto_renew_period: typing.Optional[jsii.Number] = None,
        backend_server_weight: typing.Optional[jsii.Number] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        deployment_set_id: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        disk_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceGroupClone.DiskMappingsProperty"]]]] = None,
        eni_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceGroupClone.EniMappingsProperty"]]]] = None,
        hpc_cluster_id: typing.Optional[builtins.str] = None,
        image_id: typing.Optional[builtins.str] = None,
        instance_name: typing.Optional[builtins.str] = None,
        internet_max_bandwidth_in: typing.Optional[jsii.Number] = None,
        internet_max_bandwidth_out: typing.Optional[jsii.Number] = None,
        ipv6_address_count: typing.Optional[jsii.Number] = None,
        ipv6_addresses: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
        key_pair_name: typing.Optional[builtins.str] = None,
        launch_template_id: typing.Optional[builtins.str] = None,
        launch_template_name: typing.Optional[builtins.str] = None,
        launch_template_version: typing.Optional[builtins.str] = None,
        load_balancer_id_to_attach: typing.Optional[builtins.str] = None,
        password: typing.Optional[builtins.str] = None,
        password_inherit: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        period: typing.Optional[jsii.Number] = None,
        period_unit: typing.Optional[builtins.str] = None,
        ram_role_name: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        security_group_ids: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
        spot_price_limit: typing.Optional[builtins.str] = None,
        spot_strategy: typing.Optional[builtins.str] = None,
        system_disk_auto_snapshot_policy_id: typing.Optional[builtins.str] = None,
        system_disk_category: typing.Optional[builtins.str] = None,
        system_disk_description: typing.Optional[builtins.str] = None,
        system_disk_disk_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::InstanceGroupClone``.

        :param max_amount: 
        :param source_instance_id: 
        :param auto_release_time: 
        :param auto_renew: 
        :param auto_renew_period: 
        :param backend_server_weight: 
        :param deletion_protection: 
        :param deployment_set_id: 
        :param description: 
        :param disk_mappings: 
        :param eni_mappings: 
        :param hpc_cluster_id: 
        :param image_id: 
        :param instance_name: 
        :param internet_max_bandwidth_in: 
        :param internet_max_bandwidth_out: 
        :param ipv6_address_count: 
        :param ipv6_addresses: 
        :param key_pair_name: 
        :param launch_template_id: 
        :param launch_template_name: 
        :param launch_template_version: 
        :param load_balancer_id_to_attach: 
        :param password: 
        :param password_inherit: 
        :param period: 
        :param period_unit: 
        :param ram_role_name: 
        :param resource_group_id: 
        :param security_group_id: 
        :param security_group_ids: 
        :param spot_price_limit: 
        :param spot_strategy: 
        :param system_disk_auto_snapshot_policy_id: 
        :param system_disk_category: 
        :param system_disk_description: 
        :param system_disk_disk_name: 
        :param tags: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "max_amount": max_amount,
            "source_instance_id": source_instance_id,
        }
        if auto_release_time is not None:
            self._values["auto_release_time"] = auto_release_time
        if auto_renew is not None:
            self._values["auto_renew"] = auto_renew
        if auto_renew_period is not None:
            self._values["auto_renew_period"] = auto_renew_period
        if backend_server_weight is not None:
            self._values["backend_server_weight"] = backend_server_weight
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if deployment_set_id is not None:
            self._values["deployment_set_id"] = deployment_set_id
        if description is not None:
            self._values["description"] = description
        if disk_mappings is not None:
            self._values["disk_mappings"] = disk_mappings
        if eni_mappings is not None:
            self._values["eni_mappings"] = eni_mappings
        if hpc_cluster_id is not None:
            self._values["hpc_cluster_id"] = hpc_cluster_id
        if image_id is not None:
            self._values["image_id"] = image_id
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if internet_max_bandwidth_in is not None:
            self._values["internet_max_bandwidth_in"] = internet_max_bandwidth_in
        if internet_max_bandwidth_out is not None:
            self._values["internet_max_bandwidth_out"] = internet_max_bandwidth_out
        if ipv6_address_count is not None:
            self._values["ipv6_address_count"] = ipv6_address_count
        if ipv6_addresses is not None:
            self._values["ipv6_addresses"] = ipv6_addresses
        if key_pair_name is not None:
            self._values["key_pair_name"] = key_pair_name
        if launch_template_id is not None:
            self._values["launch_template_id"] = launch_template_id
        if launch_template_name is not None:
            self._values["launch_template_name"] = launch_template_name
        if launch_template_version is not None:
            self._values["launch_template_version"] = launch_template_version
        if load_balancer_id_to_attach is not None:
            self._values["load_balancer_id_to_attach"] = load_balancer_id_to_attach
        if password is not None:
            self._values["password"] = password
        if password_inherit is not None:
            self._values["password_inherit"] = password_inherit
        if period is not None:
            self._values["period"] = period
        if period_unit is not None:
            self._values["period_unit"] = period_unit
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if spot_price_limit is not None:
            self._values["spot_price_limit"] = spot_price_limit
        if spot_strategy is not None:
            self._values["spot_strategy"] = spot_strategy
        if system_disk_auto_snapshot_policy_id is not None:
            self._values["system_disk_auto_snapshot_policy_id"] = system_disk_auto_snapshot_policy_id
        if system_disk_category is not None:
            self._values["system_disk_category"] = system_disk_category
        if system_disk_description is not None:
            self._values["system_disk_description"] = system_disk_description
        if system_disk_disk_name is not None:
            self._values["system_disk_disk_name"] = system_disk_disk_name
        if tags is not None:
            self._values["tags"] = tags
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def max_amount(self) -> jsii.Number:
        """
        :Property: maxAmount: Max number of instances to create, should be bigger than 'MinAmount' and smaller than 1000.
        """
        result = self._values.get("max_amount")
        assert result is not None, "Required property 'max_amount' is missing"
        return result

    @builtins.property
    def source_instance_id(self) -> builtins.str:
        """
        :Property: sourceInstanceId: Source ecs instance used to copy properties to clone new ecs instance. It will copy the InstanceType, ImageId, InternetChargeType, InternetMaxBandwidthIn, InternetMaxBandwidthOut and the system disk and data disk configurations. If the instance network is VPC, it will also clone the relative properties. If specified instance with more than one security group, it will use the first security group to create instance. you can also specify the SecurityGroupId to override it.
        """
        result = self._values.get("source_instance_id")
        assert result is not None, "Required property 'source_instance_id' is missing"
        return result

    @builtins.property
    def auto_release_time(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoReleaseTime: Auto release time for created instance, Follow ISO8601 standard using UTC time. format is 'yyyy-MM-ddTHH:mm:ssZ'. Not bigger than 3 years from this day onwards
        """
        result = self._values.get("auto_release_time")
        return result

    @builtins.property
    def auto_renew(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoRenew: Whether renew the fee automatically? When the parameter InstanceChargeType is PrePaid, it will take effect. Range of value:True: automatic renewal.False: no automatic renewal. Default value is False.Old instances will not be changed.
        """
        result = self._values.get("auto_renew")
        return result

    @builtins.property
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.Old instances will not be changed.
        """
        result = self._values.get("auto_renew_period")
        return result

    @builtins.property
    def backend_server_weight(self) -> typing.Optional[jsii.Number]:
        """
        :Property: backendServerWeight: The weight of backend server of load balancer. From 0 to 100, 0 means offline. Default is 100.
        """
        result = self._values.get("backend_server_weight")
        return result

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deletionProtection: Whether an instance can be released manually through the console or API, deletion protection only support postPaid instance
        """
        result = self._values.get("deletion_protection")
        return result

    @builtins.property
    def deployment_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: deploymentSetId: Deployment set ID. The change of the property does not affect existing instances.
        """
        result = self._values.get("deployment_set_id")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty. Old instances will not be changed.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceGroupClone.DiskMappingsProperty"]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.Old instances will not be changed.
        """
        result = self._values.get("disk_mappings")
        return result

    @builtins.property
    def eni_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceGroupClone.EniMappingsProperty"]]]]:
        """
        :Property: eniMappings: NetworkInterface to attach to instance. Max support 1 ENI.
        """
        result = self._values.get("eni_mappings")
        return result

    @builtins.property
    def hpc_cluster_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.The change of the property does not affect existing instances.
        """
        result = self._values.get("hpc_cluster_id")
        return result

    @builtins.property
    def image_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        result = self._values.get("image_id")
        return result

    @builtins.property
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.
        Support to use the regular expression to set the different instance name for each ECS instance. InstanceName could be specified as 'name_prefix[begin_number,bits]name_suffix', such as 'testinstance[123,4]tail'. If you creates 3 instances with the instance name 'testinstance[123,4]tail', all the instances' names are testinstance0123tail, testinstance0124tail, testinstance0125tail.
        The 'name_prefix[begin_number,bits]name_suffix' should follow those rules:

        1. 'name_prefix' is required.
        2. 'name_suffix' is optional.
        3. The name regular expression can't include any spaces.
        4. The 'bits' must be in range [1, 6].
        5. The 'begin_number' must be in range [0, 999999].
        6. You could only specify 'begin_number'. The 'bits' will be set as 6 by default.
        7. You also could only specify the [] or [,]. The 'begin_number' will be set as 0 by default, the 'bits' will be set as 6 by default.
        8. If the bits of 'begin_number' is less than the 'bits' you specified, like [1234,1], the 'bits' will be set as 6 by default.
        """
        result = self._values.get("instance_name")
        return result

    @builtins.property
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        result = self._values.get("internet_max_bandwidth_in")
        return result

    @builtins.property
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Set internet output bandwidth of instance. Unit is Mbps(Mega bit per second). Range is [0,200]. Default is 1.While the property is not 0, public ip will be assigned for instance.
        """
        result = self._values.get("internet_max_bandwidth_out")
        return result

    @builtins.property
    def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        ipv6AddressCount: Specifies the number of randomly generated IPv6 addresses for the elastic NIC.
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        The change of the property does not affect existing instances.
        """
        result = self._values.get("ipv6_address_count")
        return result

    @builtins.property
    def ipv6_addresses(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property:

        ipv6Addresses: Specify one or more IPv6 addresses for the elastic NIC. Currently, the maximum list size is 1. Example value: 2001:db8:1234:1a00::*** .
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        The change of the property does not affect existing instances.
        """
        result = self._values.get("ipv6_addresses")
        return result

    @builtins.property
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.Old instances will not be changed.
        """
        result = self._values.get("key_pair_name")
        return result

    @builtins.property
    def launch_template_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateId: ID of launch template. Launch template id or name must be specified to use launch template
        """
        result = self._values.get("launch_template_id")
        return result

    @builtins.property
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateName: Name of launch template. Launch template id or name must be specified to use launch template
        """
        result = self._values.get("launch_template_name")
        return result

    @builtins.property
    def launch_template_version(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateVersion: Version of launch template. Default version is used if version is not specified.
        """
        result = self._values.get("launch_template_version")
        return result

    @builtins.property
    def load_balancer_id_to_attach(self) -> typing.Optional[builtins.str]:
        """
        :Property: loadBalancerIdToAttach: After the instance is created. Automatic attach it to the load balancer.
        """
        result = self._values.get("load_balancer_id_to_attach")
        return result

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        result = self._values.get("password")
        return result

    @builtins.property
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: passwordInherit: Specifies whether to use the password preset in the image. To use the PasswordInherit parameter, the Password parameter must be empty and you must make sure that the selected image has a password configured.
        """
        result = self._values.get("password_inherit")
        return result

    @builtins.property
    def period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: period: Prepaid time period. Unit is month, it could be from 1 to 9 or 12, 24, 36, 48, 60. Default value is 1.Old instances will not be changed.
        """
        result = self._values.get("period")
        return result

    @builtins.property
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month. Default value is Month.Old instances will not be changed.
        """
        result = self._values.get("period_unit")
        return result

    @builtins.property
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        result = self._values.get("ram_role_name")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def security_group_ids(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property: securityGroupIds: The IDs of security groups N to which the instance belongs. The valid values of N are based on the maximum number of security groups to which an instance can belong. For more information, see Security group limits.Note: You cannot specify both SecurityGroupId and SecurityGroupIds at the same time.
        """
        result = self._values.get("security_group_ids")
        return result

    @builtins.property
    def spot_price_limit(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotPriceLimit: The hourly price threshold of a instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Three decimals is allowed at most.
        """
        result = self._values.get("spot_price_limit")
        return result

    @builtins.property
    def spot_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotStrategy: The spot strategy of a Pay-As-You-Go instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Value range: "NoSpot: A regular Pay-As-You-Go instance", "SpotWithPriceLimit: A price threshold for a spot instance, ""SpotAsPriceGo: A price that is based on the highest Pay-As-You-Go instance. "Default value: NoSpot.
        """
        result = self._values.get("spot_strategy")
        return result

    @builtins.property
    def system_disk_auto_snapshot_policy_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskAutoSnapshotPolicyId: Auto snapshot policy ID.
        """
        result = self._values.get("system_disk_auto_snapshot_policy_id")
        return result

    @builtins.property
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. Default is cloud_efficiency. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd.Old instances will not be changed.
        """
        result = self._values.get("system_disk_category")
        return result

    @builtins.property
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.Old instances will not be changed.
        """
        result = self._values.get("system_disk_description")
        return result

    @builtins.property
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.Old instances will not be changed.
        """
        result = self._values.get("system_disk_disk_name")
        return result

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InstanceGroupCloneProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.InstanceGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "image_id": "imageId",
        "instance_type": "instanceType",
        "max_amount": "maxAmount",
        "allocate_public_ip": "allocatePublicIp",
        "auto_release_time": "autoReleaseTime",
        "auto_renew": "autoRenew",
        "auto_renew_period": "autoRenewPeriod",
        "dedicated_host_id": "dedicatedHostId",
        "deletion_protection": "deletionProtection",
        "deployment_set_id": "deploymentSetId",
        "description": "description",
        "disk_mappings": "diskMappings",
        "eni_mappings": "eniMappings",
        "host_name": "hostName",
        "hpc_cluster_id": "hpcClusterId",
        "instance_charge_type": "instanceChargeType",
        "instance_name": "instanceName",
        "internet_charge_type": "internetChargeType",
        "internet_max_bandwidth_in": "internetMaxBandwidthIn",
        "internet_max_bandwidth_out": "internetMaxBandwidthOut",
        "io_optimized": "ioOptimized",
        "ipv6_address_count": "ipv6AddressCount",
        "ipv6_addresses": "ipv6Addresses",
        "key_pair_name": "keyPairName",
        "launch_template_id": "launchTemplateId",
        "launch_template_name": "launchTemplateName",
        "launch_template_version": "launchTemplateVersion",
        "network_type": "networkType",
        "password": "password",
        "password_inherit": "passwordInherit",
        "period": "period",
        "period_unit": "periodUnit",
        "private_ip_address": "privateIpAddress",
        "ram_role_name": "ramRoleName",
        "resource_group_id": "resourceGroupId",
        "security_enhancement_strategy": "securityEnhancementStrategy",
        "security_group_id": "securityGroupId",
        "security_group_ids": "securityGroupIds",
        "spot_price_limit": "spotPriceLimit",
        "spot_strategy": "spotStrategy",
        "system_disk_auto_snapshot_policy_id": "systemDiskAutoSnapshotPolicyId",
        "system_disk_category": "systemDiskCategory",
        "system_disk_description": "systemDiskDescription",
        "system_disk_disk_name": "systemDiskDiskName",
        "system_disk_performance_level": "systemDiskPerformanceLevel",
        "system_disk_size": "systemDiskSize",
        "tags": "tags",
        "user_data": "userData",
        "vpc_id": "vpcId",
        "v_switch_id": "vSwitchId",
        "zone_id": "zoneId",
    },
)
class InstanceGroupProps:
    def __init__(
        self,
        *,
        image_id: builtins.str,
        instance_type: builtins.str,
        max_amount: jsii.Number,
        allocate_public_ip: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        auto_release_time: typing.Optional[builtins.str] = None,
        auto_renew: typing.Optional[builtins.str] = None,
        auto_renew_period: typing.Optional[jsii.Number] = None,
        dedicated_host_id: typing.Optional[builtins.str] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        deployment_set_id: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        disk_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceGroup.DiskMappingsProperty"]]]] = None,
        eni_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceGroup.EniMappingsProperty"]]]] = None,
        host_name: typing.Optional[builtins.str] = None,
        hpc_cluster_id: typing.Optional[builtins.str] = None,
        instance_charge_type: typing.Optional[builtins.str] = None,
        instance_name: typing.Optional[builtins.str] = None,
        internet_charge_type: typing.Optional[builtins.str] = None,
        internet_max_bandwidth_in: typing.Optional[jsii.Number] = None,
        internet_max_bandwidth_out: typing.Optional[jsii.Number] = None,
        io_optimized: typing.Optional[builtins.str] = None,
        ipv6_address_count: typing.Optional[jsii.Number] = None,
        ipv6_addresses: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
        key_pair_name: typing.Optional[builtins.str] = None,
        launch_template_id: typing.Optional[builtins.str] = None,
        launch_template_name: typing.Optional[builtins.str] = None,
        launch_template_version: typing.Optional[builtins.str] = None,
        network_type: typing.Optional[builtins.str] = None,
        password: typing.Optional[builtins.str] = None,
        password_inherit: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        period: typing.Optional[jsii.Number] = None,
        period_unit: typing.Optional[builtins.str] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        ram_role_name: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_enhancement_strategy: typing.Optional[builtins.str] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        security_group_ids: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
        spot_price_limit: typing.Optional[builtins.str] = None,
        spot_strategy: typing.Optional[builtins.str] = None,
        system_disk_auto_snapshot_policy_id: typing.Optional[builtins.str] = None,
        system_disk_category: typing.Optional[builtins.str] = None,
        system_disk_description: typing.Optional[builtins.str] = None,
        system_disk_disk_name: typing.Optional[builtins.str] = None,
        system_disk_performance_level: typing.Optional[builtins.str] = None,
        system_disk_size: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]] = None,
        user_data: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
        v_switch_id: typing.Optional[builtins.str] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::InstanceGroup``.

        :param image_id: 
        :param instance_type: 
        :param max_amount: 
        :param allocate_public_ip: 
        :param auto_release_time: 
        :param auto_renew: 
        :param auto_renew_period: 
        :param dedicated_host_id: 
        :param deletion_protection: 
        :param deployment_set_id: 
        :param description: 
        :param disk_mappings: 
        :param eni_mappings: 
        :param host_name: 
        :param hpc_cluster_id: 
        :param instance_charge_type: 
        :param instance_name: 
        :param internet_charge_type: 
        :param internet_max_bandwidth_in: 
        :param internet_max_bandwidth_out: 
        :param io_optimized: 
        :param ipv6_address_count: 
        :param ipv6_addresses: 
        :param key_pair_name: 
        :param launch_template_id: 
        :param launch_template_name: 
        :param launch_template_version: 
        :param network_type: 
        :param password: 
        :param password_inherit: 
        :param period: 
        :param period_unit: 
        :param private_ip_address: 
        :param ram_role_name: 
        :param resource_group_id: 
        :param security_enhancement_strategy: 
        :param security_group_id: 
        :param security_group_ids: 
        :param spot_price_limit: 
        :param spot_strategy: 
        :param system_disk_auto_snapshot_policy_id: 
        :param system_disk_category: 
        :param system_disk_description: 
        :param system_disk_disk_name: 
        :param system_disk_performance_level: 
        :param system_disk_size: 
        :param tags: 
        :param user_data: 
        :param vpc_id: 
        :param v_switch_id: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "image_id": image_id,
            "instance_type": instance_type,
            "max_amount": max_amount,
        }
        if allocate_public_ip is not None:
            self._values["allocate_public_ip"] = allocate_public_ip
        if auto_release_time is not None:
            self._values["auto_release_time"] = auto_release_time
        if auto_renew is not None:
            self._values["auto_renew"] = auto_renew
        if auto_renew_period is not None:
            self._values["auto_renew_period"] = auto_renew_period
        if dedicated_host_id is not None:
            self._values["dedicated_host_id"] = dedicated_host_id
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if deployment_set_id is not None:
            self._values["deployment_set_id"] = deployment_set_id
        if description is not None:
            self._values["description"] = description
        if disk_mappings is not None:
            self._values["disk_mappings"] = disk_mappings
        if eni_mappings is not None:
            self._values["eni_mappings"] = eni_mappings
        if host_name is not None:
            self._values["host_name"] = host_name
        if hpc_cluster_id is not None:
            self._values["hpc_cluster_id"] = hpc_cluster_id
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if internet_max_bandwidth_in is not None:
            self._values["internet_max_bandwidth_in"] = internet_max_bandwidth_in
        if internet_max_bandwidth_out is not None:
            self._values["internet_max_bandwidth_out"] = internet_max_bandwidth_out
        if io_optimized is not None:
            self._values["io_optimized"] = io_optimized
        if ipv6_address_count is not None:
            self._values["ipv6_address_count"] = ipv6_address_count
        if ipv6_addresses is not None:
            self._values["ipv6_addresses"] = ipv6_addresses
        if key_pair_name is not None:
            self._values["key_pair_name"] = key_pair_name
        if launch_template_id is not None:
            self._values["launch_template_id"] = launch_template_id
        if launch_template_name is not None:
            self._values["launch_template_name"] = launch_template_name
        if launch_template_version is not None:
            self._values["launch_template_version"] = launch_template_version
        if network_type is not None:
            self._values["network_type"] = network_type
        if password is not None:
            self._values["password"] = password
        if password_inherit is not None:
            self._values["password_inherit"] = password_inherit
        if period is not None:
            self._values["period"] = period
        if period_unit is not None:
            self._values["period_unit"] = period_unit
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_enhancement_strategy is not None:
            self._values["security_enhancement_strategy"] = security_enhancement_strategy
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if spot_price_limit is not None:
            self._values["spot_price_limit"] = spot_price_limit
        if spot_strategy is not None:
            self._values["spot_strategy"] = spot_strategy
        if system_disk_auto_snapshot_policy_id is not None:
            self._values["system_disk_auto_snapshot_policy_id"] = system_disk_auto_snapshot_policy_id
        if system_disk_category is not None:
            self._values["system_disk_category"] = system_disk_category
        if system_disk_description is not None:
            self._values["system_disk_description"] = system_disk_description
        if system_disk_disk_name is not None:
            self._values["system_disk_disk_name"] = system_disk_disk_name
        if system_disk_performance_level is not None:
            self._values["system_disk_performance_level"] = system_disk_performance_level
        if system_disk_size is not None:
            self._values["system_disk_size"] = system_disk_size
        if tags is not None:
            self._values["tags"] = tags
        if user_data is not None:
            self._values["user_data"] = user_data
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id
        if v_switch_id is not None:
            self._values["v_switch_id"] = v_switch_id
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def image_id(self) -> builtins.str:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        result = self._values.get("image_id")
        assert result is not None, "Required property 'image_id' is missing"
        return result

    @builtins.property
    def instance_type(self) -> builtins.str:
        """
        :Property: instanceType: Ecs instance supported instance type, make sure it should be correct.
        """
        result = self._values.get("instance_type")
        assert result is not None, "Required property 'instance_type' is missing"
        return result

    @builtins.property
    def max_amount(self) -> jsii.Number:
        """
        :Property: maxAmount: Max number of instances to create, should be bigger than 'MinAmount' and smaller than 1000.
        """
        result = self._values.get("max_amount")
        assert result is not None, "Required property 'max_amount' is missing"
        return result

    @builtins.property
    def allocate_public_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: allocatePublicIp: The public ip for ecs instance, if properties is true, will allocate public ip. If property InternetMaxBandwidthOut set to 0, it will not assign public ip.
        """
        result = self._values.get("allocate_public_ip")
        return result

    @builtins.property
    def auto_release_time(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoReleaseTime: Auto release time for created instance, Follow ISO8601 standard using UTC time. format is 'yyyy-MM-ddTHH:mm:ssZ'. Not bigger than 3 years from this day onwards
        """
        result = self._values.get("auto_release_time")
        return result

    @builtins.property
    def auto_renew(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoRenew: Whether renew the fee automatically? When the parameter InstanceChargeType is PrePaid, it will take effect. Range of value:True: automatic renewal.False: no automatic renewal. Default value is False.Old instances will not be changed.
        """
        result = self._values.get("auto_renew")
        return result

    @builtins.property
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.Old instances will not be changed.
        """
        result = self._values.get("auto_renew_period")
        return result

    @builtins.property
    def dedicated_host_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: dedicatedHostId: which dedicated host will be deployed
        """
        result = self._values.get("dedicated_host_id")
        return result

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deletionProtection: Whether an instance can be released manually through the console or API, deletion protection only support postPaid instance
        """
        result = self._values.get("deletion_protection")
        return result

    @builtins.property
    def deployment_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: deploymentSetId: Deployment set ID. The change of the property does not affect existing instances.
        """
        result = self._values.get("deployment_set_id")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty. Old instances will not be changed.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceGroup.DiskMappingsProperty"]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.Old instances will not be changed.
        """
        result = self._values.get("disk_mappings")
        return result

    @builtins.property
    def eni_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceGroup.EniMappingsProperty"]]]]:
        """
        :Property: eniMappings: NetworkInterface to attach to instance. Max support 1 ENI.
        """
        result = self._values.get("eni_mappings")
        return result

    @builtins.property
    def host_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        hostName: Host name of created ecs instance. at least 2 characters, and '.' '-' Is not the first and last characters as hostname, not continuous use. Windows platform can be up to 15 characters, allowing letters (without limiting case), numbers and '-', and does not support the number of points, not all is digital ('.').Other (Linux, etc.) platform up to 30 characters, allowing support number multiple points for the period between the points, each permit letters (without limiting case), numbers and '-' components.
        Support to use the regular expression to set the different instance name for each ECS instance. HostName could be specified as 'name_prefix[begin_number,bits]name_suffix', such as 'host[123,4]tail'. If you creates 3 instances with hostname 'host[123,4]tail', all the host names of instances are host0123tail, host0124tail, host0125tail. The 'name_prefix[begin_number,bits]name_suffix' should follow those rules:

        1. 'name_prefix' is required.
        2. 'name_suffix' is optional.
        3. The name regular expression can't include any spaces.
        4. The 'bits' must be in range [1, 6].
        5. The 'begin_number' must be in range [0, 999999].
        6. You could only specify 'begin_number'. The 'bits' will be set as 6 by default.
        7. You also could only specify the [] or [,]. The 'begin_number' will be set as 0 by default, the 'bits' will be set as 6 by default.
        8. If the bits of 'begin_number' is less than the 'bits' you specified, like [1234,1], the 'bits' will be set as 6 by default.
        The host name is specified by regular expression works after restart instance manually.
        """
        result = self._values.get("host_name")
        return result

    @builtins.property
    def hpc_cluster_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.The change of the property does not affect existing instances.
        """
        result = self._values.get("hpc_cluster_id")
        return result

    @builtins.property
    def instance_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceChargeType: Instance Charge type, allowed value: Prepaid and Postpaid. If specified Prepaid, please ensure you have sufficient balance in your account. Or instance creation will be failure. Default value is Postpaid.Old instances will not be changed.
        """
        result = self._values.get("instance_charge_type")
        return result

    @builtins.property
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.
        Support to use the regular expression to set the different instance name for each ECS instance. InstanceName could be specified as 'name_prefix[begin_number,bits]name_suffix', such as 'testinstance[123,4]tail'. If you creates 3 instances with the instance name 'testinstance[123,4]tail', all the instances' names are testinstance0123tail, testinstance0124tail, testinstance0125tail.
        The 'name_prefix[begin_number,bits]name_suffix' should follow those rules:

        1. 'name_prefix' is required.
        2. 'name_suffix' is optional.
        3. The name regular expression can't include any spaces.
        4. The 'bits' must be in range [1, 6].
        5. The 'begin_number' must be in range [0, 999999].
        6. You could only specify 'begin_number'. The 'bits' will be set as 6 by default.
        7. You also could only specify the [] or [,]. The 'begin_number' will be set as 0 by default, the 'bits' will be set as 6 by default.
        8. If the bits of 'begin_number' is less than the 'bits' you specified, like [1234,1], the 'bits' will be set as 6 by default.
        """
        result = self._values.get("instance_name")
        return result

    @builtins.property
    def internet_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: internetChargeType: Instance internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByTraffic
        """
        result = self._values.get("internet_charge_type")
        return result

    @builtins.property
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        result = self._values.get("internet_max_bandwidth_in")
        return result

    @builtins.property
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Set internet output bandwidth of instance. Unit is Mbps(Mega bit per second). Range is [0,200]. Default is 1.While the property is not 0, public ip will be assigned for instance.
        """
        result = self._values.get("internet_max_bandwidth_out")
        return result

    @builtins.property
    def io_optimized(self) -> typing.Optional[builtins.str]:
        """
        :Property: ioOptimized: The 'optimized' instance can provide better IO performance. Support 'none' and 'optimized' only, default is 'optimized'.
        """
        result = self._values.get("io_optimized")
        return result

    @builtins.property
    def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        ipv6AddressCount: Specifies the number of randomly generated IPv6 addresses for the elastic NIC.
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        The change of the property does not affect existing instances.
        """
        result = self._values.get("ipv6_address_count")
        return result

    @builtins.property
    def ipv6_addresses(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property:

        ipv6Addresses: Specify one or more IPv6 addresses for the elastic NIC. Currently, the maximum list size is 1. Example value: 2001:db8:1234:1a00::*** .
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        The change of the property does not affect existing instances.
        """
        result = self._values.get("ipv6_addresses")
        return result

    @builtins.property
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.Old instances will not be changed.
        """
        result = self._values.get("key_pair_name")
        return result

    @builtins.property
    def launch_template_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateId: ID of launch template. Launch template id or name must be specified to use launch template
        """
        result = self._values.get("launch_template_id")
        return result

    @builtins.property
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateName: Name of launch template. Launch template id or name must be specified to use launch template
        """
        result = self._values.get("launch_template_name")
        return result

    @builtins.property
    def launch_template_version(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateVersion: Version of launch template. Default version is used if version is not specified.
        """
        result = self._values.get("launch_template_version")
        return result

    @builtins.property
    def network_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: networkType: Instance network type. Support 'vpc' and 'classic', for compatible reason, default is 'classic'. If vswitch id and vpc id is specified, the property will be forced to be set to 'vpc'
        """
        result = self._values.get("network_type")
        return result

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        result = self._values.get("password")
        return result

    @builtins.property
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: passwordInherit: Specifies whether to use the password preset in the image. To use the PasswordInherit parameter, the Password parameter must be empty and you must make sure that the selected image has a password configured.
        """
        result = self._values.get("password_inherit")
        return result

    @builtins.property
    def period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: period: Prepaid time period. Unit is month, it could be from 1 to 9 or 12, 24, 36, 48, 60. Default value is 1.Old instances will not be changed.
        """
        result = self._values.get("period")
        return result

    @builtins.property
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month. Default value is Month.Old instances will not be changed.
        """
        result = self._values.get("period_unit")
        return result

    @builtins.property
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        """
        :Property: privateIpAddress: Private IP for the instance created. Only works for VPC instance and cannot duplicated with existing instance.
        """
        result = self._values.get("private_ip_address")
        return result

    @builtins.property
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        result = self._values.get("ram_role_name")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def security_enhancement_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityEnhancementStrategy:
        """
        result = self._values.get("security_enhancement_strategy")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def security_group_ids(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property: securityGroupIds: The IDs of security groups N to which the instance belongs. The valid values of N are based on the maximum number of security groups to which an instance can belong. For more information, see Security group limits.Note: You cannot specify both SecurityGroupId and SecurityGroupIds at the same time.
        """
        result = self._values.get("security_group_ids")
        return result

    @builtins.property
    def spot_price_limit(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotPriceLimit: The hourly price threshold of a instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Three decimals is allowed at most.
        """
        result = self._values.get("spot_price_limit")
        return result

    @builtins.property
    def spot_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotStrategy: The spot strategy of a Pay-As-You-Go instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Value range: "NoSpot: A regular Pay-As-You-Go instance", "SpotWithPriceLimit: A price threshold for a spot instance, ""SpotAsPriceGo: A price that is based on the highest Pay-As-You-Go instance. "Default value: NoSpot.
        """
        result = self._values.get("spot_strategy")
        return result

    @builtins.property
    def system_disk_auto_snapshot_policy_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskAutoSnapshotPolicyId: Auto snapshot policy ID.
        """
        result = self._values.get("system_disk_auto_snapshot_policy_id")
        return result

    @builtins.property
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. Default is cloud_efficiency. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd.Old instances will not be changed.
        """
        result = self._values.get("system_disk_category")
        return result

    @builtins.property
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.Old instances will not be changed.
        """
        result = self._values.get("system_disk_description")
        return result

    @builtins.property
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.Old instances will not be changed.
        """
        result = self._values.get("system_disk_disk_name")
        return result

    @builtins.property
    def system_disk_performance_level(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskPerformanceLevel: The performance level of the enhanced SSD used as the system disk.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
        """
        result = self._values.get("system_disk_performance_level")
        return result

    @builtins.property
    def system_disk_size(self) -> typing.Optional[jsii.Number]:
        """
        :Property: systemDiskSize: Disk size of the system disk, range from 20 to 500 GB. If you specify with your own image, make sure the system disk size bigger than image size.
        """
        result = self._values.get("system_disk_size")
        return result

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def user_data(self) -> typing.Optional[builtins.str]:
        """
        :Property: userData: User data to pass to instance. [1, 16KB] characters.User data should not be base64 encoded. If you want to pass base64 encoded string to the property, use function Fn::Base64Decode to decode the base64 string first.
        """
        result = self._values.get("user_data")
        return result

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcId: The VPC id to create ecs instance.
        """
        result = self._values.get("vpc_id")
        return result

    @builtins.property
    def v_switch_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vSwitchId: The vSwitch Id to create ecs instance.
        """
        result = self._values.get("v_switch_id")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InstanceGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.InstanceProps",
    jsii_struct_bases=[],
    name_mapping={
        "image_id": "imageId",
        "instance_type": "instanceType",
        "allocate_public_ip": "allocatePublicIp",
        "auto_renew": "autoRenew",
        "auto_renew_period": "autoRenewPeriod",
        "dedicated_host_id": "dedicatedHostId",
        "deletion_protection": "deletionProtection",
        "deployment_set_id": "deploymentSetId",
        "description": "description",
        "disk_mappings": "diskMappings",
        "host_name": "hostName",
        "hpc_cluster_id": "hpcClusterId",
        "instance_charge_type": "instanceChargeType",
        "instance_name": "instanceName",
        "internet_charge_type": "internetChargeType",
        "internet_max_bandwidth_in": "internetMaxBandwidthIn",
        "internet_max_bandwidth_out": "internetMaxBandwidthOut",
        "io_optimized": "ioOptimized",
        "key_pair_name": "keyPairName",
        "password": "password",
        "password_inherit": "passwordInherit",
        "period": "period",
        "period_unit": "periodUnit",
        "private_ip_address": "privateIpAddress",
        "ram_role_name": "ramRoleName",
        "resource_group_id": "resourceGroupId",
        "security_enhancement_strategy": "securityEnhancementStrategy",
        "security_group_id": "securityGroupId",
        "spot_price_limit": "spotPriceLimit",
        "spot_strategy": "spotStrategy",
        "system_disk_category": "systemDiskCategory",
        "system_disk_description": "systemDiskDescription",
        "system_disk_disk_name": "systemDiskDiskName",
        "system_disk_performance_level": "systemDiskPerformanceLevel",
        "system_disk_size": "systemDiskSize",
        "tags": "tags",
        "user_data": "userData",
        "vpc_id": "vpcId",
        "v_switch_id": "vSwitchId",
        "zone_id": "zoneId",
    },
)
class InstanceProps:
    def __init__(
        self,
        *,
        image_id: builtins.str,
        instance_type: builtins.str,
        allocate_public_ip: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        auto_renew: typing.Optional[builtins.str] = None,
        auto_renew_period: typing.Optional[jsii.Number] = None,
        dedicated_host_id: typing.Optional[builtins.str] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        deployment_set_id: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        disk_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstance.DiskMappingsProperty"]]]] = None,
        host_name: typing.Optional[builtins.str] = None,
        hpc_cluster_id: typing.Optional[builtins.str] = None,
        instance_charge_type: typing.Optional[builtins.str] = None,
        instance_name: typing.Optional[builtins.str] = None,
        internet_charge_type: typing.Optional[builtins.str] = None,
        internet_max_bandwidth_in: typing.Optional[jsii.Number] = None,
        internet_max_bandwidth_out: typing.Optional[jsii.Number] = None,
        io_optimized: typing.Optional[builtins.str] = None,
        key_pair_name: typing.Optional[builtins.str] = None,
        password: typing.Optional[builtins.str] = None,
        password_inherit: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        period: typing.Optional[jsii.Number] = None,
        period_unit: typing.Optional[builtins.str] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        ram_role_name: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_enhancement_strategy: typing.Optional[builtins.str] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        spot_price_limit: typing.Optional[builtins.str] = None,
        spot_strategy: typing.Optional[builtins.str] = None,
        system_disk_category: typing.Optional[builtins.str] = None,
        system_disk_description: typing.Optional[builtins.str] = None,
        system_disk_disk_name: typing.Optional[builtins.str] = None,
        system_disk_performance_level: typing.Optional[builtins.str] = None,
        system_disk_size: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]] = None,
        user_data: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
        v_switch_id: typing.Optional[builtins.str] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::Instance``.

        :param image_id: 
        :param instance_type: 
        :param allocate_public_ip: 
        :param auto_renew: 
        :param auto_renew_period: 
        :param dedicated_host_id: 
        :param deletion_protection: 
        :param deployment_set_id: 
        :param description: 
        :param disk_mappings: 
        :param host_name: 
        :param hpc_cluster_id: 
        :param instance_charge_type: 
        :param instance_name: 
        :param internet_charge_type: 
        :param internet_max_bandwidth_in: 
        :param internet_max_bandwidth_out: 
        :param io_optimized: 
        :param key_pair_name: 
        :param password: 
        :param password_inherit: 
        :param period: 
        :param period_unit: 
        :param private_ip_address: 
        :param ram_role_name: 
        :param resource_group_id: 
        :param security_enhancement_strategy: 
        :param security_group_id: 
        :param spot_price_limit: 
        :param spot_strategy: 
        :param system_disk_category: 
        :param system_disk_description: 
        :param system_disk_disk_name: 
        :param system_disk_performance_level: 
        :param system_disk_size: 
        :param tags: 
        :param user_data: 
        :param vpc_id: 
        :param v_switch_id: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "image_id": image_id,
            "instance_type": instance_type,
        }
        if allocate_public_ip is not None:
            self._values["allocate_public_ip"] = allocate_public_ip
        if auto_renew is not None:
            self._values["auto_renew"] = auto_renew
        if auto_renew_period is not None:
            self._values["auto_renew_period"] = auto_renew_period
        if dedicated_host_id is not None:
            self._values["dedicated_host_id"] = dedicated_host_id
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if deployment_set_id is not None:
            self._values["deployment_set_id"] = deployment_set_id
        if description is not None:
            self._values["description"] = description
        if disk_mappings is not None:
            self._values["disk_mappings"] = disk_mappings
        if host_name is not None:
            self._values["host_name"] = host_name
        if hpc_cluster_id is not None:
            self._values["hpc_cluster_id"] = hpc_cluster_id
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if internet_max_bandwidth_in is not None:
            self._values["internet_max_bandwidth_in"] = internet_max_bandwidth_in
        if internet_max_bandwidth_out is not None:
            self._values["internet_max_bandwidth_out"] = internet_max_bandwidth_out
        if io_optimized is not None:
            self._values["io_optimized"] = io_optimized
        if key_pair_name is not None:
            self._values["key_pair_name"] = key_pair_name
        if password is not None:
            self._values["password"] = password
        if password_inherit is not None:
            self._values["password_inherit"] = password_inherit
        if period is not None:
            self._values["period"] = period
        if period_unit is not None:
            self._values["period_unit"] = period_unit
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_enhancement_strategy is not None:
            self._values["security_enhancement_strategy"] = security_enhancement_strategy
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if spot_price_limit is not None:
            self._values["spot_price_limit"] = spot_price_limit
        if spot_strategy is not None:
            self._values["spot_strategy"] = spot_strategy
        if system_disk_category is not None:
            self._values["system_disk_category"] = system_disk_category
        if system_disk_description is not None:
            self._values["system_disk_description"] = system_disk_description
        if system_disk_disk_name is not None:
            self._values["system_disk_disk_name"] = system_disk_disk_name
        if system_disk_performance_level is not None:
            self._values["system_disk_performance_level"] = system_disk_performance_level
        if system_disk_size is not None:
            self._values["system_disk_size"] = system_disk_size
        if tags is not None:
            self._values["tags"] = tags
        if user_data is not None:
            self._values["user_data"] = user_data
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id
        if v_switch_id is not None:
            self._values["v_switch_id"] = v_switch_id
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def image_id(self) -> builtins.str:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        result = self._values.get("image_id")
        assert result is not None, "Required property 'image_id' is missing"
        return result

    @builtins.property
    def instance_type(self) -> builtins.str:
        """
        :Property: instanceType: Ecs instance supported instance type, make sure it should be correct.
        """
        result = self._values.get("instance_type")
        assert result is not None, "Required property 'instance_type' is missing"
        return result

    @builtins.property
    def allocate_public_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: allocatePublicIp: The public ip for ecs instance, if properties is true, will allocate public ip. If property InternetMaxBandwidthOut set to 0, it will not assign public ip.
        """
        result = self._values.get("allocate_public_ip")
        return result

    @builtins.property
    def auto_renew(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoRenew: Whether renew the fee automatically? When the parameter InstanceChargeType is PrePaid, it will take effect. Range of value:True: automatic renewal.False: no automatic renewal. Default value is False.
        """
        result = self._values.get("auto_renew")
        return result

    @builtins.property
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.
        """
        result = self._values.get("auto_renew_period")
        return result

    @builtins.property
    def dedicated_host_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: dedicatedHostId: which dedicated host will be deployed
        """
        result = self._values.get("dedicated_host_id")
        return result

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deletionProtection: Whether an instance can be released manually through the console or API, deletion protection only support postPaid instance
        """
        result = self._values.get("deletion_protection")
        return result

    @builtins.property
    def deployment_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: deploymentSetId: Deployment set ID.
        """
        result = self._values.get("deployment_set_id")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstance.DiskMappingsProperty"]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.
        """
        result = self._values.get("disk_mappings")
        return result

    @builtins.property
    def host_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: hostName: Host name of created ecs instance. at least 2 characters, and '.' '-' Is not the first and last characters as hostname, not continuous use. Windows platform can be up to 15 characters, allowing letters (without limiting case), numbers and '-', and does not support the number of points, not all is digital ('.').Other (Linux, etc.) platform up to 30 characters, allowing support number multiple points for the period between the points, each permit letters (without limiting case), numbers and '-' components.
        """
        result = self._values.get("host_name")
        return result

    @builtins.property
    def hpc_cluster_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.
        """
        result = self._values.get("hpc_cluster_id")
        return result

    @builtins.property
    def instance_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceChargeType: Instance Charge type, allowed value: Prepaid and Postpaid. If specified Prepaid, please ensure you have sufficient balance in your account. Or instance creation will be failure. Default value is Postpaid.
        """
        result = self._values.get("instance_charge_type")
        return result

    @builtins.property
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("instance_name")
        return result

    @builtins.property
    def internet_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: internetChargeType: Instance internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByTraffic
        """
        result = self._values.get("internet_charge_type")
        return result

    @builtins.property
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        result = self._values.get("internet_max_bandwidth_in")
        return result

    @builtins.property
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Set internet output bandwidth of instance. Unit is Mbps(Mega bit per second). Range is [0,200]. Default is 1.While the property is not 0, public ip will be assigned for instance.
        """
        result = self._values.get("internet_max_bandwidth_out")
        return result

    @builtins.property
    def io_optimized(self) -> typing.Optional[builtins.str]:
        """
        :Property: ioOptimized: The 'optimized' instance can provide better IO performance. Support 'none' and 'optimized' only, default is 'optimized'.
        """
        result = self._values.get("io_optimized")
        return result

    @builtins.property
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.
        """
        result = self._values.get("key_pair_name")
        return result

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        result = self._values.get("password")
        return result

    @builtins.property
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: passwordInherit: Specifies whether to use the password preset in the image. To use the PasswordInherit parameter, the Password parameter must be empty and you must make sure that the selected image has a password configured.
        """
        result = self._values.get("password_inherit")
        return result

    @builtins.property
    def period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: period: Prepaid time period. Unit is month, it could be from 1 to 9 or 12, 24, 36, 48, 60. Default value is 1.
        """
        result = self._values.get("period")
        return result

    @builtins.property
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month/Year. Default value is Month.
        """
        result = self._values.get("period_unit")
        return result

    @builtins.property
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        """
        :Property: privateIpAddress: Private IP for the instance created. Only works for VPC instance and cannot duplicated with existing instance.
        """
        result = self._values.get("private_ip_address")
        return result

    @builtins.property
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        result = self._values.get("ram_role_name")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def security_enhancement_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityEnhancementStrategy:
        """
        result = self._values.get("security_enhancement_strategy")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def spot_price_limit(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotPriceLimit: The hourly price threshold of a instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Three decimals is allowed at most.
        """
        result = self._values.get("spot_price_limit")
        return result

    @builtins.property
    def spot_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotStrategy: The spot strategy of a Pay-As-You-Go instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Value range: "NoSpot: A regular Pay-As-You-Go instance", "SpotWithPriceLimit: A price threshold for a spot instance, ""SpotAsPriceGo: A price that is based on the highest Pay-As-You-Go instance. "Default value: NoSpot.
        """
        result = self._values.get("spot_strategy")
        return result

    @builtins.property
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. Default is cloud_efficiency. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd
        """
        result = self._values.get("system_disk_category")
        return result

    @builtins.property
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.
        """
        result = self._values.get("system_disk_description")
        return result

    @builtins.property
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.
        """
        result = self._values.get("system_disk_disk_name")
        return result

    @builtins.property
    def system_disk_performance_level(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskPerformanceLevel: The performance level of the enhanced SSD used as the system disk.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
        """
        result = self._values.get("system_disk_performance_level")
        return result

    @builtins.property
    def system_disk_size(self) -> typing.Optional[jsii.Number]:
        """
        :Property: systemDiskSize: Disk size of the system disk, range from 20 to 500 GB. If you specify with your own image, make sure the system disk size bigger than image size.
        """
        result = self._values.get("system_disk_size")
        return result

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def user_data(self) -> typing.Optional[builtins.str]:
        """
        :Property: userData: User data to pass to instance. [1, 16KB] characters.User data should not be base64 encoded. If you want to pass base64 encoded string to the property, use function Fn::Base64Decode to decode the base64 string first.
        """
        result = self._values.get("user_data")
        return result

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcId: The VPC id to create ecs instance.
        """
        result = self._values.get("vpc_id")
        return result

    @builtins.property
    def v_switch_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vSwitchId: The vSwitch Id to create ecs instance.
        """
        result = self._values.get("v_switch_id")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InstanceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Invocation(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.Invocation",
):
    """A ROS resource type:  ``ALIYUN::ECS::Invocation``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "InvocationProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::Invocation``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(Invocation, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInvokeId")
    def attr_invoke_id(self) -> typing.Any:
        """
        :Attribute: InvokeId: The id of command execution.
        """
        return jsii.get(self, "attrInvokeId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.InvocationProps",
    jsii_struct_bases=[],
    name_mapping={
        "command_id": "commandId",
        "instance_ids": "instanceIds",
        "frequency": "frequency",
        "parameters": "parameters",
        "timed": "timed",
    },
)
class InvocationProps:
    def __init__(
        self,
        *,
        command_id: builtins.str,
        instance_ids: typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable],
        frequency: typing.Optional[builtins.str] = None,
        parameters: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.Mapping[builtins.str, typing.Any]]] = None,
        timed: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::Invocation``.

        :param command_id: 
        :param instance_ids: 
        :param frequency: 
        :param parameters: 
        :param timed: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "command_id": command_id,
            "instance_ids": instance_ids,
        }
        if frequency is not None:
            self._values["frequency"] = frequency
        if parameters is not None:
            self._values["parameters"] = parameters
        if timed is not None:
            self._values["timed"] = timed

    @builtins.property
    def command_id(self) -> builtins.str:
        """
        :Property: commandId: The id of command.
        """
        result = self._values.get("command_id")
        assert result is not None, "Required property 'command_id' is missing"
        return result

    @builtins.property
    def instance_ids(
        self,
    ) -> typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]:
        """
        :Property: instanceIds: The instance id list. Select up to 50 instances at a time.Instances status must be running.
        """
        result = self._values.get("instance_ids")
        assert result is not None, "Required property 'instance_ids' is missing"
        return result

    @builtins.property
    def frequency(self) -> typing.Optional[builtins.str]:
        """
        :Property: frequency: The frequency of timing execution (the shortest frequency is performed every 1 minute). It iss mandatory when Timing is True.The value rule follows the rules of the cron expression.
        """
        result = self._values.get("frequency")
        return result

    @builtins.property
    def parameters(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property:

        parameters: The key-value pairs of custom parameters passed in when the script contains custom parameters.
        Number of custom parameters: 0 to 10.
        The key cannot be an empty string. It can be up to 64 characters in length.
        The value can be an empty string.
        After the custom parameters and the original script content are Base64 encoded, the total size cannot exceed 16 KB.
        The set of custom parameter names must be a subset of the parameter set that is defined when you created the script. You can use an empty string to represent the parameters that are not passed in.
        Default value: null, indicating that this parameter is canceled and customer parameters are disabled.
        """
        result = self._values.get("parameters")
        return result

    @builtins.property
    def timed(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: timed: Whether it is timed execution. Default is False.
        """
        result = self._values.get("timed")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InvocationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class JoinSecurityGroup(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.JoinSecurityGroup",
):
    """A ROS resource type:  ``ALIYUN::ECS::JoinSecurityGroup``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "JoinSecurityGroupProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::JoinSecurityGroup``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(JoinSecurityGroup, self, [scope, id, props, enable_resource_property_constraint])


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.JoinSecurityGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "security_group_id": "securityGroupId",
        "instance_id": "instanceId",
        "instance_id_list": "instanceIdList",
        "network_interface_list": "networkInterfaceList",
    },
)
class JoinSecurityGroupProps:
    def __init__(
        self,
        *,
        security_group_id: builtins.str,
        instance_id: typing.Optional[builtins.str] = None,
        instance_id_list: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
        network_interface_list: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::JoinSecurityGroup``.

        :param security_group_id: 
        :param instance_id: 
        :param instance_id_list: 
        :param network_interface_list: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "security_group_id": security_group_id,
        }
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if instance_id_list is not None:
            self._values["instance_id_list"] = instance_id_list
        if network_interface_list is not None:
            self._values["network_interface_list"] = network_interface_list

    @builtins.property
    def security_group_id(self) -> builtins.str:
        """
        :Property: securityGroupId: Security group id to join.
        """
        result = self._values.get("security_group_id")
        assert result is not None, "Required property 'security_group_id' is missing"
        return result

    @builtins.property
    def instance_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceId: Instance Id to the join the security group.
        """
        result = self._values.get("instance_id")
        return result

    @builtins.property
    def instance_id_list(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property: instanceIdList: The comma delimited instance id list.If the property "InstanceId" is setting, this property will be ignored.
        """
        result = self._values.get("instance_id_list")
        return result

    @builtins.property
    def network_interface_list(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property: networkInterfaceList: Network interface list.
        """
        result = self._values.get("network_interface_list")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "JoinSecurityGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LaunchTemplate(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.LaunchTemplate",
):
    """A ROS resource type:  ``ALIYUN::ECS::LaunchTemplate``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "LaunchTemplateProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::LaunchTemplate``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(LaunchTemplate, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrDefaultVersionNumber")
    def attr_default_version_number(self) -> typing.Any:
        """
        :Attribute: DefaultVersionNumber: The default version number of launch template.
        """
        return jsii.get(self, "attrDefaultVersionNumber")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrLatestVersionNumber")
    def attr_latest_version_number(self) -> typing.Any:
        """
        :Attribute: LatestVersionNumber: The latest version number of launch template.
        """
        return jsii.get(self, "attrLatestVersionNumber")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrLaunchTemplateId")
    def attr_launch_template_id(self) -> typing.Any:
        """
        :Attribute: LaunchTemplateId: The id of launch template.
        """
        return jsii.get(self, "attrLaunchTemplateId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrLaunchTemplateName")
    def attr_launch_template_name(self) -> typing.Any:
        """
        :Attribute: LaunchTemplateName: The name of launch template.
        """
        return jsii.get(self, "attrLaunchTemplateName")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.LaunchTemplateProps",
    jsii_struct_bases=[],
    name_mapping={
        "launch_template_name": "launchTemplateName",
        "auto_release_time": "autoReleaseTime",
        "description": "description",
        "disk_mappings": "diskMappings",
        "host_name": "hostName",
        "image_id": "imageId",
        "instance_name": "instanceName",
        "instance_type": "instanceType",
        "internet_charge_type": "internetChargeType",
        "internet_max_bandwidth_in": "internetMaxBandwidthIn",
        "internet_max_bandwidth_out": "internetMaxBandwidthOut",
        "io_optimized": "ioOptimized",
        "key_pair_name": "keyPairName",
        "network_interfaces": "networkInterfaces",
        "network_type": "networkType",
        "ram_role_name": "ramRoleName",
        "security_enhancement_strategy": "securityEnhancementStrategy",
        "security_group_id": "securityGroupId",
        "spot_price_limit": "spotPriceLimit",
        "spot_strategy": "spotStrategy",
        "system_disk_category": "systemDiskCategory",
        "system_disk_description": "systemDiskDescription",
        "system_disk_disk_name": "systemDiskDiskName",
        "system_disk_size": "systemDiskSize",
        "tags": "tags",
        "template_tags": "templateTags",
        "user_data": "userData",
        "version_description": "versionDescription",
        "v_switch_id": "vSwitchId",
        "zone_id": "zoneId",
    },
)
class LaunchTemplateProps:
    def __init__(
        self,
        *,
        launch_template_name: builtins.str,
        auto_release_time: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        disk_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosLaunchTemplate.DiskMappingsProperty"]]]] = None,
        host_name: typing.Optional[builtins.str] = None,
        image_id: typing.Optional[builtins.str] = None,
        instance_name: typing.Optional[builtins.str] = None,
        instance_type: typing.Optional[builtins.str] = None,
        internet_charge_type: typing.Optional[builtins.str] = None,
        internet_max_bandwidth_in: typing.Optional[jsii.Number] = None,
        internet_max_bandwidth_out: typing.Optional[jsii.Number] = None,
        io_optimized: typing.Optional[builtins.str] = None,
        key_pair_name: typing.Optional[builtins.str] = None,
        network_interfaces: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosLaunchTemplate.NetworkInterfacesProperty"]]]] = None,
        network_type: typing.Optional[builtins.str] = None,
        ram_role_name: typing.Optional[builtins.str] = None,
        security_enhancement_strategy: typing.Optional[builtins.str] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        spot_price_limit: typing.Optional[builtins.str] = None,
        spot_strategy: typing.Optional[builtins.str] = None,
        system_disk_category: typing.Optional[builtins.str] = None,
        system_disk_description: typing.Optional[builtins.str] = None,
        system_disk_disk_name: typing.Optional[builtins.str] = None,
        system_disk_size: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]] = None,
        template_tags: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosLaunchTemplate.TemplateTagsProperty"]]]] = None,
        user_data: typing.Optional[builtins.str] = None,
        version_description: typing.Optional[builtins.str] = None,
        v_switch_id: typing.Optional[builtins.str] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::LaunchTemplate``.

        :param launch_template_name: 
        :param auto_release_time: 
        :param description: 
        :param disk_mappings: 
        :param host_name: 
        :param image_id: 
        :param instance_name: 
        :param instance_type: 
        :param internet_charge_type: 
        :param internet_max_bandwidth_in: 
        :param internet_max_bandwidth_out: 
        :param io_optimized: 
        :param key_pair_name: 
        :param network_interfaces: 
        :param network_type: 
        :param ram_role_name: 
        :param security_enhancement_strategy: 
        :param security_group_id: 
        :param spot_price_limit: 
        :param spot_strategy: 
        :param system_disk_category: 
        :param system_disk_description: 
        :param system_disk_disk_name: 
        :param system_disk_size: 
        :param tags: 
        :param template_tags: 
        :param user_data: 
        :param version_description: 
        :param v_switch_id: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "launch_template_name": launch_template_name,
        }
        if auto_release_time is not None:
            self._values["auto_release_time"] = auto_release_time
        if description is not None:
            self._values["description"] = description
        if disk_mappings is not None:
            self._values["disk_mappings"] = disk_mappings
        if host_name is not None:
            self._values["host_name"] = host_name
        if image_id is not None:
            self._values["image_id"] = image_id
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if internet_max_bandwidth_in is not None:
            self._values["internet_max_bandwidth_in"] = internet_max_bandwidth_in
        if internet_max_bandwidth_out is not None:
            self._values["internet_max_bandwidth_out"] = internet_max_bandwidth_out
        if io_optimized is not None:
            self._values["io_optimized"] = io_optimized
        if key_pair_name is not None:
            self._values["key_pair_name"] = key_pair_name
        if network_interfaces is not None:
            self._values["network_interfaces"] = network_interfaces
        if network_type is not None:
            self._values["network_type"] = network_type
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if security_enhancement_strategy is not None:
            self._values["security_enhancement_strategy"] = security_enhancement_strategy
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if spot_price_limit is not None:
            self._values["spot_price_limit"] = spot_price_limit
        if spot_strategy is not None:
            self._values["spot_strategy"] = spot_strategy
        if system_disk_category is not None:
            self._values["system_disk_category"] = system_disk_category
        if system_disk_description is not None:
            self._values["system_disk_description"] = system_disk_description
        if system_disk_disk_name is not None:
            self._values["system_disk_disk_name"] = system_disk_disk_name
        if system_disk_size is not None:
            self._values["system_disk_size"] = system_disk_size
        if tags is not None:
            self._values["tags"] = tags
        if template_tags is not None:
            self._values["template_tags"] = template_tags
        if user_data is not None:
            self._values["user_data"] = user_data
        if version_description is not None:
            self._values["version_description"] = version_description
        if v_switch_id is not None:
            self._values["v_switch_id"] = v_switch_id
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def launch_template_name(self) -> builtins.str:
        """
        :Property: launchTemplateName: The name of launch template.
        """
        result = self._values.get("launch_template_name")
        assert result is not None, "Required property 'launch_template_name' is missing"
        return result

    @builtins.property
    def auto_release_time(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoReleaseTime: Auto release time for created instance, Follow ISO8601 standard using UTC time. format is 'yyyy-MM-ddTHH:mm:ssZ'. Not bigger than 3 years from this day onwards
        """
        result = self._values.get("auto_release_time")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosLaunchTemplate.DiskMappingsProperty"]]]]:
        """
        :Property: diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        """
        result = self._values.get("disk_mappings")
        return result

    @builtins.property
    def host_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: hostName: Host name of created ecs instance. at least 2 characters, and '.' '-' Is not the first and last characters as hostname, not continuous use. Windows platform can be up to 15 characters, allowing letters (without limiting case), numbers and '-', and does not support the number of points, not all is digital ('.').Other (Linux, etc.) platform up to 30 characters, allowing support number multiple points for the period between the points, each permit letters (without limiting case), numbers and '-' components.
        """
        result = self._values.get("host_name")
        return result

    @builtins.property
    def image_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        result = self._values.get("image_id")
        return result

    @builtins.property
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("instance_name")
        return result

    @builtins.property
    def instance_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceType: Ecs instance supported instance type, make sure it should be correct.
        """
        result = self._values.get("instance_type")
        return result

    @builtins.property
    def internet_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: internetChargeType: Instance internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only.
        """
        result = self._values.get("internet_charge_type")
        return result

    @builtins.property
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet in bandwidth in Mbps(Mega bit per second). The range is [1,200].
        """
        result = self._values.get("internet_max_bandwidth_in")
        return result

    @builtins.property
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Max internet out bandwidth in Mbps(Mega bit per second). Range is [0,200].While the property is not 0, public ip will be assigned for instance.
        """
        result = self._values.get("internet_max_bandwidth_out")
        return result

    @builtins.property
    def io_optimized(self) -> typing.Optional[builtins.str]:
        """
        :Property: ioOptimized: The 'optimized' instance can provide better IO performance. Support 'none' and 'optimized' only.
        """
        result = self._values.get("io_optimized")
        return result

    @builtins.property
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.
        """
        result = self._values.get("key_pair_name")
        return result

    @builtins.property
    def network_interfaces(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosLaunchTemplate.NetworkInterfacesProperty"]]]]:
        """
        :Property: networkInterfaces: Elastic network interfaces to be attached to instance.
        """
        result = self._values.get("network_interfaces")
        return result

    @builtins.property
    def network_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: networkType: Instance network type. Support 'vpc' and 'classic'
        """
        result = self._values.get("network_type")
        return result

    @builtins.property
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        result = self._values.get("ram_role_name")
        return result

    @builtins.property
    def security_enhancement_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityEnhancementStrategy: Activate or deactivate security enhancement,Value range: "Active" and "Deactive"
        """
        result = self._values.get("security_enhancement_strategy")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def spot_price_limit(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotPriceLimit: The hourly price threshold of a instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Three decimals is allowed at most.
        """
        result = self._values.get("spot_price_limit")
        return result

    @builtins.property
    def spot_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotStrategy: The spot strategy of a Pay-As-You-Go instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Value range: "NoSpot: A regular Pay-As-You-Go instance", "SpotWithPriceLimit: A price threshold for a spot instance, ""SpotAsPriceGo: A price that is based on the highest Pay-As-You-Go instance. "
        """
        result = self._values.get("spot_strategy")
        return result

    @builtins.property
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd
        """
        result = self._values.get("system_disk_category")
        return result

    @builtins.property
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.
        """
        result = self._values.get("system_disk_description")
        return result

    @builtins.property
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.
        """
        result = self._values.get("system_disk_disk_name")
        return result

    @builtins.property
    def system_disk_size(self) -> typing.Optional[jsii.Number]:
        """
        :Property: systemDiskSize: Disk size of the system disk, range from 20 to 500 GB. If you specify with your own image, make sure the system disk size bigger than image size.
        """
        result = self._values.get("system_disk_size")
        return result

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property: tags: Tags to attach to instance, security group, disk and network interface.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def template_tags(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosLaunchTemplate.TemplateTagsProperty"]]]]:
        """
        :Property: templateTags: Template tags to attach to launch template.
        """
        result = self._values.get("template_tags")
        return result

    @builtins.property
    def user_data(self) -> typing.Optional[builtins.str]:
        """
        :Property: userData: User data to pass to instance. [1, 16KB] characters.
        """
        result = self._values.get("user_data")
        return result

    @builtins.property
    def version_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: versionDescription: Description for version 1 of launch template.
        """
        result = self._values.get("version_description")
        return result

    @builtins.property
    def v_switch_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vSwitchId: The vSwitch Id to create ecs instance.
        """
        result = self._values.get("v_switch_id")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: zoneId: Current zone to create the instance.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LaunchTemplateProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NetworkInterface(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.NetworkInterface",
):
    """A ROS resource type:  ``ALIYUN::ECS::NetworkInterface``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "NetworkInterfaceProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::NetworkInterface``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(NetworkInterface, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrMacAddress")
    def attr_mac_address(self) -> typing.Any:
        """
        :Attribute: MacAddress: The MAC address of your Network Interface.
        """
        return jsii.get(self, "attrMacAddress")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrNetworkInterfaceId")
    def attr_network_interface_id(self) -> typing.Any:
        """
        :Attribute: NetworkInterfaceId: ID of your Network Interface.
        """
        return jsii.get(self, "attrNetworkInterfaceId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateIpAddress")
    def attr_private_ip_address(self) -> typing.Any:
        """
        :Attribute: PrivateIpAddress: The primary private ip address of your Network Interface.
        """
        return jsii.get(self, "attrPrivateIpAddress")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrSecondaryPrivateIpAddresses")
    def attr_secondary_private_ip_addresses(self) -> typing.Any:
        """
        :Attribute: SecondaryPrivateIpAddresses: The secondary private IP addresses of your Network Interface.
        """
        return jsii.get(self, "attrSecondaryPrivateIpAddresses")


class NetworkInterfaceAttachment(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.NetworkInterfaceAttachment",
):
    """A ROS resource type:  ``ALIYUN::ECS::NetworkInterfaceAttachment``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "NetworkInterfaceAttachmentProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::NetworkInterfaceAttachment``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(NetworkInterfaceAttachment, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrNetworkInterfaceId")
    def attr_network_interface_id(self) -> typing.Any:
        """
        :Attribute: NetworkInterfaceId: ID of your Network Interface.
        """
        return jsii.get(self, "attrNetworkInterfaceId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrTrunkNetworkInstanceId")
    def attr_trunk_network_instance_id(self) -> typing.Any:
        """
        :Attribute: TrunkNetworkInstanceId: ID of Trunk Network Interface.
        """
        return jsii.get(self, "attrTrunkNetworkInstanceId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.NetworkInterfaceAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "instance_id": "instanceId",
        "network_interface_id": "networkInterfaceId",
        "trunk_network_instance_id": "trunkNetworkInstanceId",
    },
)
class NetworkInterfaceAttachmentProps:
    def __init__(
        self,
        *,
        instance_id: builtins.str,
        network_interface_id: builtins.str,
        trunk_network_instance_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::NetworkInterfaceAttachment``.

        :param instance_id: 
        :param network_interface_id: 
        :param trunk_network_instance_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "instance_id": instance_id,
            "network_interface_id": network_interface_id,
        }
        if trunk_network_instance_id is not None:
            self._values["trunk_network_instance_id"] = trunk_network_instance_id

    @builtins.property
    def instance_id(self) -> builtins.str:
        """
        :Property: instanceId: ECS instance id
        """
        result = self._values.get("instance_id")
        assert result is not None, "Required property 'instance_id' is missing"
        return result

    @builtins.property
    def network_interface_id(self) -> builtins.str:
        """
        :Property: networkInterfaceId: Network interface id
        """
        result = self._values.get("network_interface_id")
        assert result is not None, "Required property 'network_interface_id' is missing"
        return result

    @builtins.property
    def trunk_network_instance_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: trunkNetworkInstanceId: undefined
        """
        result = self._values.get("trunk_network_instance_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkInterfaceAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NetworkInterfacePermission(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.NetworkInterfacePermission",
):
    """A ROS resource type:  ``ALIYUN::ECS::NetworkInterfacePermission``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "NetworkInterfacePermissionProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::NetworkInterfacePermission``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(NetworkInterfacePermission, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrNetworkInterfacePermissionId")
    def attr_network_interface_permission_id(self) -> typing.Any:
        """
        :Attribute: NetworkInterfacePermissionId: the network interface permission id
        """
        return jsii.get(self, "attrNetworkInterfacePermissionId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.NetworkInterfacePermissionProps",
    jsii_struct_bases=[],
    name_mapping={
        "account_id": "accountId",
        "network_interface_id": "networkInterfaceId",
        "permission": "permission",
    },
)
class NetworkInterfacePermissionProps:
    def __init__(
        self,
        *,
        account_id: builtins.str,
        network_interface_id: builtins.str,
        permission: builtins.str,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::NetworkInterfacePermission``.

        :param account_id: 
        :param network_interface_id: 
        :param permission: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "account_id": account_id,
            "network_interface_id": network_interface_id,
            "permission": permission,
        }

    @builtins.property
    def account_id(self) -> builtins.str:
        """
        :Property: accountId: the account id
        """
        result = self._values.get("account_id")
        assert result is not None, "Required property 'account_id' is missing"
        return result

    @builtins.property
    def network_interface_id(self) -> builtins.str:
        """
        :Property: networkInterfaceId: Network interface id
        """
        result = self._values.get("network_interface_id")
        assert result is not None, "Required property 'network_interface_id' is missing"
        return result

    @builtins.property
    def permission(self) -> builtins.str:
        """
        :Property: permission: the permission
        """
        result = self._values.get("permission")
        assert result is not None, "Required property 'permission' is missing"
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkInterfacePermissionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.NetworkInterfaceProps",
    jsii_struct_bases=[],
    name_mapping={
        "v_switch_id": "vSwitchId",
        "description": "description",
        "network_interface_name": "networkInterfaceName",
        "primary_ip_address": "primaryIpAddress",
        "private_ip_addresses": "privateIpAddresses",
        "resource_group_id": "resourceGroupId",
        "security_group_id": "securityGroupId",
        "security_group_ids": "securityGroupIds",
    },
)
class NetworkInterfaceProps:
    def __init__(
        self,
        *,
        v_switch_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        network_interface_name: typing.Optional[builtins.str] = None,
        primary_ip_address: typing.Optional[builtins.str] = None,
        private_ip_addresses: typing.Optional[typing.List[builtins.str]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        security_group_ids: typing.Optional[typing.List[builtins.str]] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::NetworkInterface``.

        :param v_switch_id: 
        :param description: 
        :param network_interface_name: 
        :param primary_ip_address: 
        :param private_ip_addresses: 
        :param resource_group_id: 
        :param security_group_id: 
        :param security_group_ids: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "v_switch_id": v_switch_id,
        }
        if description is not None:
            self._values["description"] = description
        if network_interface_name is not None:
            self._values["network_interface_name"] = network_interface_name
        if primary_ip_address is not None:
            self._values["primary_ip_address"] = primary_ip_address
        if private_ip_addresses is not None:
            self._values["private_ip_addresses"] = private_ip_addresses
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids

    @builtins.property
    def v_switch_id(self) -> builtins.str:
        """
        :Property: vSwitchId: VSwitch ID of the specified VPC. Specifies the switch ID for the VPC.
        """
        result = self._values.get("v_switch_id")
        assert result is not None, "Required property 'v_switch_id' is missing"
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of your ENI. It is a string of [2, 256] English or Chinese characters.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def network_interface_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: networkInterfaceName: Name of your ENI. It is a string of [2, 128]  Chinese or English characters. It must begin with a letter and can contain numbers, underscores (_), colons (:), or hyphens (-).
        """
        result = self._values.get("network_interface_name")
        return result

    @builtins.property
    def primary_ip_address(self) -> typing.Optional[builtins.str]:
        """
        :Property: primaryIpAddress: The primary private IP address of the ENI.  The specified IP address must have the same Host ID as the VSwitch. If no IP addresses are specified, a random network ID is assigned for the ENI.
        """
        result = self._values.get("primary_ip_address")
        return result

    @builtins.property
    def private_ip_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
        """
        :Property: privateIpAddresses: Specifies secondary private IP addresses of the ENI. This IP address must be an available IP address in the CIDR block of the VSwitch to which the ENI belongs.
        """
        result = self._values.get("private_ip_addresses")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: The ID of the security group that the ENI joins. The security group and the ENI must be in a same VPC.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        """
        :Property: securityGroupIds: The IDs of the security groups that the ENI joins. The security groups and the ENI must belong to the same VPC.
        """
        result = self._values.get("security_group_ids")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkInterfaceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PrepayInstance(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.PrepayInstance",
):
    """A ROS resource type:  ``ALIYUN::ECS::PrepayInstance``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "PrepayInstanceProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::PrepayInstance``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(PrepayInstance, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrHostNames")
    def attr_host_names(self) -> typing.Any:
        """
        :Attribute: HostNames: Host names of created instance.
        """
        return jsii.get(self, "attrHostNames")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInnerIps")
    def attr_inner_ips(self) -> typing.Any:
        """
        :Attribute: InnerIps: Inner IP address list of the specified instance. Only for classical instance.
        """
        return jsii.get(self, "attrInnerIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInstanceIds")
    def attr_instance_ids(self) -> typing.Any:
        """
        :Attribute: InstanceIds: The instance id list of created ecs instance
        """
        return jsii.get(self, "attrInstanceIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> typing.Any:
        """
        :Attribute: OrderId: The order id list of created instance.
        """
        return jsii.get(self, "attrOrderId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateIps")
    def attr_private_ips(self) -> typing.Any:
        """
        :Attribute: PrivateIps: Private IP address list of created ecs instance. Only for VPC instance.
        """
        return jsii.get(self, "attrPrivateIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPublicIps")
    def attr_public_ips(self) -> typing.Any:
        """
        :Attribute: PublicIps: Public IP address list of created ecs instance.
        """
        return jsii.get(self, "attrPublicIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrRelatedOrderIds")
    def attr_related_order_ids(self) -> typing.Any:
        """
        :Attribute: RelatedOrderIds: The related order id list of created ecs instances
        """
        return jsii.get(self, "attrRelatedOrderIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrZoneIds")
    def attr_zone_ids(self) -> typing.Any:
        """
        :Attribute: ZoneIds: Zone id of created instance.
        """
        return jsii.get(self, "attrZoneIds")


class PrepayInstanceGroupClone(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.PrepayInstanceGroupClone",
):
    """A ROS resource type:  ``ALIYUN::ECS::PrepayInstanceGroupClone``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "PrepayInstanceGroupCloneProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::PrepayInstanceGroupClone``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(PrepayInstanceGroupClone, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrHostNames")
    def attr_host_names(self) -> typing.Any:
        """
        :Attribute: HostNames: Host names of created instance.
        """
        return jsii.get(self, "attrHostNames")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInnerIps")
    def attr_inner_ips(self) -> typing.Any:
        """
        :Attribute: InnerIps: Inner IP address list of the specified instance. Only for classical instance.
        """
        return jsii.get(self, "attrInnerIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInstanceIds")
    def attr_instance_ids(self) -> typing.Any:
        """
        :Attribute: InstanceIds: The instance id list of created ecs instance
        """
        return jsii.get(self, "attrInstanceIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> typing.Any:
        """
        :Attribute: OrderId: The order id list of created instance.
        """
        return jsii.get(self, "attrOrderId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateIps")
    def attr_private_ips(self) -> typing.Any:
        """
        :Attribute: PrivateIps: Private IP address list of created ecs instance. Only for VPC instance.
        """
        return jsii.get(self, "attrPrivateIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPublicIps")
    def attr_public_ips(self) -> typing.Any:
        """
        :Attribute: PublicIps: Public IP address list of created ecs instance.
        """
        return jsii.get(self, "attrPublicIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrRelatedOrderIds")
    def attr_related_order_ids(self) -> typing.Any:
        """
        :Attribute: RelatedOrderIds: The related order id list of created ecs instances
        """
        return jsii.get(self, "attrRelatedOrderIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrZoneIds")
    def attr_zone_ids(self) -> typing.Any:
        """
        :Attribute: ZoneIds: Zone id of created instance.
        """
        return jsii.get(self, "attrZoneIds")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.PrepayInstanceGroupCloneProps",
    jsii_struct_bases=[],
    name_mapping={
        "max_amount": "maxAmount",
        "min_amount": "minAmount",
        "period": "period",
        "period_type": "periodType",
        "source_instance_id": "sourceInstanceId",
        "auto_renew": "autoRenew",
        "auto_renew_period": "autoRenewPeriod",
        "deployment_set_id": "deploymentSetId",
        "description": "description",
        "disk_mappings": "diskMappings",
        "eni_mappings": "eniMappings",
        "hpc_cluster_id": "hpcClusterId",
        "image_id": "imageId",
        "instance_name": "instanceName",
        "internet_max_bandwidth_in": "internetMaxBandwidthIn",
        "internet_max_bandwidth_out": "internetMaxBandwidthOut",
        "key_pair_name": "keyPairName",
        "launch_template_id": "launchTemplateId",
        "launch_template_name": "launchTemplateName",
        "launch_template_version": "launchTemplateVersion",
        "password": "password",
        "password_inherit": "passwordInherit",
        "period_unit": "periodUnit",
        "ram_role_name": "ramRoleName",
        "security_group_id": "securityGroupId",
        "security_group_ids": "securityGroupIds",
        "system_disk_auto_snapshot_policy_id": "systemDiskAutoSnapshotPolicyId",
        "system_disk_category": "systemDiskCategory",
        "system_disk_description": "systemDiskDescription",
        "system_disk_disk_name": "systemDiskDiskName",
        "tags": "tags",
        "zone_id": "zoneId",
    },
)
class PrepayInstanceGroupCloneProps:
    def __init__(
        self,
        *,
        max_amount: jsii.Number,
        min_amount: jsii.Number,
        period: jsii.Number,
        period_type: builtins.str,
        source_instance_id: builtins.str,
        auto_renew: typing.Optional[builtins.str] = None,
        auto_renew_period: typing.Optional[jsii.Number] = None,
        deployment_set_id: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        disk_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosPrepayInstanceGroupClone.DiskMappingsProperty"]]]] = None,
        eni_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosPrepayInstanceGroupClone.EniMappingsProperty"]]]] = None,
        hpc_cluster_id: typing.Optional[builtins.str] = None,
        image_id: typing.Optional[builtins.str] = None,
        instance_name: typing.Optional[builtins.str] = None,
        internet_max_bandwidth_in: typing.Optional[jsii.Number] = None,
        internet_max_bandwidth_out: typing.Optional[jsii.Number] = None,
        key_pair_name: typing.Optional[builtins.str] = None,
        launch_template_id: typing.Optional[builtins.str] = None,
        launch_template_name: typing.Optional[builtins.str] = None,
        launch_template_version: typing.Optional[builtins.str] = None,
        password: typing.Optional[builtins.str] = None,
        password_inherit: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        period_unit: typing.Optional[builtins.str] = None,
        ram_role_name: typing.Optional[builtins.str] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        security_group_ids: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
        system_disk_auto_snapshot_policy_id: typing.Optional[builtins.str] = None,
        system_disk_category: typing.Optional[builtins.str] = None,
        system_disk_description: typing.Optional[builtins.str] = None,
        system_disk_disk_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::PrepayInstanceGroupClone``.

        :param max_amount: 
        :param min_amount: 
        :param period: 
        :param period_type: 
        :param source_instance_id: 
        :param auto_renew: 
        :param auto_renew_period: 
        :param deployment_set_id: 
        :param description: 
        :param disk_mappings: 
        :param eni_mappings: 
        :param hpc_cluster_id: 
        :param image_id: 
        :param instance_name: 
        :param internet_max_bandwidth_in: 
        :param internet_max_bandwidth_out: 
        :param key_pair_name: 
        :param launch_template_id: 
        :param launch_template_name: 
        :param launch_template_version: 
        :param password: 
        :param password_inherit: 
        :param period_unit: 
        :param ram_role_name: 
        :param security_group_id: 
        :param security_group_ids: 
        :param system_disk_auto_snapshot_policy_id: 
        :param system_disk_category: 
        :param system_disk_description: 
        :param system_disk_disk_name: 
        :param tags: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "max_amount": max_amount,
            "min_amount": min_amount,
            "period": period,
            "period_type": period_type,
            "source_instance_id": source_instance_id,
        }
        if auto_renew is not None:
            self._values["auto_renew"] = auto_renew
        if auto_renew_period is not None:
            self._values["auto_renew_period"] = auto_renew_period
        if deployment_set_id is not None:
            self._values["deployment_set_id"] = deployment_set_id
        if description is not None:
            self._values["description"] = description
        if disk_mappings is not None:
            self._values["disk_mappings"] = disk_mappings
        if eni_mappings is not None:
            self._values["eni_mappings"] = eni_mappings
        if hpc_cluster_id is not None:
            self._values["hpc_cluster_id"] = hpc_cluster_id
        if image_id is not None:
            self._values["image_id"] = image_id
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if internet_max_bandwidth_in is not None:
            self._values["internet_max_bandwidth_in"] = internet_max_bandwidth_in
        if internet_max_bandwidth_out is not None:
            self._values["internet_max_bandwidth_out"] = internet_max_bandwidth_out
        if key_pair_name is not None:
            self._values["key_pair_name"] = key_pair_name
        if launch_template_id is not None:
            self._values["launch_template_id"] = launch_template_id
        if launch_template_name is not None:
            self._values["launch_template_name"] = launch_template_name
        if launch_template_version is not None:
            self._values["launch_template_version"] = launch_template_version
        if password is not None:
            self._values["password"] = password
        if password_inherit is not None:
            self._values["password_inherit"] = password_inherit
        if period_unit is not None:
            self._values["period_unit"] = period_unit
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if system_disk_auto_snapshot_policy_id is not None:
            self._values["system_disk_auto_snapshot_policy_id"] = system_disk_auto_snapshot_policy_id
        if system_disk_category is not None:
            self._values["system_disk_category"] = system_disk_category
        if system_disk_description is not None:
            self._values["system_disk_description"] = system_disk_description
        if system_disk_disk_name is not None:
            self._values["system_disk_disk_name"] = system_disk_disk_name
        if tags is not None:
            self._values["tags"] = tags
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def max_amount(self) -> jsii.Number:
        """
        :Property: maxAmount: Max number of instances to create, should be smaller than 'MaxAmount' and smaller than 100.
        """
        result = self._values.get("max_amount")
        assert result is not None, "Required property 'max_amount' is missing"
        return result

    @builtins.property
    def min_amount(self) -> jsii.Number:
        """
        :Property: minAmount: Max number of instances to create, should be bigger than 'MinAmount' and smaller than 100.
        """
        result = self._values.get("min_amount")
        assert result is not None, "Required property 'min_amount' is missing"
        return result

    @builtins.property
    def period(self) -> jsii.Number:
        """
        :Property: period: Prepaid time period. While choose by pay by month, it could be from 1 to 9. While choose pay by year, it could be from 1 to 3.
        """
        result = self._values.get("period")
        assert result is not None, "Required property 'period' is missing"
        return result

    @builtins.property
    def period_type(self) -> builtins.str:
        """
        :Property: periodType: Charge period for created instances.
        """
        result = self._values.get("period_type")
        assert result is not None, "Required property 'period_type' is missing"
        return result

    @builtins.property
    def source_instance_id(self) -> builtins.str:
        """
        :Property: sourceInstanceId: Source ecs instance used to copy properties to clone new ecs instance. It will copy the InstanceType, ImageId, InternetChargeType, InternetMaxBandwidthIn, InternetMaxBandwidthOut and the system disk and data disk configurations. If the instance network is VPC, it will also clone the relative properties. If specified instance with more than one security group, it will use the first security group to create instance. you can also specify the SecurityGroupId to override it.
        """
        result = self._values.get("source_instance_id")
        assert result is not None, "Required property 'source_instance_id' is missing"
        return result

    @builtins.property
    def auto_renew(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoRenew: Whether renew the fee automatically? When the parameter InstanceChargeType is PrePaid, it will take effect. Range of value:True: automatic renewal.False: no automatic renewal. Default value is False.Old instances will not be changed.
        """
        result = self._values.get("auto_renew")
        return result

    @builtins.property
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.Old instances will not be changed.
        """
        result = self._values.get("auto_renew_period")
        return result

    @builtins.property
    def deployment_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: deploymentSetId: Deployment set ID. The change of the property does not affect existing instances.
        """
        result = self._values.get("deployment_set_id")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty. Old instances will not be changed.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosPrepayInstanceGroupClone.DiskMappingsProperty"]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.Old instances will not be changed.
        """
        result = self._values.get("disk_mappings")
        return result

    @builtins.property
    def eni_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosPrepayInstanceGroupClone.EniMappingsProperty"]]]]:
        """
        :Property: eniMappings: NetworkInterface to attach to instance. Max support 1 ENI.
        """
        result = self._values.get("eni_mappings")
        return result

    @builtins.property
    def hpc_cluster_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.The change of the property does not affect existing instances.
        """
        result = self._values.get("hpc_cluster_id")
        return result

    @builtins.property
    def image_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        result = self._values.get("image_id")
        return result

    @builtins.property
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("instance_name")
        return result

    @builtins.property
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        result = self._values.get("internet_max_bandwidth_in")
        return result

    @builtins.property
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Set internet output bandwidth of instance. Unit is Mbps(Mega bit per second). Range is [0,200]. Default is 1.While the property is not 0, public ip will be assigned for instance.
        """
        result = self._values.get("internet_max_bandwidth_out")
        return result

    @builtins.property
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.Old instances will not be changed.
        """
        result = self._values.get("key_pair_name")
        return result

    @builtins.property
    def launch_template_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateId: ID of launch template. Launch template id or name must be specified to use launch template
        """
        result = self._values.get("launch_template_id")
        return result

    @builtins.property
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateName: Name of launch template. Launch template id or name must be specified to use launch template
        """
        result = self._values.get("launch_template_name")
        return result

    @builtins.property
    def launch_template_version(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateVersion: Version of launch template. Default version is used if version is not specified.
        """
        result = self._values.get("launch_template_version")
        return result

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        result = self._values.get("password")
        return result

    @builtins.property
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: passwordInherit: Specifies whether to use the password preset in the image. To use the PasswordInherit parameter, the Password parameter must be empty and you must make sure that the selected image has a password configured.
        """
        result = self._values.get("password_inherit")
        return result

    @builtins.property
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month. Default value is Month.Old instances will not be changed.
        """
        result = self._values.get("period_unit")
        return result

    @builtins.property
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        result = self._values.get("ram_role_name")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def security_group_ids(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property: securityGroupIds: The IDs of security groups N to which the instance belongs. The valid values of N are based on the maximum number of security groups to which an instance can belong. For more information, see Security group limits.Note: You cannot specify both SecurityGroupId and SecurityGroupIds at the same time.
        """
        result = self._values.get("security_group_ids")
        return result

    @builtins.property
    def system_disk_auto_snapshot_policy_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskAutoSnapshotPolicyId: Auto snapshot policy ID.
        """
        result = self._values.get("system_disk_auto_snapshot_policy_id")
        return result

    @builtins.property
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. Default is cloud_efficiency. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd.Old instances will not be changed.
        """
        result = self._values.get("system_disk_category")
        return result

    @builtins.property
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.Old instances will not be changed.
        """
        result = self._values.get("system_disk_description")
        return result

    @builtins.property
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.Old instances will not be changed.
        """
        result = self._values.get("system_disk_disk_name")
        return result

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrepayInstanceGroupCloneProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.PrepayInstanceProps",
    jsii_struct_bases=[],
    name_mapping={
        "image_id": "imageId",
        "instance_type": "instanceType",
        "max_amount": "maxAmount",
        "min_amount": "minAmount",
        "period": "period",
        "period_type": "periodType",
        "allocate_public_ip": "allocatePublicIp",
        "auto_renew": "autoRenew",
        "auto_renew_period": "autoRenewPeriod",
        "dedicated_host_id": "dedicatedHostId",
        "deployment_set_id": "deploymentSetId",
        "description": "description",
        "disk_mappings": "diskMappings",
        "host_name": "hostName",
        "hpc_cluster_id": "hpcClusterId",
        "instance_charge_type": "instanceChargeType",
        "instance_name": "instanceName",
        "internet_charge_type": "internetChargeType",
        "internet_max_bandwidth_in": "internetMaxBandwidthIn",
        "internet_max_bandwidth_out": "internetMaxBandwidthOut",
        "io_optimized": "ioOptimized",
        "key_pair_name": "keyPairName",
        "password": "password",
        "password_inherit": "passwordInherit",
        "period_unit": "periodUnit",
        "private_ip_address": "privateIpAddress",
        "ram_role_name": "ramRoleName",
        "security_enhancement_strategy": "securityEnhancementStrategy",
        "security_group_id": "securityGroupId",
        "system_disk_category": "systemDiskCategory",
        "system_disk_description": "systemDiskDescription",
        "system_disk_disk_name": "systemDiskDiskName",
        "system_disk_performance_level": "systemDiskPerformanceLevel",
        "system_disk_size": "systemDiskSize",
        "tags": "tags",
        "user_data": "userData",
        "vpc_id": "vpcId",
        "v_switch_id": "vSwitchId",
        "zone_id": "zoneId",
    },
)
class PrepayInstanceProps:
    def __init__(
        self,
        *,
        image_id: builtins.str,
        instance_type: builtins.str,
        max_amount: jsii.Number,
        min_amount: jsii.Number,
        period: jsii.Number,
        period_type: builtins.str,
        allocate_public_ip: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        auto_renew: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        auto_renew_period: typing.Optional[jsii.Number] = None,
        dedicated_host_id: typing.Optional[builtins.str] = None,
        deployment_set_id: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        disk_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosPrepayInstance.DiskMappingsProperty"]]]] = None,
        host_name: typing.Optional[builtins.str] = None,
        hpc_cluster_id: typing.Optional[builtins.str] = None,
        instance_charge_type: typing.Optional[builtins.str] = None,
        instance_name: typing.Optional[builtins.str] = None,
        internet_charge_type: typing.Optional[builtins.str] = None,
        internet_max_bandwidth_in: typing.Optional[jsii.Number] = None,
        internet_max_bandwidth_out: typing.Optional[jsii.Number] = None,
        io_optimized: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        key_pair_name: typing.Optional[builtins.str] = None,
        password: typing.Optional[builtins.str] = None,
        password_inherit: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        period_unit: typing.Optional[builtins.str] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        ram_role_name: typing.Optional[builtins.str] = None,
        security_enhancement_strategy: typing.Optional[builtins.str] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        system_disk_category: typing.Optional[builtins.str] = None,
        system_disk_description: typing.Optional[builtins.str] = None,
        system_disk_disk_name: typing.Optional[builtins.str] = None,
        system_disk_performance_level: typing.Optional[builtins.str] = None,
        system_disk_size: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]] = None,
        user_data: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
        v_switch_id: typing.Optional[builtins.str] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::PrepayInstance``.

        :param image_id: 
        :param instance_type: 
        :param max_amount: 
        :param min_amount: 
        :param period: 
        :param period_type: 
        :param allocate_public_ip: 
        :param auto_renew: 
        :param auto_renew_period: 
        :param dedicated_host_id: 
        :param deployment_set_id: 
        :param description: 
        :param disk_mappings: 
        :param host_name: 
        :param hpc_cluster_id: 
        :param instance_charge_type: 
        :param instance_name: 
        :param internet_charge_type: 
        :param internet_max_bandwidth_in: 
        :param internet_max_bandwidth_out: 
        :param io_optimized: 
        :param key_pair_name: 
        :param password: 
        :param password_inherit: 
        :param period_unit: 
        :param private_ip_address: 
        :param ram_role_name: 
        :param security_enhancement_strategy: 
        :param security_group_id: 
        :param system_disk_category: 
        :param system_disk_description: 
        :param system_disk_disk_name: 
        :param system_disk_performance_level: 
        :param system_disk_size: 
        :param tags: 
        :param user_data: 
        :param vpc_id: 
        :param v_switch_id: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "image_id": image_id,
            "instance_type": instance_type,
            "max_amount": max_amount,
            "min_amount": min_amount,
            "period": period,
            "period_type": period_type,
        }
        if allocate_public_ip is not None:
            self._values["allocate_public_ip"] = allocate_public_ip
        if auto_renew is not None:
            self._values["auto_renew"] = auto_renew
        if auto_renew_period is not None:
            self._values["auto_renew_period"] = auto_renew_period
        if dedicated_host_id is not None:
            self._values["dedicated_host_id"] = dedicated_host_id
        if deployment_set_id is not None:
            self._values["deployment_set_id"] = deployment_set_id
        if description is not None:
            self._values["description"] = description
        if disk_mappings is not None:
            self._values["disk_mappings"] = disk_mappings
        if host_name is not None:
            self._values["host_name"] = host_name
        if hpc_cluster_id is not None:
            self._values["hpc_cluster_id"] = hpc_cluster_id
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if internet_max_bandwidth_in is not None:
            self._values["internet_max_bandwidth_in"] = internet_max_bandwidth_in
        if internet_max_bandwidth_out is not None:
            self._values["internet_max_bandwidth_out"] = internet_max_bandwidth_out
        if io_optimized is not None:
            self._values["io_optimized"] = io_optimized
        if key_pair_name is not None:
            self._values["key_pair_name"] = key_pair_name
        if password is not None:
            self._values["password"] = password
        if password_inherit is not None:
            self._values["password_inherit"] = password_inherit
        if period_unit is not None:
            self._values["period_unit"] = period_unit
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if security_enhancement_strategy is not None:
            self._values["security_enhancement_strategy"] = security_enhancement_strategy
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if system_disk_category is not None:
            self._values["system_disk_category"] = system_disk_category
        if system_disk_description is not None:
            self._values["system_disk_description"] = system_disk_description
        if system_disk_disk_name is not None:
            self._values["system_disk_disk_name"] = system_disk_disk_name
        if system_disk_performance_level is not None:
            self._values["system_disk_performance_level"] = system_disk_performance_level
        if system_disk_size is not None:
            self._values["system_disk_size"] = system_disk_size
        if tags is not None:
            self._values["tags"] = tags
        if user_data is not None:
            self._values["user_data"] = user_data
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id
        if v_switch_id is not None:
            self._values["v_switch_id"] = v_switch_id
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def image_id(self) -> builtins.str:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        result = self._values.get("image_id")
        assert result is not None, "Required property 'image_id' is missing"
        return result

    @builtins.property
    def instance_type(self) -> builtins.str:
        """
        :Property: instanceType: Ecs instance supported instance type, make sure it should be correct.
        """
        result = self._values.get("instance_type")
        assert result is not None, "Required property 'instance_type' is missing"
        return result

    @builtins.property
    def max_amount(self) -> jsii.Number:
        """
        :Property: maxAmount: Max number of instances to create, should be smaller than 'MaxAmount' and smaller than 100.
        """
        result = self._values.get("max_amount")
        assert result is not None, "Required property 'max_amount' is missing"
        return result

    @builtins.property
    def min_amount(self) -> jsii.Number:
        """
        :Property: minAmount: Max number of instances to create, should be bigger than 'MinAmount' and smaller than 100.
        """
        result = self._values.get("min_amount")
        assert result is not None, "Required property 'min_amount' is missing"
        return result

    @builtins.property
    def period(self) -> jsii.Number:
        """
        :Property: period: Prepaid time period. While choose by pay by month, it could be from 1 to 9. While choose pay by year, it could be from 1 to 3.
        """
        result = self._values.get("period")
        assert result is not None, "Required property 'period' is missing"
        return result

    @builtins.property
    def period_type(self) -> builtins.str:
        """
        :Property: periodType: Charge period for created instances.
        """
        result = self._values.get("period_type")
        assert result is not None, "Required property 'period_type' is missing"
        return result

    @builtins.property
    def allocate_public_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: allocatePublicIp: The public ip for ecs instance, if properties is true, will allocate public ip. If property InternetMaxBandwidthOut set to 0, it will not assign public ip.
        """
        result = self._values.get("allocate_public_ip")
        return result

    @builtins.property
    def auto_renew(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: autoRenew: Auto renew the prepay instance. If the period type is by year, it will renew by year, else it will renew by month.
        """
        result = self._values.get("auto_renew")
        return result

    @builtins.property
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.
        """
        result = self._values.get("auto_renew_period")
        return result

    @builtins.property
    def dedicated_host_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: dedicatedHostId: which dedicated host will be deployed
        """
        result = self._values.get("dedicated_host_id")
        return result

    @builtins.property
    def deployment_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: deploymentSetId: Deployment set ID.
        """
        result = self._values.get("deployment_set_id")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosPrepayInstance.DiskMappingsProperty"]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.
        """
        result = self._values.get("disk_mappings")
        return result

    @builtins.property
    def host_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: hostName: Host name of created ecs instance. at least 2 characters, and '.' '-' Is not the first and last characters as hostname, not continuous use. Windows platform can be up to 15 characters, allowing letters (without limiting case), numbers and '-', and does not support the number of points, not all is digital ('.').Other (Linux, etc.) platform up to 30 characters, allowing support number multiple points for the period between the points, each permit letters (without limiting case), numbers and '-' components.
        """
        result = self._values.get("host_name")
        return result

    @builtins.property
    def hpc_cluster_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.
        """
        result = self._values.get("hpc_cluster_id")
        return result

    @builtins.property
    def instance_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceChargeType: Instance Charge type, allowed value: Prepaid and Postpaid. If specified Prepaid, please ensure you have sufficient balance in your account. Or instance creation will be failure. Default value is Postpaid.
        """
        result = self._values.get("instance_charge_type")
        return result

    @builtins.property
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("instance_name")
        return result

    @builtins.property
    def internet_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: internetChargeType: Instance internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only. For AfterPay instance, default is 'PayByBandwidth'.
        """
        result = self._values.get("internet_charge_type")
        return result

    @builtins.property
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        result = self._values.get("internet_max_bandwidth_in")
        return result

    @builtins.property
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Set internet output bandwidth of instance. Unit is Mbps(Mega bit per second). Range is [0,200]. Default is 1.While the property is not 0, public ip will be assigned for instance.
        """
        result = self._values.get("internet_max_bandwidth_out")
        return result

    @builtins.property
    def io_optimized(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: ioOptimized: The 'optimized' instance can provide better IO performance. Support true or false, Default is true.
        """
        result = self._values.get("io_optimized")
        return result

    @builtins.property
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.
        """
        result = self._values.get("key_pair_name")
        return result

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        result = self._values.get("password")
        return result

    @builtins.property
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: passwordInherit: Specifies whether to use the password preset in the image. To use the PasswordInherit parameter, the Password parameter must be empty and you must make sure that the selected image has a password configured.
        """
        result = self._values.get("password_inherit")
        return result

    @builtins.property
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month/Year. Default value is Month.
        """
        result = self._values.get("period_unit")
        return result

    @builtins.property
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        """
        :Property: privateIpAddress: Private IP for the instance created. Only works for VPC instance and cannot duplicated with existing instance.
        """
        result = self._values.get("private_ip_address")
        return result

    @builtins.property
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        result = self._values.get("ram_role_name")
        return result

    @builtins.property
    def security_enhancement_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityEnhancementStrategy:
        """
        result = self._values.get("security_enhancement_strategy")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. Default is cloud_efficiency. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd
        """
        result = self._values.get("system_disk_category")
        return result

    @builtins.property
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.
        """
        result = self._values.get("system_disk_description")
        return result

    @builtins.property
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.
        """
        result = self._values.get("system_disk_disk_name")
        return result

    @builtins.property
    def system_disk_performance_level(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskPerformanceLevel: The performance level of the enhanced SSD used as the system disk.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
        """
        result = self._values.get("system_disk_performance_level")
        return result

    @builtins.property
    def system_disk_size(self) -> typing.Optional[jsii.Number]:
        """
        :Property: systemDiskSize: Disk size of the system disk, range from 20 to 500 GB. If you specify with your own image, make sure the system disk size bigger than image size.
        """
        result = self._values.get("system_disk_size")
        return result

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def user_data(self) -> typing.Optional[builtins.str]:
        """
        :Property: userData: User data to pass to instance. [1, 16KB] characters.User data should not be base64 encoded. If you want to pass base64 encoded string to the property, use function Fn::Base64Decode to decode the base64 string first.
        """
        result = self._values.get("user_data")
        return result

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcId: The VPC id to create ecs instance.
        """
        result = self._values.get("vpc_id")
        return result

    @builtins.property
    def v_switch_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vSwitchId: The vSwitch Id to create ecs instance.
        """
        result = self._values.get("v_switch_id")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrepayInstanceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosAssignIpv6Addresses(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosAssignIpv6Addresses",
):
    """A ROS template type:  ``ALIYUN::ECS::AssignIpv6Addresses``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosAssignIpv6AddressesProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::AssignIpv6Addresses``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosAssignIpv6Addresses, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrIpv6Addresses")
    def attr_ipv6_addresses(self) -> typing.Any:
        """
        :Attribute: Ipv6Addresses: Assigned IPv6 addresses.
        """
        return jsii.get(self, "attrIpv6Addresses")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrIpv6AddressIds")
    def attr_ipv6_address_ids(self) -> typing.Any:
        """
        :Attribute: Ipv6AddressIds: Assigned IPv6 address IDs.
        """
        return jsii.get(self, "attrIpv6AddressIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrNetworkInterfaceId")
    def attr_network_interface_id(self) -> typing.Any:
        """
        :Attribute: NetworkInterfaceId: Elastic network interface ID.
        """
        return jsii.get(self, "attrNetworkInterfaceId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="networkInterfaceId")
    def network_interface_id(self) -> builtins.str:
        """
        :Property: networkInterfaceId: Elastic network interface ID.
        """
        return jsii.get(self, "networkInterfaceId")

    @network_interface_id.setter # type: ignore
    def network_interface_id(self, value: builtins.str) -> None:
        jsii.set(self, "networkInterfaceId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ipv6AddressCount")
    def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        ipv6AddressCount: IPv6 addresses specified number of randomly generated interfaces elasticity.
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        """
        return jsii.get(self, "ipv6AddressCount")

    @ipv6_address_count.setter # type: ignore
    def ipv6_address_count(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "ipv6AddressCount", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ipv6Addresses")
    def ipv6_addresses(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property:

        ipv6Addresses: Specify one or more IPv6 addresses for the elastic NIC. Currently, the maximum list size is 1. Example value: 2001:db8:1234:1a00::*** .
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        """
        return jsii.get(self, "ipv6Addresses")

    @ipv6_addresses.setter # type: ignore
    def ipv6_addresses(
        self,
        value: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "ipv6Addresses", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosAssignIpv6AddressesProps",
    jsii_struct_bases=[],
    name_mapping={
        "network_interface_id": "networkInterfaceId",
        "ipv6_address_count": "ipv6AddressCount",
        "ipv6_addresses": "ipv6Addresses",
    },
)
class RosAssignIpv6AddressesProps:
    def __init__(
        self,
        *,
        network_interface_id: builtins.str,
        ipv6_address_count: typing.Optional[jsii.Number] = None,
        ipv6_addresses: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::AssignIpv6Addresses``.

        :param network_interface_id: 
        :param ipv6_address_count: 
        :param ipv6_addresses: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "network_interface_id": network_interface_id,
        }
        if ipv6_address_count is not None:
            self._values["ipv6_address_count"] = ipv6_address_count
        if ipv6_addresses is not None:
            self._values["ipv6_addresses"] = ipv6_addresses

    @builtins.property
    def network_interface_id(self) -> builtins.str:
        """
        :Property: networkInterfaceId: Elastic network interface ID.
        """
        result = self._values.get("network_interface_id")
        assert result is not None, "Required property 'network_interface_id' is missing"
        return result

    @builtins.property
    def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        ipv6AddressCount: IPv6 addresses specified number of randomly generated interfaces elasticity.
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        """
        result = self._values.get("ipv6_address_count")
        return result

    @builtins.property
    def ipv6_addresses(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property:

        ipv6Addresses: Specify one or more IPv6 addresses for the elastic NIC. Currently, the maximum list size is 1. Example value: 2001:db8:1234:1a00::*** .
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        """
        result = self._values.get("ipv6_addresses")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosAssignIpv6AddressesProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosAssignPrivateIpAddresses(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosAssignPrivateIpAddresses",
):
    """A ROS template type:  ``ALIYUN::ECS::AssignPrivateIpAddresses``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosAssignPrivateIpAddressesProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::AssignPrivateIpAddresses``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosAssignPrivateIpAddresses, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrNetworkInterfaceId")
    def attr_network_interface_id(self) -> typing.Any:
        """
        :Attribute: NetworkInterfaceId: The ID of the ENI.
        """
        return jsii.get(self, "attrNetworkInterfaceId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateIpAddresses")
    def attr_private_ip_addresses(self) -> typing.Any:
        """
        :Attribute: PrivateIpAddresses: Assigned private ip addresses.
        """
        return jsii.get(self, "attrPrivateIpAddresses")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="networkInterfaceId")
    def network_interface_id(self) -> builtins.str:
        """
        :Property: networkInterfaceId: The ID of the ENI.
        """
        return jsii.get(self, "networkInterfaceId")

    @network_interface_id.setter # type: ignore
    def network_interface_id(self, value: builtins.str) -> None:
        jsii.set(self, "networkInterfaceId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="privateIpAddresses")
    def private_ip_addresses(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property:

        privateIpAddresses: One or multiple secondary private IP addresses selected from the CIDR block of the VSwitch that hosts the ENI.
        Valid values of number of private ip addresses:
        When the ENI is in the Available state: 1 to 10.
        When the ENI is in the InUse state: limited by the instance type.
        For more information, see Instance type families.
        You must specify either the PrivateIpAddresses parameter or the SecondaryPrivateIpAddressCount parameter to assign secondary private IP addresses.
        """
        return jsii.get(self, "privateIpAddresses")

    @private_ip_addresses.setter # type: ignore
    def private_ip_addresses(
        self,
        value: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "privateIpAddresses", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> typing.Optional[jsii.Number]:
        """
        :Property: secondaryPrivateIpAddressCount: The specified number of private IP addresses to be assigned by the ECS instance.
        """
        return jsii.get(self, "secondaryPrivateIpAddressCount")

    @secondary_private_ip_address_count.setter # type: ignore
    def secondary_private_ip_address_count(
        self,
        value: typing.Optional[jsii.Number],
    ) -> None:
        jsii.set(self, "secondaryPrivateIpAddressCount", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosAssignPrivateIpAddressesProps",
    jsii_struct_bases=[],
    name_mapping={
        "network_interface_id": "networkInterfaceId",
        "private_ip_addresses": "privateIpAddresses",
        "secondary_private_ip_address_count": "secondaryPrivateIpAddressCount",
    },
)
class RosAssignPrivateIpAddressesProps:
    def __init__(
        self,
        *,
        network_interface_id: builtins.str,
        private_ip_addresses: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
        secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::AssignPrivateIpAddresses``.

        :param network_interface_id: 
        :param private_ip_addresses: 
        :param secondary_private_ip_address_count: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "network_interface_id": network_interface_id,
        }
        if private_ip_addresses is not None:
            self._values["private_ip_addresses"] = private_ip_addresses
        if secondary_private_ip_address_count is not None:
            self._values["secondary_private_ip_address_count"] = secondary_private_ip_address_count

    @builtins.property
    def network_interface_id(self) -> builtins.str:
        """
        :Property: networkInterfaceId: The ID of the ENI.
        """
        result = self._values.get("network_interface_id")
        assert result is not None, "Required property 'network_interface_id' is missing"
        return result

    @builtins.property
    def private_ip_addresses(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property:

        privateIpAddresses: One or multiple secondary private IP addresses selected from the CIDR block of the VSwitch that hosts the ENI.
        Valid values of number of private ip addresses:
        When the ENI is in the Available state: 1 to 10.
        When the ENI is in the InUse state: limited by the instance type.
        For more information, see Instance type families.
        You must specify either the PrivateIpAddresses parameter or the SecondaryPrivateIpAddressCount parameter to assign secondary private IP addresses.
        """
        result = self._values.get("private_ip_addresses")
        return result

    @builtins.property
    def secondary_private_ip_address_count(self) -> typing.Optional[jsii.Number]:
        """
        :Property: secondaryPrivateIpAddressCount: The specified number of private IP addresses to be assigned by the ECS instance.
        """
        result = self._values.get("secondary_private_ip_address_count")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosAssignPrivateIpAddressesProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosAutoProvisioningGroup(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosAutoProvisioningGroup",
):
    """A ROS template type:  ``ALIYUN::ECS::AutoProvisioningGroup``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosAutoProvisioningGroupProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::AutoProvisioningGroup``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosAutoProvisioningGroup, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrAutoProvisioningGroupId")
    def attr_auto_provisioning_group_id(self) -> typing.Any:
        """
        :Attribute: AutoProvisioningGroupId: The ID of the auto provisioning group.
        """
        return jsii.get(self, "attrAutoProvisioningGroupId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="launchTemplateId")
    def launch_template_id(self) -> builtins.str:
        """
        :Property:

        launchTemplateId: The ID of the instance launch template associated with the auto provisioning group.
        You can call the DescribeLaunchTemplates operation to query available instance launch templates.
        An auto provisioning group can be associated with only one instance launch template.
        But you can configure multiple extended configurations for the launch template through
        the LaunchTemplateConfig parameter.
        """
        return jsii.get(self, "launchTemplateId")

    @launch_template_id.setter # type: ignore
    def launch_template_id(self, value: builtins.str) -> None:
        jsii.set(self, "launchTemplateId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="totalTargetCapacity")
    def total_target_capacity(self) -> builtins.str:
        """
        :Property:

        totalTargetCapacity: The total target capacity of the auto provisioning group. The target capacity consists
        of the following three parts:
        The target capacity of pay-as-you-go instances specified by the PayAsYouGoTargetCapacity parameter
        The target capacity of preemptible instances specified by the SpotTargetCapacity parameter
        The supplemental capacity besides PayAsYouGoTargetCapacity and SpotTargetCapacity
        """
        return jsii.get(self, "totalTargetCapacity")

    @total_target_capacity.setter # type: ignore
    def total_target_capacity(self, value: builtins.str) -> None:
        jsii.set(self, "totalTargetCapacity", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoProvisioningGroupName")
    def auto_provisioning_group_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        autoProvisioningGroupName: The name of the auto provisioning group to be created. It must be 2 to 128 characters
        in length. It must start with a letter but cannot start with http:// or https://.
        It can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        """
        return jsii.get(self, "autoProvisioningGroupName")

    @auto_provisioning_group_name.setter # type: ignore
    def auto_provisioning_group_name(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "autoProvisioningGroupName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoProvisioningGroupType")
    def auto_provisioning_group_type(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        autoProvisioningGroupType: The type of the auto provisioning group. Valid values:
        request: One-time delivery. After the auto provisioning group is started, it only attempts
        to create an instance cluster once. If the cluster fails to be created, the group
        does not try again.
        maintain: The continuous delivery and maintain capacity type. After the auto provisioning group
        is started, it continuously attempts to create and maintain the instance cluster.
        The auto provisioning group compares the real-time and target capacity of the cluster.
        If the cluster does not meet the target capacity, the group will create instances
        until the cluster meets the target capacity.
        Default value: maintain
        """
        return jsii.get(self, "autoProvisioningGroupType")

    @auto_provisioning_group_type.setter # type: ignore
    def auto_provisioning_group_type(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "autoProvisioningGroupType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="defaultTargetCapacityType")
    def default_target_capacity_type(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        defaultTargetCapacityType: The type of supplemental instances. When the total value of PayAsYouGoTargetCapacity and SpotTargetCapacity is smaller than the value of TotalTargetCapacity, the auto provisioning group will create instances of the specified type to meet
        the capacity requirements. Valid values:
        PayAsYouGo: Pay-as-you-go instances.
        Spot: Preemptible instances.
        Default value: Spot
        """
        return jsii.get(self, "defaultTargetCapacityType")

    @default_target_capacity_type.setter # type: ignore
    def default_target_capacity_type(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "defaultTargetCapacityType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: The description of the auto provisioning group.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="excessCapacityTerminationPolicy")
    def excess_capacity_termination_policy(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        excessCapacityTerminationPolicy: The shutdown policy for excess preemptible instances followed when the capacity of
        the auto provisioning group exceeds the target capacity. Valid values:
        no-termination: Excess preemptible instances are not shut down.
        termination: Excess preemptible instances are to be shut down. The action to be performed on these
        shutdown instances is specified by the SpotInstanceInterruptionBehavior parameter.
        Default value: no-termination
        """
        return jsii.get(self, "excessCapacityTerminationPolicy")

    @excess_capacity_termination_policy.setter # type: ignore
    def excess_capacity_termination_policy(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "excessCapacityTerminationPolicy", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="launchTemplateConfig")
    def launch_template_config(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosAutoProvisioningGroup.LaunchTemplateConfigProperty"]]]]:
        """
        :Property: launchTemplateConfig:
        """
        return jsii.get(self, "launchTemplateConfig")

    @launch_template_config.setter # type: ignore
    def launch_template_config(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosAutoProvisioningGroup.LaunchTemplateConfigProperty"]]]],
    ) -> None:
        jsii.set(self, "launchTemplateConfig", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="launchTemplateVersion")
    def launch_template_version(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        launchTemplateVersion: The version of the instance launch template associated with the auto provisioning
        group. You can call the DescribeLaunchTemplateVersions operation to query the versions of available instance launch templates.
        """
        return jsii.get(self, "launchTemplateVersion")

    @launch_template_version.setter # type: ignore
    def launch_template_version(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "launchTemplateVersion", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="maxSpotPrice")
    def max_spot_price(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        maxSpotPrice: The global maximum price for preemptible instances in the auto provisioning group.
        If both the MaxSpotPrice and LaunchTemplateConfig.N.MaxPrice parameters are specified, the maximum price is the lower value of the two.
        """
        return jsii.get(self, "maxSpotPrice")

    @max_spot_price.setter # type: ignore
    def max_spot_price(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "maxSpotPrice", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="payAsYouGoAllocationStrategy")
    def pay_as_you_go_allocation_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        payAsYouGoAllocationStrategy: The scale-out policy for pay-as-you-go instances. Valid values:
        lowest-price: The cost optimization policy the auto provisioning group follows to select instance
        types of the lowest cost to create instances.
        prioritized: The priority-based policy the auto provisioning group follows to create instances.
        The priority of an instance type is specified by the LaunchTemplateConfig.N.Priority parameter.
        Default value: lowest-price
        """
        return jsii.get(self, "payAsYouGoAllocationStrategy")

    @pay_as_you_go_allocation_strategy.setter # type: ignore
    def pay_as_you_go_allocation_strategy(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "payAsYouGoAllocationStrategy", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="payAsYouGoTargetCapacity")
    def pay_as_you_go_target_capacity(self) -> typing.Optional[builtins.str]:
        """
        :Property: payAsYouGoTargetCapacity: The target capacity of pay-as-you-go instances in the auto provisioning group.
        """
        return jsii.get(self, "payAsYouGoTargetCapacity")

    @pay_as_you_go_target_capacity.setter # type: ignore
    def pay_as_you_go_target_capacity(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "payAsYouGoTargetCapacity", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="spotAllocationStrategy")
    def spot_allocation_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        spotAllocationStrategy: The scale-out policy for preemptible instances. Valid values:
        lowest-price: The cost optimization policy the auto provisioning group follows to select instance
        types of the lowest cost to create instances.
        diversified: The distribution balancing policy the auto provisioning group follows to evenly create
        instances across zones specified in multiple extended template configurations.
        Default value: lowest-price
        """
        return jsii.get(self, "spotAllocationStrategy")

    @spot_allocation_strategy.setter # type: ignore
    def spot_allocation_strategy(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "spotAllocationStrategy", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="spotInstanceInterruptionBehavior")
    def spot_instance_interruption_behavior(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        spotInstanceInterruptionBehavior: The default behavior after preemptible instances are shut down. Value values:
        stop: stops preemptible instances.
        terminate: releases preemptible instances.
        Default value: stop
        """
        return jsii.get(self, "spotInstanceInterruptionBehavior")

    @spot_instance_interruption_behavior.setter # type: ignore
    def spot_instance_interruption_behavior(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "spotInstanceInterruptionBehavior", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="spotInstancePoolsToUseCount")
    def spot_instance_pools_to_use_count(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        spotInstancePoolsToUseCount: This parameter takes effect when the SpotAllocationStrategy parameter is set to lowest-price. The auto provisioning group selects instance types of the lowest cost to create
        instances.
        """
        return jsii.get(self, "spotInstancePoolsToUseCount")

    @spot_instance_pools_to_use_count.setter # type: ignore
    def spot_instance_pools_to_use_count(
        self,
        value: typing.Optional[jsii.Number],
    ) -> None:
        jsii.set(self, "spotInstancePoolsToUseCount", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="spotTargetCapacity")
    def spot_target_capacity(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotTargetCapacity: The target capacity of preemptible instances in the auto provisioning group.
        """
        return jsii.get(self, "spotTargetCapacity")

    @spot_target_capacity.setter # type: ignore
    def spot_target_capacity(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "spotTargetCapacity", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="terminateInstances")
    def terminate_instances(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        terminateInstances: Specifies whether to release instances of the auto provisioning group. Valid values:
        true
        false
        Default: false
        """
        return jsii.get(self, "terminateInstances")

    @terminate_instances.setter # type: ignore
    def terminate_instances(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "terminateInstances", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="terminateInstancesWithExpiration")
    def terminate_instances_with_expiration(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        terminateInstancesWithExpiration: The shutdown policy for preemptible instances when the auto provisioning group expires.
        Valid values:
        true: shuts down preemptible instances. The action to be performed on these shutdown instances
        is specified by the SpotInstanceInterruptionBehavior parameter.
        false: does not shut down preemptible instances.
        Default: false
        """
        return jsii.get(self, "terminateInstancesWithExpiration")

    @terminate_instances_with_expiration.setter # type: ignore
    def terminate_instances_with_expiration(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "terminateInstancesWithExpiration", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="validFrom")
    def valid_from(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        validFrom: The time when the auto provisioning group is started. The period of time between this
        point in time and the point in time specified by the ValidUntil parameter is the effective time period of the auto provisioning group.
        By default, an auto provisioning group is immediately started after creation.
        """
        return jsii.get(self, "validFrom")

    @valid_from.setter # type: ignore
    def valid_from(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "validFrom", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="validUntil")
    def valid_until(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        validUntil: The time when the auto provisioning group expires. The period of time between this
        point in time and the point in time specified by the ValidFrom parameter is the effective time period of the auto provisioning group.
        By default, an auto provisioning group never expires.
        """
        return jsii.get(self, "validUntil")

    @valid_until.setter # type: ignore
    def valid_until(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "validUntil", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosAutoProvisioningGroup.LaunchTemplateConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "max_price": "maxPrice",
            "v_switch_id": "vSwitchId",
            "instance_type": "instanceType",
            "priority": "priority",
            "weighted_capacity": "weightedCapacity",
        },
    )
    class LaunchTemplateConfigProperty:
        def __init__(
            self,
            *,
            max_price: jsii.Number,
            v_switch_id: builtins.str,
            instance_type: typing.Optional[builtins.str] = None,
            priority: typing.Optional[jsii.Number] = None,
            weighted_capacity: typing.Optional[jsii.Number] = None,
        ) -> None:
            """
            :param max_price: 
            :param v_switch_id: 
            :param instance_type: 
            :param priority: 
            :param weighted_capacity: 
            """
            self._values: typing.Dict[str, typing.Any] = {
                "max_price": max_price,
                "v_switch_id": v_switch_id,
            }
            if instance_type is not None:
                self._values["instance_type"] = instance_type
            if priority is not None:
                self._values["priority"] = priority
            if weighted_capacity is not None:
                self._values["weighted_capacity"] = weighted_capacity

        @builtins.property
        def max_price(self) -> jsii.Number:
            """
            :Property:

            maxPrice: The maximum price of the instance type specified in the Nth extended configurations
            of the launch template.
            """
            result = self._values.get("max_price")
            assert result is not None, "Required property 'max_price' is missing"
            return result

        @builtins.property
        def v_switch_id(self) -> builtins.str:
            """
            :Property: vSwitchId: The ID of the VSwitch in the Nth extended configurations of the launch template.
            """
            result = self._values.get("v_switch_id")
            assert result is not None, "Required property 'v_switch_id' is missing"
            return result

        @builtins.property
        def instance_type(self) -> typing.Optional[builtins.str]:
            """
            :Property: instanceType: The instance type of the Nth extended configurations of the launch template.
            """
            result = self._values.get("instance_type")
            return result

        @builtins.property
        def priority(self) -> typing.Optional[jsii.Number]:
            """
            :Property:

            priority: The priority of the instance type specified in the Nth extended configurations of
            the launch template. A value of 0 indicates the highest priority.
            """
            result = self._values.get("priority")
            return result

        @builtins.property
        def weighted_capacity(self) -> typing.Optional[jsii.Number]:
            """
            :Property:

            weightedCapacity: The weight of the instance type specified in the Nth extended configurations of the
            launch template.
            The weight is calculated based on the computing power of a specified instance type
            and the minimum computing power of a single node of the cluster. A greater weight
            indicates that the instance has more computing power, and as a result fewer instances
            are required.
            For example, when the minimum computing power of a single node is 8 vCPUs and 60 GiB
            of memory, the weight of the instance type with 8 vCPUs and 60 GiB of memory is 1,
            and the weight of the instance type with 16 vCPUs and 120 GiB of memory is 2.
            """
            result = self._values.get("weighted_capacity")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LaunchTemplateConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosAutoProvisioningGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "launch_template_id": "launchTemplateId",
        "total_target_capacity": "totalTargetCapacity",
        "auto_provisioning_group_name": "autoProvisioningGroupName",
        "auto_provisioning_group_type": "autoProvisioningGroupType",
        "default_target_capacity_type": "defaultTargetCapacityType",
        "description": "description",
        "excess_capacity_termination_policy": "excessCapacityTerminationPolicy",
        "launch_template_config": "launchTemplateConfig",
        "launch_template_version": "launchTemplateVersion",
        "max_spot_price": "maxSpotPrice",
        "pay_as_you_go_allocation_strategy": "payAsYouGoAllocationStrategy",
        "pay_as_you_go_target_capacity": "payAsYouGoTargetCapacity",
        "spot_allocation_strategy": "spotAllocationStrategy",
        "spot_instance_interruption_behavior": "spotInstanceInterruptionBehavior",
        "spot_instance_pools_to_use_count": "spotInstancePoolsToUseCount",
        "spot_target_capacity": "spotTargetCapacity",
        "terminate_instances": "terminateInstances",
        "terminate_instances_with_expiration": "terminateInstancesWithExpiration",
        "valid_from": "validFrom",
        "valid_until": "validUntil",
    },
)
class RosAutoProvisioningGroupProps:
    def __init__(
        self,
        *,
        launch_template_id: builtins.str,
        total_target_capacity: builtins.str,
        auto_provisioning_group_name: typing.Optional[builtins.str] = None,
        auto_provisioning_group_type: typing.Optional[builtins.str] = None,
        default_target_capacity_type: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        excess_capacity_termination_policy: typing.Optional[builtins.str] = None,
        launch_template_config: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosAutoProvisioningGroup.LaunchTemplateConfigProperty]]]] = None,
        launch_template_version: typing.Optional[builtins.str] = None,
        max_spot_price: typing.Optional[jsii.Number] = None,
        pay_as_you_go_allocation_strategy: typing.Optional[builtins.str] = None,
        pay_as_you_go_target_capacity: typing.Optional[builtins.str] = None,
        spot_allocation_strategy: typing.Optional[builtins.str] = None,
        spot_instance_interruption_behavior: typing.Optional[builtins.str] = None,
        spot_instance_pools_to_use_count: typing.Optional[jsii.Number] = None,
        spot_target_capacity: typing.Optional[builtins.str] = None,
        terminate_instances: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        terminate_instances_with_expiration: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        valid_from: typing.Optional[builtins.str] = None,
        valid_until: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::AutoProvisioningGroup``.

        :param launch_template_id: 
        :param total_target_capacity: 
        :param auto_provisioning_group_name: 
        :param auto_provisioning_group_type: 
        :param default_target_capacity_type: 
        :param description: 
        :param excess_capacity_termination_policy: 
        :param launch_template_config: 
        :param launch_template_version: 
        :param max_spot_price: 
        :param pay_as_you_go_allocation_strategy: 
        :param pay_as_you_go_target_capacity: 
        :param spot_allocation_strategy: 
        :param spot_instance_interruption_behavior: 
        :param spot_instance_pools_to_use_count: 
        :param spot_target_capacity: 
        :param terminate_instances: 
        :param terminate_instances_with_expiration: 
        :param valid_from: 
        :param valid_until: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "launch_template_id": launch_template_id,
            "total_target_capacity": total_target_capacity,
        }
        if auto_provisioning_group_name is not None:
            self._values["auto_provisioning_group_name"] = auto_provisioning_group_name
        if auto_provisioning_group_type is not None:
            self._values["auto_provisioning_group_type"] = auto_provisioning_group_type
        if default_target_capacity_type is not None:
            self._values["default_target_capacity_type"] = default_target_capacity_type
        if description is not None:
            self._values["description"] = description
        if excess_capacity_termination_policy is not None:
            self._values["excess_capacity_termination_policy"] = excess_capacity_termination_policy
        if launch_template_config is not None:
            self._values["launch_template_config"] = launch_template_config
        if launch_template_version is not None:
            self._values["launch_template_version"] = launch_template_version
        if max_spot_price is not None:
            self._values["max_spot_price"] = max_spot_price
        if pay_as_you_go_allocation_strategy is not None:
            self._values["pay_as_you_go_allocation_strategy"] = pay_as_you_go_allocation_strategy
        if pay_as_you_go_target_capacity is not None:
            self._values["pay_as_you_go_target_capacity"] = pay_as_you_go_target_capacity
        if spot_allocation_strategy is not None:
            self._values["spot_allocation_strategy"] = spot_allocation_strategy
        if spot_instance_interruption_behavior is not None:
            self._values["spot_instance_interruption_behavior"] = spot_instance_interruption_behavior
        if spot_instance_pools_to_use_count is not None:
            self._values["spot_instance_pools_to_use_count"] = spot_instance_pools_to_use_count
        if spot_target_capacity is not None:
            self._values["spot_target_capacity"] = spot_target_capacity
        if terminate_instances is not None:
            self._values["terminate_instances"] = terminate_instances
        if terminate_instances_with_expiration is not None:
            self._values["terminate_instances_with_expiration"] = terminate_instances_with_expiration
        if valid_from is not None:
            self._values["valid_from"] = valid_from
        if valid_until is not None:
            self._values["valid_until"] = valid_until

    @builtins.property
    def launch_template_id(self) -> builtins.str:
        """
        :Property:

        launchTemplateId: The ID of the instance launch template associated with the auto provisioning group.
        You can call the DescribeLaunchTemplates operation to query available instance launch templates.
        An auto provisioning group can be associated with only one instance launch template.
        But you can configure multiple extended configurations for the launch template through
        the LaunchTemplateConfig parameter.
        """
        result = self._values.get("launch_template_id")
        assert result is not None, "Required property 'launch_template_id' is missing"
        return result

    @builtins.property
    def total_target_capacity(self) -> builtins.str:
        """
        :Property:

        totalTargetCapacity: The total target capacity of the auto provisioning group. The target capacity consists
        of the following three parts:
        The target capacity of pay-as-you-go instances specified by the PayAsYouGoTargetCapacity parameter
        The target capacity of preemptible instances specified by the SpotTargetCapacity parameter
        The supplemental capacity besides PayAsYouGoTargetCapacity and SpotTargetCapacity
        """
        result = self._values.get("total_target_capacity")
        assert result is not None, "Required property 'total_target_capacity' is missing"
        return result

    @builtins.property
    def auto_provisioning_group_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        autoProvisioningGroupName: The name of the auto provisioning group to be created. It must be 2 to 128 characters
        in length. It must start with a letter but cannot start with http:// or https://.
        It can contain letters, digits, colons (:), underscores (_), and hyphens (-).
        """
        result = self._values.get("auto_provisioning_group_name")
        return result

    @builtins.property
    def auto_provisioning_group_type(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        autoProvisioningGroupType: The type of the auto provisioning group. Valid values:
        request: One-time delivery. After the auto provisioning group is started, it only attempts
        to create an instance cluster once. If the cluster fails to be created, the group
        does not try again.
        maintain: The continuous delivery and maintain capacity type. After the auto provisioning group
        is started, it continuously attempts to create and maintain the instance cluster.
        The auto provisioning group compares the real-time and target capacity of the cluster.
        If the cluster does not meet the target capacity, the group will create instances
        until the cluster meets the target capacity.
        Default value: maintain
        """
        result = self._values.get("auto_provisioning_group_type")
        return result

    @builtins.property
    def default_target_capacity_type(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        defaultTargetCapacityType: The type of supplemental instances. When the total value of PayAsYouGoTargetCapacity and SpotTargetCapacity is smaller than the value of TotalTargetCapacity, the auto provisioning group will create instances of the specified type to meet
        the capacity requirements. Valid values:
        PayAsYouGo: Pay-as-you-go instances.
        Spot: Preemptible instances.
        Default value: Spot
        """
        result = self._values.get("default_target_capacity_type")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: The description of the auto provisioning group.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def excess_capacity_termination_policy(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        excessCapacityTerminationPolicy: The shutdown policy for excess preemptible instances followed when the capacity of
        the auto provisioning group exceeds the target capacity. Valid values:
        no-termination: Excess preemptible instances are not shut down.
        termination: Excess preemptible instances are to be shut down. The action to be performed on these
        shutdown instances is specified by the SpotInstanceInterruptionBehavior parameter.
        Default value: no-termination
        """
        result = self._values.get("excess_capacity_termination_policy")
        return result

    @builtins.property
    def launch_template_config(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosAutoProvisioningGroup.LaunchTemplateConfigProperty]]]]:
        """
        :Property: launchTemplateConfig:
        """
        result = self._values.get("launch_template_config")
        return result

    @builtins.property
    def launch_template_version(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        launchTemplateVersion: The version of the instance launch template associated with the auto provisioning
        group. You can call the DescribeLaunchTemplateVersions operation to query the versions of available instance launch templates.
        """
        result = self._values.get("launch_template_version")
        return result

    @builtins.property
    def max_spot_price(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        maxSpotPrice: The global maximum price for preemptible instances in the auto provisioning group.
        If both the MaxSpotPrice and LaunchTemplateConfig.N.MaxPrice parameters are specified, the maximum price is the lower value of the two.
        """
        result = self._values.get("max_spot_price")
        return result

    @builtins.property
    def pay_as_you_go_allocation_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        payAsYouGoAllocationStrategy: The scale-out policy for pay-as-you-go instances. Valid values:
        lowest-price: The cost optimization policy the auto provisioning group follows to select instance
        types of the lowest cost to create instances.
        prioritized: The priority-based policy the auto provisioning group follows to create instances.
        The priority of an instance type is specified by the LaunchTemplateConfig.N.Priority parameter.
        Default value: lowest-price
        """
        result = self._values.get("pay_as_you_go_allocation_strategy")
        return result

    @builtins.property
    def pay_as_you_go_target_capacity(self) -> typing.Optional[builtins.str]:
        """
        :Property: payAsYouGoTargetCapacity: The target capacity of pay-as-you-go instances in the auto provisioning group.
        """
        result = self._values.get("pay_as_you_go_target_capacity")
        return result

    @builtins.property
    def spot_allocation_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        spotAllocationStrategy: The scale-out policy for preemptible instances. Valid values:
        lowest-price: The cost optimization policy the auto provisioning group follows to select instance
        types of the lowest cost to create instances.
        diversified: The distribution balancing policy the auto provisioning group follows to evenly create
        instances across zones specified in multiple extended template configurations.
        Default value: lowest-price
        """
        result = self._values.get("spot_allocation_strategy")
        return result

    @builtins.property
    def spot_instance_interruption_behavior(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        spotInstanceInterruptionBehavior: The default behavior after preemptible instances are shut down. Value values:
        stop: stops preemptible instances.
        terminate: releases preemptible instances.
        Default value: stop
        """
        result = self._values.get("spot_instance_interruption_behavior")
        return result

    @builtins.property
    def spot_instance_pools_to_use_count(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        spotInstancePoolsToUseCount: This parameter takes effect when the SpotAllocationStrategy parameter is set to lowest-price. The auto provisioning group selects instance types of the lowest cost to create
        instances.
        """
        result = self._values.get("spot_instance_pools_to_use_count")
        return result

    @builtins.property
    def spot_target_capacity(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotTargetCapacity: The target capacity of preemptible instances in the auto provisioning group.
        """
        result = self._values.get("spot_target_capacity")
        return result

    @builtins.property
    def terminate_instances(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        terminateInstances: Specifies whether to release instances of the auto provisioning group. Valid values:
        true
        false
        Default: false
        """
        result = self._values.get("terminate_instances")
        return result

    @builtins.property
    def terminate_instances_with_expiration(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        terminateInstancesWithExpiration: The shutdown policy for preemptible instances when the auto provisioning group expires.
        Valid values:
        true: shuts down preemptible instances. The action to be performed on these shutdown instances
        is specified by the SpotInstanceInterruptionBehavior parameter.
        false: does not shut down preemptible instances.
        Default: false
        """
        result = self._values.get("terminate_instances_with_expiration")
        return result

    @builtins.property
    def valid_from(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        validFrom: The time when the auto provisioning group is started. The period of time between this
        point in time and the point in time specified by the ValidUntil parameter is the effective time period of the auto provisioning group.
        By default, an auto provisioning group is immediately started after creation.
        """
        result = self._values.get("valid_from")
        return result

    @builtins.property
    def valid_until(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        validUntil: The time when the auto provisioning group expires. The period of time between this
        point in time and the point in time specified by the ValidFrom parameter is the effective time period of the auto provisioning group.
        By default, an auto provisioning group never expires.
        """
        result = self._values.get("valid_until")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosAutoProvisioningGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosAutoSnapshotPolicy(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosAutoSnapshotPolicy",
):
    """A ROS template type:  ``ALIYUN::ECS::AutoSnapshotPolicy``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosAutoSnapshotPolicyProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::AutoSnapshotPolicy``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosAutoSnapshotPolicy, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrAutoSnapshotPolicyId")
    def attr_auto_snapshot_policy_id(self) -> typing.Any:
        """
        :Attribute: AutoSnapshotPolicyId: The automatic snapshot policy ID.
        """
        return jsii.get(self, "attrAutoSnapshotPolicyId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="repeatWeekdays")
    def repeat_weekdays(
        self,
    ) -> typing.Union[typing.List[jsii.Number], ros_cdk_core.IResolvable]:
        """
        :Property:

        repeatWeekdays: The automatic snapshot repetition dates. The unit of measurement is day and the repeating cycle is a week. Value range: [1, 7], which represents days starting from Monday to Sunday, for example 1 indicates Monday. When you want to schedule multiple automatic snapshot tasks for a disk in a week, you can set the RepeatWeekdays to an array.
        A maximum of seven time points can be selected.
        The format is a list of [1, 2, ..., 7] and the time points are separated by commas (,).
        """
        return jsii.get(self, "repeatWeekdays")

    @repeat_weekdays.setter # type: ignore
    def repeat_weekdays(
        self,
        value: typing.Union[typing.List[jsii.Number], ros_cdk_core.IResolvable],
    ) -> None:
        jsii.set(self, "repeatWeekdays", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="retentionDays")
    def retention_days(self) -> jsii.Number:
        """
        :Property:

        retentionDays: The snapshot retention time, and the unit of measurement is day. Optional values:
        -1: The automatic snapshots are retained permanently.
        [1, 65536]: The number of days retained.
        Default value: -1.
        """
        return jsii.get(self, "retentionDays")

    @retention_days.setter # type: ignore
    def retention_days(self, value: jsii.Number) -> None:
        jsii.set(self, "retentionDays", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="timePoints")
    def time_points(
        self,
    ) -> typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]:
        """
        :Property:

        timePoints: The automatic snapshot creation schedule, and the unit of measurement is hour. Value range: [0, 23], which represents from 00:00 to 24:00, for example 1 indicates 01:00. When you want to schedule multiple automatic snapshot tasks for a disk in a day, you can set the TimePoints to an array.
        A maximum of 24 time points can be selected.
        The format is a list of [0, 1, ..., 23] and the time points are separated by commas (,).
        """
        return jsii.get(self, "timePoints")

    @time_points.setter # type: ignore
    def time_points(
        self,
        value: typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable],
    ) -> None:
        jsii.set(self, "timePoints", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoSnapshotPolicyName")
    def auto_snapshot_policy_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        autoSnapshotPolicyName: The name of the automatic snapshot policy.
        It can consist of [2, 128] English or Chinese characters.
        Must begin with an uppercase or lowercase letter or a Chinese character. Can contain numbers, periods (.), colons (:), underscores (_), and hyphens (-).
        Cannot start with http:// or https://.
        Default value: null.
        """
        return jsii.get(self, "autoSnapshotPolicyName")

    @auto_snapshot_policy_name.setter # type: ignore
    def auto_snapshot_policy_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "autoSnapshotPolicyName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="diskIds")
    def disk_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        """
        :Property: diskIds: The disk ID. When you want to apply the automatic snapshot policy to multiple disks, you can set the DiskIds to an array. The format is list of ["d-xxxxxxxxx", "d-yyyyyyyyy", ..., "d-zzzzzzzzz"] and the IDs are separated by commas (,).
        """
        return jsii.get(self, "diskIds")

    @disk_ids.setter # type: ignore
    def disk_ids(self, value: typing.Optional[typing.List[builtins.str]]) -> None:
        jsii.set(self, "diskIds", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosAutoSnapshotPolicyProps",
    jsii_struct_bases=[],
    name_mapping={
        "repeat_weekdays": "repeatWeekdays",
        "retention_days": "retentionDays",
        "time_points": "timePoints",
        "auto_snapshot_policy_name": "autoSnapshotPolicyName",
        "disk_ids": "diskIds",
    },
)
class RosAutoSnapshotPolicyProps:
    def __init__(
        self,
        *,
        repeat_weekdays: typing.Union[typing.List[jsii.Number], ros_cdk_core.IResolvable],
        retention_days: jsii.Number,
        time_points: typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable],
        auto_snapshot_policy_name: typing.Optional[builtins.str] = None,
        disk_ids: typing.Optional[typing.List[builtins.str]] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::AutoSnapshotPolicy``.

        :param repeat_weekdays: 
        :param retention_days: 
        :param time_points: 
        :param auto_snapshot_policy_name: 
        :param disk_ids: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "repeat_weekdays": repeat_weekdays,
            "retention_days": retention_days,
            "time_points": time_points,
        }
        if auto_snapshot_policy_name is not None:
            self._values["auto_snapshot_policy_name"] = auto_snapshot_policy_name
        if disk_ids is not None:
            self._values["disk_ids"] = disk_ids

    @builtins.property
    def repeat_weekdays(
        self,
    ) -> typing.Union[typing.List[jsii.Number], ros_cdk_core.IResolvable]:
        """
        :Property:

        repeatWeekdays: The automatic snapshot repetition dates. The unit of measurement is day and the repeating cycle is a week. Value range: [1, 7], which represents days starting from Monday to Sunday, for example 1 indicates Monday. When you want to schedule multiple automatic snapshot tasks for a disk in a week, you can set the RepeatWeekdays to an array.
        A maximum of seven time points can be selected.
        The format is a list of [1, 2, ..., 7] and the time points are separated by commas (,).
        """
        result = self._values.get("repeat_weekdays")
        assert result is not None, "Required property 'repeat_weekdays' is missing"
        return result

    @builtins.property
    def retention_days(self) -> jsii.Number:
        """
        :Property:

        retentionDays: The snapshot retention time, and the unit of measurement is day. Optional values:
        -1: The automatic snapshots are retained permanently.
        [1, 65536]: The number of days retained.
        Default value: -1.
        """
        result = self._values.get("retention_days")
        assert result is not None, "Required property 'retention_days' is missing"
        return result

    @builtins.property
    def time_points(
        self,
    ) -> typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]:
        """
        :Property:

        timePoints: The automatic snapshot creation schedule, and the unit of measurement is hour. Value range: [0, 23], which represents from 00:00 to 24:00, for example 1 indicates 01:00. When you want to schedule multiple automatic snapshot tasks for a disk in a day, you can set the TimePoints to an array.
        A maximum of 24 time points can be selected.
        The format is a list of [0, 1, ..., 23] and the time points are separated by commas (,).
        """
        result = self._values.get("time_points")
        assert result is not None, "Required property 'time_points' is missing"
        return result

    @builtins.property
    def auto_snapshot_policy_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        autoSnapshotPolicyName: The name of the automatic snapshot policy.
        It can consist of [2, 128] English or Chinese characters.
        Must begin with an uppercase or lowercase letter or a Chinese character. Can contain numbers, periods (.), colons (:), underscores (_), and hyphens (-).
        Cannot start with http:// or https://.
        Default value: null.
        """
        result = self._values.get("auto_snapshot_policy_name")
        return result

    @builtins.property
    def disk_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        """
        :Property: diskIds: The disk ID. When you want to apply the automatic snapshot policy to multiple disks, you can set the DiskIds to an array. The format is list of ["d-xxxxxxxxx", "d-yyyyyyyyy", ..., "d-zzzzzzzzz"] and the IDs are separated by commas (,).
        """
        result = self._values.get("disk_ids")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosAutoSnapshotPolicyProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosBandwidthPackage(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosBandwidthPackage",
):
    """A ROS template type:  ``ALIYUN::ECS::BandwidthPackage``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosBandwidthPackageProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::BandwidthPackage``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosBandwidthPackage, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrBandwidthPackageId")
    def attr_bandwidth_package_id(self) -> typing.Any:
        """
        :Attribute: BandwidthPackageId: The bandwidth package id of created Bandwidth package.
        """
        return jsii.get(self, "attrBandwidthPackageId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrBandwidthPackageIps")
    def attr_bandwidth_package_ips(self) -> typing.Any:
        """
        :Attribute: BandwidthPackageIps: The allocated public IPs.
        """
        return jsii.get(self, "attrBandwidthPackageIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="bandwidth")
    def bandwidth(self) -> jsii.Number:
        """
        :Property: bandwidth: Bandwidth, [5-5000]M for PayByBandwidth, [5-50]M for PayByTraffic.
        """
        return jsii.get(self, "bandwidth")

    @bandwidth.setter # type: ignore
    def bandwidth(self, value: jsii.Number) -> None:
        jsii.set(self, "bandwidth", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ipCount")
    def ip_count(self) -> jsii.Number:
        """
        :Property: ipCount: Total internet IPs of this Bandwidth package, [1-5]
        """
        return jsii.get(self, "ipCount")

    @ip_count.setter # type: ignore
    def ip_count(self, value: jsii.Number) -> None:
        jsii.set(self, "ipCount", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="natGatewayId")
    def nat_gateway_id(self) -> builtins.str:
        """
        :Property: natGatewayId: Create bandwidth package for specified NAT gateway
        """
        return jsii.get(self, "natGatewayId")

    @nat_gateway_id.setter # type: ignore
    def nat_gateway_id(self, value: builtins.str) -> None:
        jsii.set(self, "natGatewayId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="bandwidthPackageName")
    def bandwidth_package_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: bandwidthPackageName: Display name of the bandwidth package, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        return jsii.get(self, "bandwidthPackageName")

    @bandwidth_package_name.setter # type: ignore
    def bandwidth_package_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "bandwidthPackageName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the bandwidth package, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetChargeType")
    def internet_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: internetChargeType: Nat Gateway internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByTraffic
        """
        return jsii.get(self, "internetChargeType")

    @internet_charge_type.setter # type: ignore
    def internet_charge_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "internetChargeType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="zoneId")
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: zoneId: The availability zone where the bandwidth package will be created.
        """
        return jsii.get(self, "zoneId")

    @zone_id.setter # type: ignore
    def zone_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "zoneId", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosBandwidthPackageProps",
    jsii_struct_bases=[],
    name_mapping={
        "bandwidth": "bandwidth",
        "ip_count": "ipCount",
        "nat_gateway_id": "natGatewayId",
        "bandwidth_package_name": "bandwidthPackageName",
        "description": "description",
        "internet_charge_type": "internetChargeType",
        "zone_id": "zoneId",
    },
)
class RosBandwidthPackageProps:
    def __init__(
        self,
        *,
        bandwidth: jsii.Number,
        ip_count: jsii.Number,
        nat_gateway_id: builtins.str,
        bandwidth_package_name: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        internet_charge_type: typing.Optional[builtins.str] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::BandwidthPackage``.

        :param bandwidth: 
        :param ip_count: 
        :param nat_gateway_id: 
        :param bandwidth_package_name: 
        :param description: 
        :param internet_charge_type: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "bandwidth": bandwidth,
            "ip_count": ip_count,
            "nat_gateway_id": nat_gateway_id,
        }
        if bandwidth_package_name is not None:
            self._values["bandwidth_package_name"] = bandwidth_package_name
        if description is not None:
            self._values["description"] = description
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def bandwidth(self) -> jsii.Number:
        """
        :Property: bandwidth: Bandwidth, [5-5000]M for PayByBandwidth, [5-50]M for PayByTraffic.
        """
        result = self._values.get("bandwidth")
        assert result is not None, "Required property 'bandwidth' is missing"
        return result

    @builtins.property
    def ip_count(self) -> jsii.Number:
        """
        :Property: ipCount: Total internet IPs of this Bandwidth package, [1-5]
        """
        result = self._values.get("ip_count")
        assert result is not None, "Required property 'ip_count' is missing"
        return result

    @builtins.property
    def nat_gateway_id(self) -> builtins.str:
        """
        :Property: natGatewayId: Create bandwidth package for specified NAT gateway
        """
        result = self._values.get("nat_gateway_id")
        assert result is not None, "Required property 'nat_gateway_id' is missing"
        return result

    @builtins.property
    def bandwidth_package_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: bandwidthPackageName: Display name of the bandwidth package, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("bandwidth_package_name")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the bandwidth package, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def internet_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: internetChargeType: Nat Gateway internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByTraffic
        """
        result = self._values.get("internet_charge_type")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: zoneId: The availability zone where the bandwidth package will be created.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosBandwidthPackageProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosCommand(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosCommand",
):
    """A ROS template type:  ``ALIYUN::ECS::Command``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosCommandProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::Command``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosCommand, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrCommandId")
    def attr_command_id(self) -> typing.Any:
        """
        :Attribute: CommandId: The id of command created.
        """
        return jsii.get(self, "attrCommandId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        """
        :Property: type: The type of command.
        """
        return jsii.get(self, "type")

    @type.setter # type: ignore
    def type(self, value: builtins.str) -> None:
        jsii.set(self, "type", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="commandContent")
    def command_content(self) -> typing.Optional[builtins.str]:
        """
        :Property: commandContent: The content of command. Content requires base64 encoding. Maximum size support 16KB.
        """
        return jsii.get(self, "commandContent")

    @command_content.setter # type: ignore
    def command_content(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "commandContent", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: The description of command.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableParameter")
    def enable_parameter(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        enableParameter: Specifies whether the script contains custom parameters.
        Default value: false
        """
        return jsii.get(self, "enableParameter")

    @enable_parameter.setter # type: ignore
    def enable_parameter(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "enableParameter", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="name")
    def name(self) -> typing.Optional[builtins.str]:
        """
        :Property: name: The name of command.
        """
        return jsii.get(self, "name")

    @name.setter # type: ignore
    def name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "name", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="timeout")
    def timeout(self) -> typing.Optional[jsii.Number]:
        """
        :Property: timeout: Total timeout when the command is executed in the instance. Input the time unit as second. Default is 60s.
        """
        return jsii.get(self, "timeout")

    @timeout.setter # type: ignore
    def timeout(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "timeout", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="workingDir")
    def working_dir(self) -> typing.Optional[builtins.str]:
        """
        :Property: workingDir: The path where command will be executed in the instance.
        """
        return jsii.get(self, "workingDir")

    @working_dir.setter # type: ignore
    def working_dir(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "workingDir", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosCommandProps",
    jsii_struct_bases=[],
    name_mapping={
        "type": "type",
        "command_content": "commandContent",
        "description": "description",
        "enable_parameter": "enableParameter",
        "name": "name",
        "timeout": "timeout",
        "working_dir": "workingDir",
    },
)
class RosCommandProps:
    def __init__(
        self,
        *,
        type: builtins.str,
        command_content: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        enable_parameter: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        name: typing.Optional[builtins.str] = None,
        timeout: typing.Optional[jsii.Number] = None,
        working_dir: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::Command``.

        :param type: 
        :param command_content: 
        :param description: 
        :param enable_parameter: 
        :param name: 
        :param timeout: 
        :param working_dir: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if command_content is not None:
            self._values["command_content"] = command_content
        if description is not None:
            self._values["description"] = description
        if enable_parameter is not None:
            self._values["enable_parameter"] = enable_parameter
        if name is not None:
            self._values["name"] = name
        if timeout is not None:
            self._values["timeout"] = timeout
        if working_dir is not None:
            self._values["working_dir"] = working_dir

    @builtins.property
    def type(self) -> builtins.str:
        """
        :Property: type: The type of command.
        """
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return result

    @builtins.property
    def command_content(self) -> typing.Optional[builtins.str]:
        """
        :Property: commandContent: The content of command. Content requires base64 encoding. Maximum size support 16KB.
        """
        result = self._values.get("command_content")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: The description of command.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def enable_parameter(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        enableParameter: Specifies whether the script contains custom parameters.
        Default value: false
        """
        result = self._values.get("enable_parameter")
        return result

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """
        :Property: name: The name of command.
        """
        result = self._values.get("name")
        return result

    @builtins.property
    def timeout(self) -> typing.Optional[jsii.Number]:
        """
        :Property: timeout: Total timeout when the command is executed in the instance. Input the time unit as second. Default is 60s.
        """
        result = self._values.get("timeout")
        return result

    @builtins.property
    def working_dir(self) -> typing.Optional[builtins.str]:
        """
        :Property: workingDir: The path where command will be executed in the instance.
        """
        result = self._values.get("working_dir")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosCommandProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosCopyImage(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosCopyImage",
):
    """A ROS template type:  ``ALIYUN::ECS::CopyImage``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosCopyImageProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::CopyImage``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosCopyImage, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrImageId")
    def attr_image_id(self) -> typing.Any:
        """
        :Attribute: ImageId: ID of the source custom image.
        """
        return jsii.get(self, "attrImageId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="destinationRegionId")
    def destination_region_id(self) -> builtins.str:
        """
        :Property: destinationRegionId: ID of the region to where the destination custom image belongs.
        """
        return jsii.get(self, "destinationRegionId")

    @destination_region_id.setter # type: ignore
    def destination_region_id(self, value: builtins.str) -> None:
        jsii.set(self, "destinationRegionId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="imageId")
    def image_id(self) -> builtins.str:
        """
        :Property: imageId: ID of the source custom image.
        """
        return jsii.get(self, "imageId")

    @image_id.setter # type: ignore
    def image_id(self, value: builtins.str) -> None:
        jsii.set(self, "imageId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="destinationDescription")
    def destination_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: destinationDescription: The description of the destination custom image.It cannot begin with http:// or https://.  Default value: null.
        """
        return jsii.get(self, "destinationDescription")

    @destination_description.setter # type: ignore
    def destination_description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "destinationDescription", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="destinationImageName")
    def destination_image_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: destinationImageName: Name of the destination custom image.The name is a string of 2 to 128 characters. It must begin with an English or a Chinese character. It can contain A-Z, a-z, Chinese characters, numbers, periods (.), colons (:), underscores (_), and hyphens (-).  Default value: null.
        """
        return jsii.get(self, "destinationImageName")

    @destination_image_name.setter # type: ignore
    def destination_image_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "destinationImageName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="encrypted")
    def encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: encrypted: Whether to encrypt the image.
        """
        return jsii.get(self, "encrypted")

    @encrypted.setter # type: ignore
    def encrypted(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "encrypted", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="kmsKeyId")
    def kms_key_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: kmsKeyId: The ID of the key used to encrypt the image.
        """
        return jsii.get(self, "kmsKeyId")

    @kms_key_id.setter # type: ignore
    def kms_key_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "kmsKeyId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="tag")
    def tag(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, ros_cdk_core.RosTag]]]]:
        """
        :Property: tag:
        """
        return jsii.get(self, "tag")

    @tag.setter # type: ignore
    def tag(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, ros_cdk_core.RosTag]]]],
    ) -> None:
        jsii.set(self, "tag", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosCopyImage.TagProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagProperty:
        def __init__(
            self,
            *,
            key: typing.Optional[builtins.str] = None,
            value: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param key: 
            :param value: 
            """
            self._values: typing.Dict[str, typing.Any] = {}
            if key is not None:
                self._values["key"] = key
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Optional[builtins.str]:
            """
            :Property: key: Custom image tag key.
            """
            result = self._values.get("key")
            return result

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            """
            :Property: value: Customize the label value of the image.
            """
            result = self._values.get("value")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosCopyImageProps",
    jsii_struct_bases=[],
    name_mapping={
        "destination_region_id": "destinationRegionId",
        "image_id": "imageId",
        "destination_description": "destinationDescription",
        "destination_image_name": "destinationImageName",
        "encrypted": "encrypted",
        "kms_key_id": "kmsKeyId",
        "tag": "tag",
    },
)
class RosCopyImageProps:
    def __init__(
        self,
        *,
        destination_region_id: builtins.str,
        image_id: builtins.str,
        destination_description: typing.Optional[builtins.str] = None,
        destination_image_name: typing.Optional[builtins.str] = None,
        encrypted: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        kms_key_id: typing.Optional[builtins.str] = None,
        tag: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, ros_cdk_core.RosTag]]]] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::CopyImage``.

        :param destination_region_id: 
        :param image_id: 
        :param destination_description: 
        :param destination_image_name: 
        :param encrypted: 
        :param kms_key_id: 
        :param tag: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "destination_region_id": destination_region_id,
            "image_id": image_id,
        }
        if destination_description is not None:
            self._values["destination_description"] = destination_description
        if destination_image_name is not None:
            self._values["destination_image_name"] = destination_image_name
        if encrypted is not None:
            self._values["encrypted"] = encrypted
        if kms_key_id is not None:
            self._values["kms_key_id"] = kms_key_id
        if tag is not None:
            self._values["tag"] = tag

    @builtins.property
    def destination_region_id(self) -> builtins.str:
        """
        :Property: destinationRegionId: ID of the region to where the destination custom image belongs.
        """
        result = self._values.get("destination_region_id")
        assert result is not None, "Required property 'destination_region_id' is missing"
        return result

    @builtins.property
    def image_id(self) -> builtins.str:
        """
        :Property: imageId: ID of the source custom image.
        """
        result = self._values.get("image_id")
        assert result is not None, "Required property 'image_id' is missing"
        return result

    @builtins.property
    def destination_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: destinationDescription: The description of the destination custom image.It cannot begin with http:// or https://.  Default value: null.
        """
        result = self._values.get("destination_description")
        return result

    @builtins.property
    def destination_image_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: destinationImageName: Name of the destination custom image.The name is a string of 2 to 128 characters. It must begin with an English or a Chinese character. It can contain A-Z, a-z, Chinese characters, numbers, periods (.), colons (:), underscores (_), and hyphens (-).  Default value: null.
        """
        result = self._values.get("destination_image_name")
        return result

    @builtins.property
    def encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: encrypted: Whether to encrypt the image.
        """
        result = self._values.get("encrypted")
        return result

    @builtins.property
    def kms_key_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: kmsKeyId: The ID of the key used to encrypt the image.
        """
        result = self._values.get("kms_key_id")
        return result

    @builtins.property
    def tag(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, ros_cdk_core.RosTag]]]]:
        """
        :Property: tag:
        """
        result = self._values.get("tag")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosCopyImageProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosCustomImage(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosCustomImage",
):
    """A ROS template type:  ``ALIYUN::ECS::CustomImage``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosCustomImageProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::CustomImage``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosCustomImage, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrImageId")
    def attr_image_id(self) -> typing.Any:
        """
        :Attribute: ImageId: Image ID
        """
        return jsii.get(self, "attrImageId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="architecture")
    def architecture(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        architecture: After specifying the data disk snapshot as the mirrored system disk, you need to determine the system architecture of the system disk through Architecture. Ranges:
        I386
        X86_64 (default)
        """
        return jsii.get(self, "architecture")

    @architecture.setter # type: ignore
    def architecture(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "architecture", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        description: The description of the image.
        It can be [0, 256] letters in length.
        It cannot begin with http:// or https://.
        Default value: null.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="diskDeviceMapping")
    def disk_device_mapping(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosCustomImage.DiskDeviceMappingProperty"]]]]:
        """
        :Property: diskDeviceMapping:
        """
        return jsii.get(self, "diskDeviceMapping")

    @disk_device_mapping.setter # type: ignore
    def disk_device_mapping(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosCustomImage.DiskDeviceMappingProperty"]]]],
    ) -> None:
        jsii.set(self, "diskDeviceMapping", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="imageName")
    def image_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        imageName: Image name.
        Can contain [2, 128] characters in length. Must begin with an English letter or Chinese character. Can contain digits, colons (:), underscores (_), or hyphens (-).
        Cannot begin with http:// or https://.
        """
        return jsii.get(self, "imageName")

    @image_name.setter # type: ignore
    def image_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "imageName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceId")
    def instance_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceId: Instance ID.
        """
        return jsii.get(self, "instanceId")

    @instance_id.setter # type: ignore
    def instance_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="platform")
    def platform(self) -> typing.Optional[builtins.str]:
        """
        :Property: platform: After specifying the data disk snapshot as the mirrored system disk, you need to determine the operating system release of the system disk through Platform.
        """
        return jsii.get(self, "platform")

    @platform.setter # type: ignore
    def platform(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "platform", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: The enterprise resource group ID where the custom image is located.
        """
        return jsii.get(self, "resourceGroupId")

    @resource_group_id.setter # type: ignore
    def resource_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "resourceGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="snapshotId")
    def snapshot_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: snapshotId: The snapshot ID. A custom image is created from the specified snapshot.
        """
        return jsii.get(self, "snapshotId")

    @snapshot_id.setter # type: ignore
    def snapshot_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "snapshotId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="tag")
    def tag(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, ros_cdk_core.RosTag]]]]:
        """
        :Property: tag:
        """
        return jsii.get(self, "tag")

    @tag.setter # type: ignore
    def tag(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, ros_cdk_core.RosTag]]]],
    ) -> None:
        jsii.set(self, "tag", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosCustomImage.DiskDeviceMappingProperty",
        jsii_struct_bases=[],
        name_mapping={
            "device": "device",
            "disk_type": "diskType",
            "size": "size",
            "snapshot_id": "snapshotId",
        },
    )
    class DiskDeviceMappingProperty:
        def __init__(
            self,
            *,
            device: typing.Optional[builtins.str] = None,
            disk_type: typing.Optional[builtins.str] = None,
            size: typing.Optional[jsii.Number] = None,
            snapshot_id: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param device: 
            :param disk_type: 
            :param size: 
            :param snapshot_id: 
            """
            self._values: typing.Dict[str, typing.Any] = {}
            if device is not None:
                self._values["device"] = device
            if disk_type is not None:
                self._values["disk_type"] = disk_type
            if size is not None:
                self._values["size"] = size
            if snapshot_id is not None:
                self._values["snapshot_id"] = snapshot_id

        @builtins.property
        def device(self) -> typing.Optional[builtins.str]:
            """
            :Property: device: Specify the device name in DiskMirrorMapping.N. in the custom image. Value range: /dev/xvda~/dev/xvdz
            """
            result = self._values.get("device")
            return result

        @builtins.property
        def disk_type(self) -> typing.Optional[builtins.str]:
            """
            :Property:

            diskType: Specifies the disk type of DiskDeviceMapping.N. in the new image. You can use the data disk snapshot as the mirrored system disk. If not specified, the default is the disk type corresponding to the snapshot. Ranges:
            System: system disk
            Data: data disk
            """
            result = self._values.get("disk_type")
            return result

        @builtins.property
        def size(self) -> typing.Optional[jsii.Number]:
            """
            :Property:

            size: The size of a disk. The unit of measurement is GiB. Value range: [5, 2000] GiB.
            The default value is the value of snapshot size (DiskDeviceMapping.N.SnapshotId) if you do not specify this parameter.
            If you do not specify the snapshot ID (DiskDeviceMapping.N.SnapshotId), the default size is 5 GiB.
            The size value cannot be less than the size of the snapshot (DiskDeviceMapping.N.SnapshotId).
            The value range of n in DiskDeviceMapping.n is: [1, 17].
            n =1: Indicates the specified disk is a system disk.
            n =2, 3, ...17: Indicates the specified disk is a data disk.
            """
            result = self._values.get("size")
            return result

        @builtins.property
        def snapshot_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: snapshotId: The snapshot ID of the disk DiskDeviceMapping.N..
            """
            result = self._values.get("snapshot_id")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DiskDeviceMappingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosCustomImage.TagProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagProperty:
        def __init__(
            self,
            *,
            key: typing.Optional[builtins.str] = None,
            value: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param key: 
            :param value: 
            """
            self._values: typing.Dict[str, typing.Any] = {}
            if key is not None:
                self._values["key"] = key
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Optional[builtins.str]:
            """
            :Property: key: The key of a tag of which n is from 1 to 20. Once you use this parameter, it cannot be a null string. It can be up to 64 characters in length. It cannot begin with "aliyun", "acs:", "http://", or "https://".
            """
            result = self._values.get("key")
            return result

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            """
            :Property: value: The value of a tag of which n is a number from 1 to 20. Once you use this parameter, it can be a null string. It can be up to 128 characters in length. It cannot begin with "aliyun", "acs:", "http://", or "https://".
            """
            result = self._values.get("value")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosCustomImageProps",
    jsii_struct_bases=[],
    name_mapping={
        "architecture": "architecture",
        "description": "description",
        "disk_device_mapping": "diskDeviceMapping",
        "image_name": "imageName",
        "instance_id": "instanceId",
        "platform": "platform",
        "resource_group_id": "resourceGroupId",
        "snapshot_id": "snapshotId",
        "tag": "tag",
    },
)
class RosCustomImageProps:
    def __init__(
        self,
        *,
        architecture: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        disk_device_mapping: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosCustomImage.DiskDeviceMappingProperty]]]] = None,
        image_name: typing.Optional[builtins.str] = None,
        instance_id: typing.Optional[builtins.str] = None,
        platform: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        snapshot_id: typing.Optional[builtins.str] = None,
        tag: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, ros_cdk_core.RosTag]]]] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::CustomImage``.

        :param architecture: 
        :param description: 
        :param disk_device_mapping: 
        :param image_name: 
        :param instance_id: 
        :param platform: 
        :param resource_group_id: 
        :param snapshot_id: 
        :param tag: 
        """
        self._values: typing.Dict[str, typing.Any] = {}
        if architecture is not None:
            self._values["architecture"] = architecture
        if description is not None:
            self._values["description"] = description
        if disk_device_mapping is not None:
            self._values["disk_device_mapping"] = disk_device_mapping
        if image_name is not None:
            self._values["image_name"] = image_name
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if platform is not None:
            self._values["platform"] = platform
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if snapshot_id is not None:
            self._values["snapshot_id"] = snapshot_id
        if tag is not None:
            self._values["tag"] = tag

    @builtins.property
    def architecture(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        architecture: After specifying the data disk snapshot as the mirrored system disk, you need to determine the system architecture of the system disk through Architecture. Ranges:
        I386
        X86_64 (default)
        """
        result = self._values.get("architecture")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        description: The description of the image.
        It can be [0, 256] letters in length.
        It cannot begin with http:// or https://.
        Default value: null.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_device_mapping(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosCustomImage.DiskDeviceMappingProperty]]]]:
        """
        :Property: diskDeviceMapping:
        """
        result = self._values.get("disk_device_mapping")
        return result

    @builtins.property
    def image_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        imageName: Image name.
        Can contain [2, 128] characters in length. Must begin with an English letter or Chinese character. Can contain digits, colons (:), underscores (_), or hyphens (-).
        Cannot begin with http:// or https://.
        """
        result = self._values.get("image_name")
        return result

    @builtins.property
    def instance_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceId: Instance ID.
        """
        result = self._values.get("instance_id")
        return result

    @builtins.property
    def platform(self) -> typing.Optional[builtins.str]:
        """
        :Property: platform: After specifying the data disk snapshot as the mirrored system disk, you need to determine the operating system release of the system disk through Platform.
        """
        result = self._values.get("platform")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: The enterprise resource group ID where the custom image is located.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def snapshot_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: snapshotId: The snapshot ID. A custom image is created from the specified snapshot.
        """
        result = self._values.get("snapshot_id")
        return result

    @builtins.property
    def tag(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, ros_cdk_core.RosTag]]]]:
        """
        :Property: tag:
        """
        result = self._values.get("tag")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosCustomImageProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosDedicatedHost(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosDedicatedHost",
):
    """A ROS template type:  ``ALIYUN::ECS::DedicatedHost``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosDedicatedHostProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::DedicatedHost``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosDedicatedHost, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrDedicatedHostIds")
    def attr_dedicated_host_ids(self) -> typing.Any:
        """
        :Attribute: DedicatedHostIds: The host id list of created hosts
        """
        return jsii.get(self, "attrDedicatedHostIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> typing.Any:
        """
        :Attribute: OrderId: The order id list of created instance.
        """
        return jsii.get(self, "attrOrderId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="tags")
    def tags(self) -> ros_cdk_core.TagManager:
        """
        :Property: tags: Tags to attach to DedicatedHost. Max support 20 tags to add during create DedicatedHost. Each tag with two properties Key and Value, and Key is required.
        """
        return jsii.get(self, "tags")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="dedicatedHostType")
    def dedicated_host_type(self) -> builtins.str:
        """
        :Property: dedicatedHostType: The instance type of host.
        """
        return jsii.get(self, "dedicatedHostType")

    @dedicated_host_type.setter # type: ignore
    def dedicated_host_type(self, value: builtins.str) -> None:
        jsii.set(self, "dedicatedHostType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="actionOnMaintenance")
    def action_on_maintenance(self) -> typing.Optional[builtins.str]:
        """
        :Property: actionOnMaintenance: The policy used to migrate the instances from the dedicated hostwhen the dedicated host fails or needs to be repaired online.Valid values: Migrate: Instances are migrated to another physical server and restarted.If the dedicated host is attached with disks that are not local disks, the default value is Migrate.Stop: Instances on the dedicated host are stopped. If the dedicated host cannot be repaired,the instances are migrated to another physical server and restarted.If the dedicated host is attached with local disks, the default value is Stop.
        """
        return jsii.get(self, "actionOnMaintenance")

    @action_on_maintenance.setter # type: ignore
    def action_on_maintenance(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "actionOnMaintenance", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoPlacement")
    def auto_placement(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoPlacement: Specifies whether the dedicated host is added to the resource pool for automatic deployment. If you do not specify the DedicatedHostId parameter when you create an instance on a dedicated host, Alibaba Cloud automatically selects a dedicated host from the resource pool to host the instance. For more information, see Automatic deployment. Valid values:on: The dedicated host is added to the resource pool for automatic deployment.off: The dedicated host is not added to the resource pool for automatic deployment.Default value: on.Note When you create a dedicated host: If you do not specify this parameter, the dedicated host is added to the automatic deployment resource pool.If you do not want to add the dedicated host to the automatic deployment resource pool, set the value to off.
        """
        return jsii.get(self, "autoPlacement")

    @auto_placement.setter # type: ignore
    def auto_placement(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "autoPlacement", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoReleaseTime")
    def auto_release_time(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoReleaseTime: Auto release time for created host, Follow ISO8601 standard using UTC time. format is 'yyyy-MM-ddTHH:mm:ssZ'. Not bigger than 3 years from this day onwards
        """
        return jsii.get(self, "autoReleaseTime")

    @auto_release_time.setter # type: ignore
    def auto_release_time(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "autoReleaseTime", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoRenew")
    def auto_renew(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoRenew: Whether renew the fee automatically? When the parameter InstanceChargeType is PrePaid, it will take effect. Range of value:True: automatic renewal.False: no automatic renewal. Default value is False.
        """
        return jsii.get(self, "autoRenew")

    @auto_renew.setter # type: ignore
    def auto_renew(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "autoRenew", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoRenewPeriod")
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.
        """
        return jsii.get(self, "autoRenewPeriod")

    @auto_renew_period.setter # type: ignore
    def auto_renew_period(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "autoRenewPeriod", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="chargeType")
    def charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: chargeType: Instance Charge type, allowed value: Prepaid and Postpaid. If specified Prepaid, please ensure you have sufficient balance in your account. Or instance creation will be failure. Default value is Postpaid.
        """
        return jsii.get(self, "chargeType")

    @charge_type.setter # type: ignore
    def charge_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "chargeType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="dedicatedHostName")
    def dedicated_host_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: dedicatedHostName: The name of the dedicated host, [2, 128] English or Chinese characters. It must begin with an uppercase/lowercase letter or a Chinese character, and may contain numbers, '_' or '-'. It cannot begin with http:// or https://.
        """
        return jsii.get(self, "dedicatedHostName")

    @dedicated_host_name.setter # type: ignore
    def dedicated_host_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "dedicatedHostName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: The description of host.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="networkAttributesSlbUdpTimeout")
    def network_attributes_slb_udp_timeout(self) -> typing.Optional[jsii.Number]:
        """
        :Property: networkAttributesSlbUdpTimeout: The duration of UDP timeout for sessions between Server Load Balancer (SLB) and the dedicated host. Unit: seconds. Valid values: 15 to 310.
        """
        return jsii.get(self, "networkAttributesSlbUdpTimeout")

    @network_attributes_slb_udp_timeout.setter # type: ignore
    def network_attributes_slb_udp_timeout(
        self,
        value: typing.Optional[jsii.Number],
    ) -> None:
        jsii.set(self, "networkAttributesSlbUdpTimeout", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="networkAttributesUdpTimeout")
    def network_attributes_udp_timeout(self) -> typing.Optional[jsii.Number]:
        """
        :Property: networkAttributesUdpTimeout: The duration of UDP timeout for sessions between users and instances on the dedicated host. Unit: seconds. Valid values: 15 to 310.
        """
        return jsii.get(self, "networkAttributesUdpTimeout")

    @network_attributes_udp_timeout.setter # type: ignore
    def network_attributes_udp_timeout(
        self,
        value: typing.Optional[jsii.Number],
    ) -> None:
        jsii.set(self, "networkAttributesUdpTimeout", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="period")
    def period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: period: Prepaid time period. Unit is month, it could be from 1 to 9 or 12, 24, 36, 48, 60. Default value is 1.
        """
        return jsii.get(self, "period")

    @period.setter # type: ignore
    def period(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "period", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="periodUnit")
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month/Year. Default value is Month.
        """
        return jsii.get(self, "periodUnit")

    @period_unit.setter # type: ignore
    def period_unit(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "periodUnit", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="quantity")
    def quantity(self) -> typing.Optional[jsii.Number]:
        """
        :Property: quantity: The number of dedicated hosts that you want to create. Valid values: 1 to 100.Default value: 1.
        """
        return jsii.get(self, "quantity")

    @quantity.setter # type: ignore
    def quantity(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "quantity", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: The ID of the resource group. If this is left blank, the system automatically fills in the ID of the default resource group.
        """
        return jsii.get(self, "resourceGroupId")

    @resource_group_id.setter # type: ignore
    def resource_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "resourceGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="zoneId")
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: zoneId: The zone to create the host.
        """
        return jsii.get(self, "zoneId")

    @zone_id.setter # type: ignore
    def zone_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "zoneId", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosDedicatedHostProps",
    jsii_struct_bases=[],
    name_mapping={
        "dedicated_host_type": "dedicatedHostType",
        "action_on_maintenance": "actionOnMaintenance",
        "auto_placement": "autoPlacement",
        "auto_release_time": "autoReleaseTime",
        "auto_renew": "autoRenew",
        "auto_renew_period": "autoRenewPeriod",
        "charge_type": "chargeType",
        "dedicated_host_name": "dedicatedHostName",
        "description": "description",
        "network_attributes_slb_udp_timeout": "networkAttributesSlbUdpTimeout",
        "network_attributes_udp_timeout": "networkAttributesUdpTimeout",
        "period": "period",
        "period_unit": "periodUnit",
        "quantity": "quantity",
        "resource_group_id": "resourceGroupId",
        "tags": "tags",
        "zone_id": "zoneId",
    },
)
class RosDedicatedHostProps:
    def __init__(
        self,
        *,
        dedicated_host_type: builtins.str,
        action_on_maintenance: typing.Optional[builtins.str] = None,
        auto_placement: typing.Optional[builtins.str] = None,
        auto_release_time: typing.Optional[builtins.str] = None,
        auto_renew: typing.Optional[builtins.str] = None,
        auto_renew_period: typing.Optional[jsii.Number] = None,
        charge_type: typing.Optional[builtins.str] = None,
        dedicated_host_name: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        network_attributes_slb_udp_timeout: typing.Optional[jsii.Number] = None,
        network_attributes_udp_timeout: typing.Optional[jsii.Number] = None,
        period: typing.Optional[jsii.Number] = None,
        period_unit: typing.Optional[builtins.str] = None,
        quantity: typing.Optional[jsii.Number] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.List[ros_cdk_core.RosTag]] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::DedicatedHost``.

        :param dedicated_host_type: 
        :param action_on_maintenance: 
        :param auto_placement: 
        :param auto_release_time: 
        :param auto_renew: 
        :param auto_renew_period: 
        :param charge_type: 
        :param dedicated_host_name: 
        :param description: 
        :param network_attributes_slb_udp_timeout: 
        :param network_attributes_udp_timeout: 
        :param period: 
        :param period_unit: 
        :param quantity: 
        :param resource_group_id: 
        :param tags: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "dedicated_host_type": dedicated_host_type,
        }
        if action_on_maintenance is not None:
            self._values["action_on_maintenance"] = action_on_maintenance
        if auto_placement is not None:
            self._values["auto_placement"] = auto_placement
        if auto_release_time is not None:
            self._values["auto_release_time"] = auto_release_time
        if auto_renew is not None:
            self._values["auto_renew"] = auto_renew
        if auto_renew_period is not None:
            self._values["auto_renew_period"] = auto_renew_period
        if charge_type is not None:
            self._values["charge_type"] = charge_type
        if dedicated_host_name is not None:
            self._values["dedicated_host_name"] = dedicated_host_name
        if description is not None:
            self._values["description"] = description
        if network_attributes_slb_udp_timeout is not None:
            self._values["network_attributes_slb_udp_timeout"] = network_attributes_slb_udp_timeout
        if network_attributes_udp_timeout is not None:
            self._values["network_attributes_udp_timeout"] = network_attributes_udp_timeout
        if period is not None:
            self._values["period"] = period
        if period_unit is not None:
            self._values["period_unit"] = period_unit
        if quantity is not None:
            self._values["quantity"] = quantity
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if tags is not None:
            self._values["tags"] = tags
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def dedicated_host_type(self) -> builtins.str:
        """
        :Property: dedicatedHostType: The instance type of host.
        """
        result = self._values.get("dedicated_host_type")
        assert result is not None, "Required property 'dedicated_host_type' is missing"
        return result

    @builtins.property
    def action_on_maintenance(self) -> typing.Optional[builtins.str]:
        """
        :Property: actionOnMaintenance: The policy used to migrate the instances from the dedicated hostwhen the dedicated host fails or needs to be repaired online.Valid values: Migrate: Instances are migrated to another physical server and restarted.If the dedicated host is attached with disks that are not local disks, the default value is Migrate.Stop: Instances on the dedicated host are stopped. If the dedicated host cannot be repaired,the instances are migrated to another physical server and restarted.If the dedicated host is attached with local disks, the default value is Stop.
        """
        result = self._values.get("action_on_maintenance")
        return result

    @builtins.property
    def auto_placement(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoPlacement: Specifies whether the dedicated host is added to the resource pool for automatic deployment. If you do not specify the DedicatedHostId parameter when you create an instance on a dedicated host, Alibaba Cloud automatically selects a dedicated host from the resource pool to host the instance. For more information, see Automatic deployment. Valid values:on: The dedicated host is added to the resource pool for automatic deployment.off: The dedicated host is not added to the resource pool for automatic deployment.Default value: on.Note When you create a dedicated host: If you do not specify this parameter, the dedicated host is added to the automatic deployment resource pool.If you do not want to add the dedicated host to the automatic deployment resource pool, set the value to off.
        """
        result = self._values.get("auto_placement")
        return result

    @builtins.property
    def auto_release_time(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoReleaseTime: Auto release time for created host, Follow ISO8601 standard using UTC time. format is 'yyyy-MM-ddTHH:mm:ssZ'. Not bigger than 3 years from this day onwards
        """
        result = self._values.get("auto_release_time")
        return result

    @builtins.property
    def auto_renew(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoRenew: Whether renew the fee automatically? When the parameter InstanceChargeType is PrePaid, it will take effect. Range of value:True: automatic renewal.False: no automatic renewal. Default value is False.
        """
        result = self._values.get("auto_renew")
        return result

    @builtins.property
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.
        """
        result = self._values.get("auto_renew_period")
        return result

    @builtins.property
    def charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: chargeType: Instance Charge type, allowed value: Prepaid and Postpaid. If specified Prepaid, please ensure you have sufficient balance in your account. Or instance creation will be failure. Default value is Postpaid.
        """
        result = self._values.get("charge_type")
        return result

    @builtins.property
    def dedicated_host_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: dedicatedHostName: The name of the dedicated host, [2, 128] English or Chinese characters. It must begin with an uppercase/lowercase letter or a Chinese character, and may contain numbers, '_' or '-'. It cannot begin with http:// or https://.
        """
        result = self._values.get("dedicated_host_name")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: The description of host.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def network_attributes_slb_udp_timeout(self) -> typing.Optional[jsii.Number]:
        """
        :Property: networkAttributesSlbUdpTimeout: The duration of UDP timeout for sessions between Server Load Balancer (SLB) and the dedicated host. Unit: seconds. Valid values: 15 to 310.
        """
        result = self._values.get("network_attributes_slb_udp_timeout")
        return result

    @builtins.property
    def network_attributes_udp_timeout(self) -> typing.Optional[jsii.Number]:
        """
        :Property: networkAttributesUdpTimeout: The duration of UDP timeout for sessions between users and instances on the dedicated host. Unit: seconds. Valid values: 15 to 310.
        """
        result = self._values.get("network_attributes_udp_timeout")
        return result

    @builtins.property
    def period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: period: Prepaid time period. Unit is month, it could be from 1 to 9 or 12, 24, 36, 48, 60. Default value is 1.
        """
        result = self._values.get("period")
        return result

    @builtins.property
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month/Year. Default value is Month.
        """
        result = self._values.get("period_unit")
        return result

    @builtins.property
    def quantity(self) -> typing.Optional[jsii.Number]:
        """
        :Property: quantity: The number of dedicated hosts that you want to create. Valid values: 1 to 100.Default value: 1.
        """
        result = self._values.get("quantity")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: The ID of the resource group. If this is left blank, the system automatically fills in the ID of the default resource group.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[ros_cdk_core.RosTag]]:
        """
        :Property: tags: Tags to attach to DedicatedHost. Max support 20 tags to add during create DedicatedHost. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: zoneId: The zone to create the host.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosDedicatedHostProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosDeploymentSet(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosDeploymentSet",
):
    """A ROS template type:  ``ALIYUN::ECS::DeploymentSet``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosDeploymentSetProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::DeploymentSet``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosDeploymentSet, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrDeploymentSetId")
    def attr_deployment_set_id(self) -> typing.Any:
        """
        :Attribute: DeploymentSetId: The ID of the deployment set.
        """
        return jsii.get(self, "attrDeploymentSetId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="deploymentSetName")
    def deployment_set_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        deploymentSetName: The name of the deployment set. It must be 2 to 128 characters in length. It must
        start with a letter and cannot start with http:// or https://. It can contain letters,
        digits, colons (:), underscores (_), and hyphens (-).
        """
        return jsii.get(self, "deploymentSetName")

    @deployment_set_name.setter # type: ignore
    def deployment_set_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "deploymentSetName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        description: The description of the deployment set. It must be 2 to 256 characters in length. It
        cannot start with http:// or https://.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="onUnableToRedeployFailedInstance")
    def on_unable_to_redeploy_failed_instance(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        onUnableToRedeployFailedInstance: The emergency solution to redeploy failed instances in the deployment set. Valid values:
        CancelMembershipAndStart: restarts the instances immediately after they are shut down
        and migrated to other deployment sets. This is the default value.
        KeepStopped: keeps the instances shut down and restarts them after the deployment
        set is replenished.
        """
        return jsii.get(self, "onUnableToRedeployFailedInstance")

    @on_unable_to_redeploy_failed_instance.setter # type: ignore
    def on_unable_to_redeploy_failed_instance(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "onUnableToRedeployFailedInstance", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosDeploymentSetProps",
    jsii_struct_bases=[],
    name_mapping={
        "deployment_set_name": "deploymentSetName",
        "description": "description",
        "on_unable_to_redeploy_failed_instance": "onUnableToRedeployFailedInstance",
    },
)
class RosDeploymentSetProps:
    def __init__(
        self,
        *,
        deployment_set_name: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        on_unable_to_redeploy_failed_instance: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::DeploymentSet``.

        :param deployment_set_name: 
        :param description: 
        :param on_unable_to_redeploy_failed_instance: 
        """
        self._values: typing.Dict[str, typing.Any] = {}
        if deployment_set_name is not None:
            self._values["deployment_set_name"] = deployment_set_name
        if description is not None:
            self._values["description"] = description
        if on_unable_to_redeploy_failed_instance is not None:
            self._values["on_unable_to_redeploy_failed_instance"] = on_unable_to_redeploy_failed_instance

    @builtins.property
    def deployment_set_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        deploymentSetName: The name of the deployment set. It must be 2 to 128 characters in length. It must
        start with a letter and cannot start with http:// or https://. It can contain letters,
        digits, colons (:), underscores (_), and hyphens (-).
        """
        result = self._values.get("deployment_set_name")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        description: The description of the deployment set. It must be 2 to 256 characters in length. It
        cannot start with http:// or https://.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def on_unable_to_redeploy_failed_instance(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        onUnableToRedeployFailedInstance: The emergency solution to redeploy failed instances in the deployment set. Valid values:
        CancelMembershipAndStart: restarts the instances immediately after they are shut down
        and migrated to other deployment sets. This is the default value.
        KeepStopped: keeps the instances shut down and restarts them after the deployment
        set is replenished.
        """
        result = self._values.get("on_unable_to_redeploy_failed_instance")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosDeploymentSetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosDisk(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosDisk",
):
    """A ROS template type:  ``ALIYUN::ECS::Disk``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosDiskProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::Disk``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosDisk, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrDiskId")
    def attr_disk_id(self) -> typing.Any:
        """
        :Attribute: DiskId: Id of created disk.
        """
        return jsii.get(self, "attrDiskId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrStatus")
    def attr_status(self) -> typing.Any:
        """
        :Attribute: Status: Created disk status.
        """
        return jsii.get(self, "attrStatus")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="tags")
    def tags(self) -> ros_cdk_core.TagManager:
        """
        :Property: tags: Tags to attach to disk. Max support 20 tags to add during create disk. Each tag with two properties Key and Value, and Key is required.
        """
        return jsii.get(self, "tags")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="zoneId")
    def zone_id(self) -> builtins.str:
        """
        :Property: zoneId: The availability zone in which the volume will be created.
        """
        return jsii.get(self, "zoneId")

    @zone_id.setter # type: ignore
    def zone_id(self, value: builtins.str) -> None:
        jsii.set(self, "zoneId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoSnapshotPolicyId")
    def auto_snapshot_policy_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoSnapshotPolicyId: Auto snapshot policy ID.
        """
        return jsii.get(self, "autoSnapshotPolicyId")

    @auto_snapshot_policy_id.setter # type: ignore
    def auto_snapshot_policy_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "autoSnapshotPolicyId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="deleteAutoSnapshot")
    def delete_auto_snapshot(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deleteAutoSnapshot: Whether the auto snapshot is released with the disk. Default to false.
        """
        return jsii.get(self, "deleteAutoSnapshot")

    @delete_auto_snapshot.setter # type: ignore
    def delete_auto_snapshot(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "deleteAutoSnapshot", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the disk, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="diskCategory")
    def disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: diskCategory: The disk category, now support cloud/cloud_ssd/cloud_essd/cloud_efficiency/san_ssd/san_efficiency, depends the region.
        """
        return jsii.get(self, "diskCategory")

    @disk_category.setter # type: ignore
    def disk_category(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "diskCategory", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="diskName")
    def disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: diskName: Display name of the disk, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        return jsii.get(self, "diskName")

    @disk_name.setter # type: ignore
    def disk_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "diskName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="encrypted")
    def encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: encrypted: Whether disk is encrypted, default to false.
        """
        return jsii.get(self, "encrypted")

    @encrypted.setter # type: ignore
    def encrypted(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "encrypted", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="kmsKeyId")
    def kms_key_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: kmsKeyId: KMS key ID used by the cloud disk.
        """
        return jsii.get(self, "kmsKeyId")

    @kms_key_id.setter # type: ignore
    def kms_key_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "kmsKeyId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="performanceLevel")
    def performance_level(self) -> typing.Optional[builtins.str]:
        """
        :Property: performanceLevel: The performance level you select for an ESSD.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
        """
        return jsii.get(self, "performanceLevel")

    @performance_level.setter # type: ignore
    def performance_level(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "performanceLevel", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        return jsii.get(self, "resourceGroupId")

    @resource_group_id.setter # type: ignore
    def resource_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "resourceGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="size")
    def size(self) -> typing.Optional[jsii.Number]:
        """
        :Property: size: The size of the disk unit in GB.
        """
        return jsii.get(self, "size")

    @size.setter # type: ignore
    def size(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "size", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="snapshotId")
    def snapshot_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: snapshotId: If specified, the backup used as the source to create disk.
        """
        return jsii.get(self, "snapshotId")

    @snapshot_id.setter # type: ignore
    def snapshot_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "snapshotId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="storageSetId")
    def storage_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: storageSetId: Storage set ID.
        """
        return jsii.get(self, "storageSetId")

    @storage_set_id.setter # type: ignore
    def storage_set_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "storageSetId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="storageSetPartitionNumber")
    def storage_set_partition_number(self) -> typing.Optional[jsii.Number]:
        """
        :Property: storageSetPartitionNumber: The number of storage set partitions.
        """
        return jsii.get(self, "storageSetPartitionNumber")

    @storage_set_partition_number.setter # type: ignore
    def storage_set_partition_number(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "storageSetPartitionNumber", value)


class RosDiskAttachment(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosDiskAttachment",
):
    """A ROS template type:  ``ALIYUN::ECS::DiskAttachment``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosDiskAttachmentProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::DiskAttachment``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosDiskAttachment, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrDevice")
    def attr_device(self) -> typing.Any:
        """
        :Attribute: Device: The device where the volume is exposed on ecs instance.
        """
        return jsii.get(self, "attrDevice")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrDiskId")
    def attr_disk_id(self) -> typing.Any:
        """
        :Attribute: DiskId: The disk id of created disk
        """
        return jsii.get(self, "attrDiskId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrStatus")
    def attr_status(self) -> typing.Any:
        """
        :Attribute: Status: The disk status now.
        """
        return jsii.get(self, "attrStatus")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="diskId")
    def disk_id(self) -> builtins.str:
        """
        :Property: diskId: The disk id to attached.
        """
        return jsii.get(self, "diskId")

    @disk_id.setter # type: ignore
    def disk_id(self, value: builtins.str) -> None:
        jsii.set(self, "diskId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceId")
    def instance_id(self) -> builtins.str:
        """
        :Property: instanceId: The instanceId to attach the disk.
        """
        return jsii.get(self, "instanceId")

    @instance_id.setter # type: ignore
    def instance_id(self, value: builtins.str) -> None:
        jsii.set(self, "instanceId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="deleteAutoSnapshot")
    def delete_auto_snapshot(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deleteAutoSnapshot: Whether the auto snapshot is released with the disk. Default to true.
        """
        return jsii.get(self, "deleteAutoSnapshot")

    @delete_auto_snapshot.setter # type: ignore
    def delete_auto_snapshot(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "deleteAutoSnapshot", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="deleteWithInstance")
    def delete_with_instance(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deleteWithInstance: If property is true, the disk will be deleted while instance is deleted, if property is false, the disk will be retain after instance is deleted.
        """
        return jsii.get(self, "deleteWithInstance")

    @delete_with_instance.setter # type: ignore
    def delete_with_instance(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "deleteWithInstance", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="device")
    def device(self) -> typing.Optional[builtins.str]:
        """
        :Property: device: The device where the volume is exposed on the instance. could be /dev/xvd[b-z]. If not specification, will use default value.
        """
        return jsii.get(self, "device")

    @device.setter # type: ignore
    def device(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "device", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosDiskAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "disk_id": "diskId",
        "instance_id": "instanceId",
        "delete_auto_snapshot": "deleteAutoSnapshot",
        "delete_with_instance": "deleteWithInstance",
        "device": "device",
    },
)
class RosDiskAttachmentProps:
    def __init__(
        self,
        *,
        disk_id: builtins.str,
        instance_id: builtins.str,
        delete_auto_snapshot: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        delete_with_instance: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        device: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::DiskAttachment``.

        :param disk_id: 
        :param instance_id: 
        :param delete_auto_snapshot: 
        :param delete_with_instance: 
        :param device: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "disk_id": disk_id,
            "instance_id": instance_id,
        }
        if delete_auto_snapshot is not None:
            self._values["delete_auto_snapshot"] = delete_auto_snapshot
        if delete_with_instance is not None:
            self._values["delete_with_instance"] = delete_with_instance
        if device is not None:
            self._values["device"] = device

    @builtins.property
    def disk_id(self) -> builtins.str:
        """
        :Property: diskId: The disk id to attached.
        """
        result = self._values.get("disk_id")
        assert result is not None, "Required property 'disk_id' is missing"
        return result

    @builtins.property
    def instance_id(self) -> builtins.str:
        """
        :Property: instanceId: The instanceId to attach the disk.
        """
        result = self._values.get("instance_id")
        assert result is not None, "Required property 'instance_id' is missing"
        return result

    @builtins.property
    def delete_auto_snapshot(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deleteAutoSnapshot: Whether the auto snapshot is released with the disk. Default to true.
        """
        result = self._values.get("delete_auto_snapshot")
        return result

    @builtins.property
    def delete_with_instance(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deleteWithInstance: If property is true, the disk will be deleted while instance is deleted, if property is false, the disk will be retain after instance is deleted.
        """
        result = self._values.get("delete_with_instance")
        return result

    @builtins.property
    def device(self) -> typing.Optional[builtins.str]:
        """
        :Property: device: The device where the volume is exposed on the instance. could be /dev/xvd[b-z]. If not specification, will use default value.
        """
        result = self._values.get("device")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosDiskAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosDiskProps",
    jsii_struct_bases=[],
    name_mapping={
        "zone_id": "zoneId",
        "auto_snapshot_policy_id": "autoSnapshotPolicyId",
        "delete_auto_snapshot": "deleteAutoSnapshot",
        "description": "description",
        "disk_category": "diskCategory",
        "disk_name": "diskName",
        "encrypted": "encrypted",
        "kms_key_id": "kmsKeyId",
        "performance_level": "performanceLevel",
        "resource_group_id": "resourceGroupId",
        "size": "size",
        "snapshot_id": "snapshotId",
        "storage_set_id": "storageSetId",
        "storage_set_partition_number": "storageSetPartitionNumber",
        "tags": "tags",
    },
)
class RosDiskProps:
    def __init__(
        self,
        *,
        zone_id: builtins.str,
        auto_snapshot_policy_id: typing.Optional[builtins.str] = None,
        delete_auto_snapshot: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        description: typing.Optional[builtins.str] = None,
        disk_category: typing.Optional[builtins.str] = None,
        disk_name: typing.Optional[builtins.str] = None,
        encrypted: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        kms_key_id: typing.Optional[builtins.str] = None,
        performance_level: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        size: typing.Optional[jsii.Number] = None,
        snapshot_id: typing.Optional[builtins.str] = None,
        storage_set_id: typing.Optional[builtins.str] = None,
        storage_set_partition_number: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.List[ros_cdk_core.RosTag]] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::Disk``.

        :param zone_id: 
        :param auto_snapshot_policy_id: 
        :param delete_auto_snapshot: 
        :param description: 
        :param disk_category: 
        :param disk_name: 
        :param encrypted: 
        :param kms_key_id: 
        :param performance_level: 
        :param resource_group_id: 
        :param size: 
        :param snapshot_id: 
        :param storage_set_id: 
        :param storage_set_partition_number: 
        :param tags: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "zone_id": zone_id,
        }
        if auto_snapshot_policy_id is not None:
            self._values["auto_snapshot_policy_id"] = auto_snapshot_policy_id
        if delete_auto_snapshot is not None:
            self._values["delete_auto_snapshot"] = delete_auto_snapshot
        if description is not None:
            self._values["description"] = description
        if disk_category is not None:
            self._values["disk_category"] = disk_category
        if disk_name is not None:
            self._values["disk_name"] = disk_name
        if encrypted is not None:
            self._values["encrypted"] = encrypted
        if kms_key_id is not None:
            self._values["kms_key_id"] = kms_key_id
        if performance_level is not None:
            self._values["performance_level"] = performance_level
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if size is not None:
            self._values["size"] = size
        if snapshot_id is not None:
            self._values["snapshot_id"] = snapshot_id
        if storage_set_id is not None:
            self._values["storage_set_id"] = storage_set_id
        if storage_set_partition_number is not None:
            self._values["storage_set_partition_number"] = storage_set_partition_number
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def zone_id(self) -> builtins.str:
        """
        :Property: zoneId: The availability zone in which the volume will be created.
        """
        result = self._values.get("zone_id")
        assert result is not None, "Required property 'zone_id' is missing"
        return result

    @builtins.property
    def auto_snapshot_policy_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoSnapshotPolicyId: Auto snapshot policy ID.
        """
        result = self._values.get("auto_snapshot_policy_id")
        return result

    @builtins.property
    def delete_auto_snapshot(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deleteAutoSnapshot: Whether the auto snapshot is released with the disk. Default to false.
        """
        result = self._values.get("delete_auto_snapshot")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the disk, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: diskCategory: The disk category, now support cloud/cloud_ssd/cloud_essd/cloud_efficiency/san_ssd/san_efficiency, depends the region.
        """
        result = self._values.get("disk_category")
        return result

    @builtins.property
    def disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: diskName: Display name of the disk, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("disk_name")
        return result

    @builtins.property
    def encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: encrypted: Whether disk is encrypted, default to false.
        """
        result = self._values.get("encrypted")
        return result

    @builtins.property
    def kms_key_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: kmsKeyId: KMS key ID used by the cloud disk.
        """
        result = self._values.get("kms_key_id")
        return result

    @builtins.property
    def performance_level(self) -> typing.Optional[builtins.str]:
        """
        :Property: performanceLevel: The performance level you select for an ESSD.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
        """
        result = self._values.get("performance_level")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def size(self) -> typing.Optional[jsii.Number]:
        """
        :Property: size: The size of the disk unit in GB.
        """
        result = self._values.get("size")
        return result

    @builtins.property
    def snapshot_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: snapshotId: If specified, the backup used as the source to create disk.
        """
        result = self._values.get("snapshot_id")
        return result

    @builtins.property
    def storage_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: storageSetId: Storage set ID.
        """
        result = self._values.get("storage_set_id")
        return result

    @builtins.property
    def storage_set_partition_number(self) -> typing.Optional[jsii.Number]:
        """
        :Property: storageSetPartitionNumber: The number of storage set partitions.
        """
        result = self._values.get("storage_set_partition_number")
        return result

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[ros_cdk_core.RosTag]]:
        """
        :Property: tags: Tags to attach to disk. Max support 20 tags to add during create disk. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosDiskProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosForwardEntry(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosForwardEntry",
):
    """A ROS template type:  ``ALIYUN::ECS::ForwardEntry``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosForwardEntryProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::ForwardEntry``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosForwardEntry, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrForwardEntryId")
    def attr_forward_entry_id(self) -> typing.Any:
        """
        :Attribute: ForwardEntryId: The id of created forward entry.
        """
        return jsii.get(self, "attrForwardEntryId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="externalIp")
    def external_ip(self) -> builtins.str:
        """
        :Property: externalIp: Source IP, must belongs to bandwidth package internet IP
        """
        return jsii.get(self, "externalIp")

    @external_ip.setter # type: ignore
    def external_ip(self, value: builtins.str) -> None:
        jsii.set(self, "externalIp", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="externalPort")
    def external_port(self) -> builtins.str:
        """
        :Property: externalPort: Source port, now support [1-65535]|Any
        """
        return jsii.get(self, "externalPort")

    @external_port.setter # type: ignore
    def external_port(self, value: builtins.str) -> None:
        jsii.set(self, "externalPort", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="forwardTableId")
    def forward_table_id(self) -> builtins.str:
        """
        :Property: forwardTableId: Create forward entry in specified forward table.
        """
        return jsii.get(self, "forwardTableId")

    @forward_table_id.setter # type: ignore
    def forward_table_id(self, value: builtins.str) -> None:
        jsii.set(self, "forwardTableId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internalIp")
    def internal_ip(self) -> builtins.str:
        """
        :Property: internalIp: Destination IP, must belong to VPC private IP
        """
        return jsii.get(self, "internalIp")

    @internal_ip.setter # type: ignore
    def internal_ip(self, value: builtins.str) -> None:
        jsii.set(self, "internalIp", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internalPort")
    def internal_port(self) -> builtins.str:
        """
        :Property: internalPort: Destination port, now support [1-65535]|Any
        """
        return jsii.get(self, "internalPort")

    @internal_port.setter # type: ignore
    def internal_port(self, value: builtins.str) -> None:
        jsii.set(self, "internalPort", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ipProtocol")
    def ip_protocol(self) -> builtins.str:
        """
        :Property: ipProtocol: Supported protocol, Now support 'TCP|UDP|Any'
        """
        return jsii.get(self, "ipProtocol")

    @ip_protocol.setter # type: ignore
    def ip_protocol(self, value: builtins.str) -> None:
        jsii.set(self, "ipProtocol", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosForwardEntryProps",
    jsii_struct_bases=[],
    name_mapping={
        "external_ip": "externalIp",
        "external_port": "externalPort",
        "forward_table_id": "forwardTableId",
        "internal_ip": "internalIp",
        "internal_port": "internalPort",
        "ip_protocol": "ipProtocol",
    },
)
class RosForwardEntryProps:
    def __init__(
        self,
        *,
        external_ip: builtins.str,
        external_port: builtins.str,
        forward_table_id: builtins.str,
        internal_ip: builtins.str,
        internal_port: builtins.str,
        ip_protocol: builtins.str,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::ForwardEntry``.

        :param external_ip: 
        :param external_port: 
        :param forward_table_id: 
        :param internal_ip: 
        :param internal_port: 
        :param ip_protocol: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "external_ip": external_ip,
            "external_port": external_port,
            "forward_table_id": forward_table_id,
            "internal_ip": internal_ip,
            "internal_port": internal_port,
            "ip_protocol": ip_protocol,
        }

    @builtins.property
    def external_ip(self) -> builtins.str:
        """
        :Property: externalIp: Source IP, must belongs to bandwidth package internet IP
        """
        result = self._values.get("external_ip")
        assert result is not None, "Required property 'external_ip' is missing"
        return result

    @builtins.property
    def external_port(self) -> builtins.str:
        """
        :Property: externalPort: Source port, now support [1-65535]|Any
        """
        result = self._values.get("external_port")
        assert result is not None, "Required property 'external_port' is missing"
        return result

    @builtins.property
    def forward_table_id(self) -> builtins.str:
        """
        :Property: forwardTableId: Create forward entry in specified forward table.
        """
        result = self._values.get("forward_table_id")
        assert result is not None, "Required property 'forward_table_id' is missing"
        return result

    @builtins.property
    def internal_ip(self) -> builtins.str:
        """
        :Property: internalIp: Destination IP, must belong to VPC private IP
        """
        result = self._values.get("internal_ip")
        assert result is not None, "Required property 'internal_ip' is missing"
        return result

    @builtins.property
    def internal_port(self) -> builtins.str:
        """
        :Property: internalPort: Destination port, now support [1-65535]|Any
        """
        result = self._values.get("internal_port")
        assert result is not None, "Required property 'internal_port' is missing"
        return result

    @builtins.property
    def ip_protocol(self) -> builtins.str:
        """
        :Property: ipProtocol: Supported protocol, Now support 'TCP|UDP|Any'
        """
        result = self._values.get("ip_protocol")
        assert result is not None, "Required property 'ip_protocol' is missing"
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosForwardEntryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosHpcCluster(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosHpcCluster",
):
    """A ROS template type:  ``ALIYUN::ECS::HpcCluster``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosHpcClusterProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::HpcCluster``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosHpcCluster, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrHpcClusterId")
    def attr_hpc_cluster_id(self) -> typing.Any:
        """
        :Attribute: HpcClusterId: The ID of the HPC cluster.
        """
        return jsii.get(self, "attrHpcClusterId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrName")
    def attr_name(self) -> typing.Any:
        """
        :Attribute: Name: The name of the HPC cluster.
        """
        return jsii.get(self, "attrName")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        """
        :Property:

        name: The name of the HPC cluster. The name must be 2 to 128 characters in length. It must
        start with a letter but cannot start with http:// or https://. It can contain letters,
        digits, colons (:), underscores (_), and hyphens (-).
        """
        return jsii.get(self, "name")

    @name.setter # type: ignore
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        description: The description of the HPC cluster. The description must be 2 to 256 characters in
        length. It cannot start with http:// or https://. Default value: empty string.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosHpcClusterProps",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "description": "description"},
)
class RosHpcClusterProps:
    def __init__(
        self,
        *,
        name: builtins.str,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::HpcCluster``.

        :param name: 
        :param description: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if description is not None:
            self._values["description"] = description

    @builtins.property
    def name(self) -> builtins.str:
        """
        :Property:

        name: The name of the HPC cluster. The name must be 2 to 128 characters in length. It must
        start with a letter but cannot start with http:// or https://. It can contain letters,
        digits, colons (:), underscores (_), and hyphens (-).
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        description: The description of the HPC cluster. The description must be 2 to 256 characters in
        length. It cannot start with http:// or https://. Default value: empty string.
        """
        result = self._values.get("description")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosHpcClusterProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosInstance(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosInstance",
):
    """A ROS template type:  ``ALIYUN::ECS::Instance``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosInstanceProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::Instance``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosInstance, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrHostName")
    def attr_host_name(self) -> typing.Any:
        """
        :Attribute: HostName: Host name of created instance.
        """
        return jsii.get(self, "attrHostName")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInnerIp")
    def attr_inner_ip(self) -> typing.Any:
        """
        :Attribute: InnerIp: Inner IP address of the specified instance. Only for classical instance.
        """
        return jsii.get(self, "attrInnerIp")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInstanceId")
    def attr_instance_id(self) -> typing.Any:
        """
        :Attribute: InstanceId: The instance id of created ecs instance
        """
        return jsii.get(self, "attrInstanceId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrimaryNetworkInterfaceId")
    def attr_primary_network_interface_id(self) -> typing.Any:
        """
        :Attribute: PrimaryNetworkInterfaceId: Primary network interface id of created instance.
        """
        return jsii.get(self, "attrPrimaryNetworkInterfaceId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateIp")
    def attr_private_ip(self) -> typing.Any:
        """
        :Attribute: PrivateIp: Private IP address of created ecs instance. Only for VPC instance.
        """
        return jsii.get(self, "attrPrivateIp")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPublicIp")
    def attr_public_ip(self) -> typing.Any:
        """
        :Attribute: PublicIp: Public IP address of created ecs instance.
        """
        return jsii.get(self, "attrPublicIp")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrZoneId")
    def attr_zone_id(self) -> typing.Any:
        """
        :Attribute: ZoneId: Zone id of created instance.
        """
        return jsii.get(self, "attrZoneId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="tags")
    def tags(self) -> ros_cdk_core.TagManager:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        return jsii.get(self, "tags")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="imageId")
    def image_id(self) -> builtins.str:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        return jsii.get(self, "imageId")

    @image_id.setter # type: ignore
    def image_id(self, value: builtins.str) -> None:
        jsii.set(self, "imageId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceType")
    def instance_type(self) -> builtins.str:
        """
        :Property: instanceType: Ecs instance supported instance type, make sure it should be correct.
        """
        return jsii.get(self, "instanceType")

    @instance_type.setter # type: ignore
    def instance_type(self, value: builtins.str) -> None:
        jsii.set(self, "instanceType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="allocatePublicIp")
    def allocate_public_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: allocatePublicIp: The public ip for ecs instance, if properties is true, will allocate public ip. If property InternetMaxBandwidthOut set to 0, it will not assign public ip.
        """
        return jsii.get(self, "allocatePublicIp")

    @allocate_public_ip.setter # type: ignore
    def allocate_public_ip(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "allocatePublicIp", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoRenew")
    def auto_renew(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoRenew: Whether renew the fee automatically? When the parameter InstanceChargeType is PrePaid, it will take effect. Range of value:True: automatic renewal.False: no automatic renewal. Default value is False.
        """
        return jsii.get(self, "autoRenew")

    @auto_renew.setter # type: ignore
    def auto_renew(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "autoRenew", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoRenewPeriod")
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.
        """
        return jsii.get(self, "autoRenewPeriod")

    @auto_renew_period.setter # type: ignore
    def auto_renew_period(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "autoRenewPeriod", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="dedicatedHostId")
    def dedicated_host_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: dedicatedHostId: which dedicated host will be deployed
        """
        return jsii.get(self, "dedicatedHostId")

    @dedicated_host_id.setter # type: ignore
    def dedicated_host_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "dedicatedHostId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="deletionProtection")
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deletionProtection: Whether an instance can be released manually through the console or API, deletion protection only support postPaid instance
        """
        return jsii.get(self, "deletionProtection")

    @deletion_protection.setter # type: ignore
    def deletion_protection(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "deletionProtection", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="deploymentSetId")
    def deployment_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: deploymentSetId: Deployment set ID.
        """
        return jsii.get(self, "deploymentSetId")

    @deployment_set_id.setter # type: ignore
    def deployment_set_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "deploymentSetId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="diskMappings")
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstance.DiskMappingsProperty"]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.
        """
        return jsii.get(self, "diskMappings")

    @disk_mappings.setter # type: ignore
    def disk_mappings(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstance.DiskMappingsProperty"]]]],
    ) -> None:
        jsii.set(self, "diskMappings", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="hostName")
    def host_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: hostName: Host name of created ecs instance. at least 2 characters, and '.' '-' Is not the first and last characters as hostname, not continuous use. Windows platform can be up to 15 characters, allowing letters (without limiting case), numbers and '-', and does not support the number of points, not all is digital ('.').Other (Linux, etc.) platform up to 30 characters, allowing support number multiple points for the period between the points, each permit letters (without limiting case), numbers and '-' components.
        """
        return jsii.get(self, "hostName")

    @host_name.setter # type: ignore
    def host_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "hostName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="hpcClusterId")
    def hpc_cluster_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.
        """
        return jsii.get(self, "hpcClusterId")

    @hpc_cluster_id.setter # type: ignore
    def hpc_cluster_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "hpcClusterId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceChargeType")
    def instance_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceChargeType: Instance Charge type, allowed value: Prepaid and Postpaid. If specified Prepaid, please ensure you have sufficient balance in your account. Or instance creation will be failure. Default value is Postpaid.
        """
        return jsii.get(self, "instanceChargeType")

    @instance_charge_type.setter # type: ignore
    def instance_charge_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceChargeType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceName")
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        return jsii.get(self, "instanceName")

    @instance_name.setter # type: ignore
    def instance_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetChargeType")
    def internet_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: internetChargeType: Instance internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByTraffic
        """
        return jsii.get(self, "internetChargeType")

    @internet_charge_type.setter # type: ignore
    def internet_charge_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "internetChargeType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetMaxBandwidthIn")
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        return jsii.get(self, "internetMaxBandwidthIn")

    @internet_max_bandwidth_in.setter # type: ignore
    def internet_max_bandwidth_in(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "internetMaxBandwidthIn", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Set internet output bandwidth of instance. Unit is Mbps(Mega bit per second). Range is [0,200]. Default is 1.While the property is not 0, public ip will be assigned for instance.
        """
        return jsii.get(self, "internetMaxBandwidthOut")

    @internet_max_bandwidth_out.setter # type: ignore
    def internet_max_bandwidth_out(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "internetMaxBandwidthOut", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ioOptimized")
    def io_optimized(self) -> typing.Optional[builtins.str]:
        """
        :Property: ioOptimized: The 'optimized' instance can provide better IO performance. Support 'none' and 'optimized' only, default is 'optimized'.
        """
        return jsii.get(self, "ioOptimized")

    @io_optimized.setter # type: ignore
    def io_optimized(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ioOptimized", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="keyPairName")
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.
        """
        return jsii.get(self, "keyPairName")

    @key_pair_name.setter # type: ignore
    def key_pair_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "keyPairName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="password")
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        return jsii.get(self, "password")

    @password.setter # type: ignore
    def password(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "password", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="passwordInherit")
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: passwordInherit: Specifies whether to use the password preset in the image. To use the PasswordInherit parameter, the Password parameter must be empty and you must make sure that the selected image has a password configured.
        """
        return jsii.get(self, "passwordInherit")

    @password_inherit.setter # type: ignore
    def password_inherit(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "passwordInherit", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="period")
    def period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: period: Prepaid time period. Unit is month, it could be from 1 to 9 or 12, 24, 36, 48, 60. Default value is 1.
        """
        return jsii.get(self, "period")

    @period.setter # type: ignore
    def period(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "period", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="periodUnit")
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month/Year. Default value is Month.
        """
        return jsii.get(self, "periodUnit")

    @period_unit.setter # type: ignore
    def period_unit(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "periodUnit", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="privateIpAddress")
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        """
        :Property: privateIpAddress: Private IP for the instance created. Only works for VPC instance and cannot duplicated with existing instance.
        """
        return jsii.get(self, "privateIpAddress")

    @private_ip_address.setter # type: ignore
    def private_ip_address(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "privateIpAddress", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ramRoleName")
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        return jsii.get(self, "ramRoleName")

    @ram_role_name.setter # type: ignore
    def ram_role_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ramRoleName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        return jsii.get(self, "resourceGroupId")

    @resource_group_id.setter # type: ignore
    def resource_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "resourceGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityEnhancementStrategy")
    def security_enhancement_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityEnhancementStrategy:
        """
        return jsii.get(self, "securityEnhancementStrategy")

    @security_enhancement_strategy.setter # type: ignore
    def security_enhancement_strategy(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "securityEnhancementStrategy", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupId")
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        return jsii.get(self, "securityGroupId")

    @security_group_id.setter # type: ignore
    def security_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "securityGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="spotPriceLimit")
    def spot_price_limit(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotPriceLimit: The hourly price threshold of a instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Three decimals is allowed at most.
        """
        return jsii.get(self, "spotPriceLimit")

    @spot_price_limit.setter # type: ignore
    def spot_price_limit(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "spotPriceLimit", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="spotStrategy")
    def spot_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotStrategy: The spot strategy of a Pay-As-You-Go instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Value range: "NoSpot: A regular Pay-As-You-Go instance", "SpotWithPriceLimit: A price threshold for a spot instance, ""SpotAsPriceGo: A price that is based on the highest Pay-As-You-Go instance. "Default value: NoSpot.
        """
        return jsii.get(self, "spotStrategy")

    @spot_strategy.setter # type: ignore
    def spot_strategy(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "spotStrategy", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskCategory")
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. Default is cloud_efficiency. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd
        """
        return jsii.get(self, "systemDiskCategory")

    @system_disk_category.setter # type: ignore
    def system_disk_category(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskCategory", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskDescription")
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.
        """
        return jsii.get(self, "systemDiskDescription")

    @system_disk_description.setter # type: ignore
    def system_disk_description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskDescription", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskDiskName")
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.
        """
        return jsii.get(self, "systemDiskDiskName")

    @system_disk_disk_name.setter # type: ignore
    def system_disk_disk_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskDiskName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskPerformanceLevel")
    def system_disk_performance_level(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskPerformanceLevel: The performance level of the enhanced SSD used as the system disk.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
        """
        return jsii.get(self, "systemDiskPerformanceLevel")

    @system_disk_performance_level.setter # type: ignore
    def system_disk_performance_level(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "systemDiskPerformanceLevel", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskSize")
    def system_disk_size(self) -> typing.Optional[jsii.Number]:
        """
        :Property: systemDiskSize: Disk size of the system disk, range from 20 to 500 GB. If you specify with your own image, make sure the system disk size bigger than image size.
        """
        return jsii.get(self, "systemDiskSize")

    @system_disk_size.setter # type: ignore
    def system_disk_size(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "systemDiskSize", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="userData")
    def user_data(self) -> typing.Optional[builtins.str]:
        """
        :Property: userData: User data to pass to instance. [1, 16KB] characters.User data should not be base64 encoded. If you want to pass base64 encoded string to the property, use function Fn::Base64Decode to decode the base64 string first.
        """
        return jsii.get(self, "userData")

    @user_data.setter # type: ignore
    def user_data(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "userData", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcId: The VPC id to create ecs instance.
        """
        return jsii.get(self, "vpcId")

    @vpc_id.setter # type: ignore
    def vpc_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vpcId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="vSwitchId")
    def v_switch_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vSwitchId: The vSwitch Id to create ecs instance.
        """
        return jsii.get(self, "vSwitchId")

    @v_switch_id.setter # type: ignore
    def v_switch_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vSwitchId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="zoneId")
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        return jsii.get(self, "zoneId")

    @zone_id.setter # type: ignore
    def zone_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "zoneId", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosInstance.DiskMappingsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "size": "size",
            "category": "category",
            "description": "description",
            "device": "device",
            "disk_name": "diskName",
            "performance_level": "performanceLevel",
            "snapshot_id": "snapshotId",
        },
    )
    class DiskMappingsProperty:
        def __init__(
            self,
            *,
            size: builtins.str,
            category: typing.Optional[builtins.str] = None,
            description: typing.Optional[builtins.str] = None,
            device: typing.Optional[builtins.str] = None,
            disk_name: typing.Optional[builtins.str] = None,
            performance_level: typing.Optional[builtins.str] = None,
            snapshot_id: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param size: 
            :param category: 
            :param description: 
            :param device: 
            :param disk_name: 
            :param performance_level: 
            :param snapshot_id: 
            """
            self._values: typing.Dict[str, typing.Any] = {
                "size": size,
            }
            if category is not None:
                self._values["category"] = category
            if description is not None:
                self._values["description"] = description
            if device is not None:
                self._values["device"] = device
            if disk_name is not None:
                self._values["disk_name"] = disk_name
            if performance_level is not None:
                self._values["performance_level"] = performance_level
            if snapshot_id is not None:
                self._values["snapshot_id"] = snapshot_id

        @builtins.property
        def size(self) -> builtins.str:
            """
            :Property: size: The size of the volume, unit in GB.Value range: cloud: [5,2000], cloud_efficiency: [20,32768], cloud_ssd: [20,32768], cloud_essd: [20,32768], ephemeral_ssd: [5,800].The value should be equal to or greater than the specific snapshot.
            """
            result = self._values.get("size")
            assert result is not None, "Required property 'size' is missing"
            return result

        @builtins.property
        def category(self) -> typing.Optional[builtins.str]:
            """
            :Property: category: The volume type.Now support: cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd. Default is cloud_efficiency.
            """
            result = self._values.get("category")
            return result

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            """
            :Property: description: Description of the disk, [2, 256] characters. Do not fill or empty, the default is empty.
            """
            result = self._values.get("description")
            return result

        @builtins.property
        def device(self) -> typing.Optional[builtins.str]:
            """
            :Property: device: The device where the volume is exposed on the instance. could be /dev/xvd[a-z]. If not specification, will use default value.
            """
            result = self._values.get("device")
            return result

        @builtins.property
        def disk_name(self) -> typing.Optional[builtins.str]:
            """
            :Property: diskName: Display name of the disk, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.
            """
            result = self._values.get("disk_name")
            return result

        @builtins.property
        def performance_level(self) -> typing.Optional[builtins.str]:
            """
            :Property: performanceLevel: The performance level of the enhanced SSD used as the Nth data disk.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
            """
            result = self._values.get("performance_level")
            return result

        @builtins.property
        def snapshot_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: snapshotId: ID of the snapshot to create the volume.
            """
            result = self._values.get("snapshot_id")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DiskMappingsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


class RosInstanceClone(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosInstanceClone",
):
    """A ROS template type:  ``ALIYUN::ECS::InstanceClone``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosInstanceCloneProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::InstanceClone``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosInstanceClone, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrHostName")
    def attr_host_name(self) -> typing.Any:
        """
        :Attribute: HostName: Host name of created instance.
        """
        return jsii.get(self, "attrHostName")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInnerIp")
    def attr_inner_ip(self) -> typing.Any:
        """
        :Attribute: InnerIp: Inner IP address of the specified instance. Only for classical instance.
        """
        return jsii.get(self, "attrInnerIp")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInstanceId")
    def attr_instance_id(self) -> typing.Any:
        """
        :Attribute: InstanceId: The instance id of created ecs instance
        """
        return jsii.get(self, "attrInstanceId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrimaryNetworkInterfaceId")
    def attr_primary_network_interface_id(self) -> typing.Any:
        """
        :Attribute: PrimaryNetworkInterfaceId: Primary network interface id of created instance.
        """
        return jsii.get(self, "attrPrimaryNetworkInterfaceId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateIp")
    def attr_private_ip(self) -> typing.Any:
        """
        :Attribute: PrivateIp: Private IP address of created ecs instance. Only for VPC instance.
        """
        return jsii.get(self, "attrPrivateIp")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPublicIp")
    def attr_public_ip(self) -> typing.Any:
        """
        :Attribute: PublicIp: Public IP address of created ecs instance.
        """
        return jsii.get(self, "attrPublicIp")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrZoneId")
    def attr_zone_id(self) -> typing.Any:
        """
        :Attribute: ZoneId: Zone id of created instance.
        """
        return jsii.get(self, "attrZoneId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="tags")
    def tags(self) -> ros_cdk_core.TagManager:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        return jsii.get(self, "tags")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="sourceInstanceId")
    def source_instance_id(self) -> builtins.str:
        """
        :Property: sourceInstanceId: Source ecs instance used to copy properties to clone new ecs instance. It will copy the InstanceType, ImageId, InternetChargeType, InternetMaxBandwidthIn, InternetMaxBandwidthOut and the system disk and data disk configurations. If the instance network is VPC, it will also clone the relative properties. If specified instance with more than one security group, it will use the first security group to create instance. you can also specify the SecurityGroupId to override it.
        """
        return jsii.get(self, "sourceInstanceId")

    @source_instance_id.setter # type: ignore
    def source_instance_id(self, value: builtins.str) -> None:
        jsii.set(self, "sourceInstanceId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="backendServerWeight")
    def backend_server_weight(self) -> typing.Optional[jsii.Number]:
        """
        :Property: backendServerWeight: The weight of backend server of load balancer. From 0 to 100, 0 means offline. Default is 100.
        """
        return jsii.get(self, "backendServerWeight")

    @backend_server_weight.setter # type: ignore
    def backend_server_weight(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "backendServerWeight", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="deletionProtection")
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deletionProtection: Whether an instance can be released manually through the console or API, deletion protection only support postPaid instance
        """
        return jsii.get(self, "deletionProtection")

    @deletion_protection.setter # type: ignore
    def deletion_protection(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "deletionProtection", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="diskMappings")
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceClone.DiskMappingsProperty"]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.
        """
        return jsii.get(self, "diskMappings")

    @disk_mappings.setter # type: ignore
    def disk_mappings(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceClone.DiskMappingsProperty"]]]],
    ) -> None:
        jsii.set(self, "diskMappings", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="imageId")
    def image_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        return jsii.get(self, "imageId")

    @image_id.setter # type: ignore
    def image_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "imageId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceChargeType")
    def instance_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceChargeType: Instance Charge type, allowed value: Prepaid and Postpaid. If specified Prepaid, please ensure you have sufficient balance in your account. Or instance creation will be failure. Default value is Postpaid.
        """
        return jsii.get(self, "instanceChargeType")

    @instance_charge_type.setter # type: ignore
    def instance_charge_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceChargeType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceName")
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        return jsii.get(self, "instanceName")

    @instance_name.setter # type: ignore
    def instance_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetMaxBandwidthIn")
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        return jsii.get(self, "internetMaxBandwidthIn")

    @internet_max_bandwidth_in.setter # type: ignore
    def internet_max_bandwidth_in(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "internetMaxBandwidthIn", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="keyPairName")
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.
        """
        return jsii.get(self, "keyPairName")

    @key_pair_name.setter # type: ignore
    def key_pair_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "keyPairName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="loadBalancerIdToAttach")
    def load_balancer_id_to_attach(self) -> typing.Optional[builtins.str]:
        """
        :Property: loadBalancerIdToAttach: After the instance is created. Automatic attach it to the load balancer.
        """
        return jsii.get(self, "loadBalancerIdToAttach")

    @load_balancer_id_to_attach.setter # type: ignore
    def load_balancer_id_to_attach(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "loadBalancerIdToAttach", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="password")
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        return jsii.get(self, "password")

    @password.setter # type: ignore
    def password(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "password", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="period")
    def period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: period: Prepaid time period. Unit is month, it could be from 1 to 9 or 12, 24, 36, 48, 60. Default value is 1.
        """
        return jsii.get(self, "period")

    @period.setter # type: ignore
    def period(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "period", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ramRoleName")
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        return jsii.get(self, "ramRoleName")

    @ram_role_name.setter # type: ignore
    def ram_role_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ramRoleName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        return jsii.get(self, "resourceGroupId")

    @resource_group_id.setter # type: ignore
    def resource_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "resourceGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupId")
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        return jsii.get(self, "securityGroupId")

    @security_group_id.setter # type: ignore
    def security_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "securityGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="spotPriceLimit")
    def spot_price_limit(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotPriceLimit: The hourly price threshold of a instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Three decimals is allowed at most.
        """
        return jsii.get(self, "spotPriceLimit")

    @spot_price_limit.setter # type: ignore
    def spot_price_limit(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "spotPriceLimit", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="spotStrategy")
    def spot_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotStrategy: The spot strategy of a Pay-As-You-Go instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Value range: "NoSpot: A regular Pay-As-You-Go instance", "SpotWithPriceLimit: A price threshold for a spot instance, ""SpotAsPriceGo: A price that is based on the highest Pay-As-You-Go instance. "Default value: NoSpot.
        """
        return jsii.get(self, "spotStrategy")

    @spot_strategy.setter # type: ignore
    def spot_strategy(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "spotStrategy", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="zoneId")
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        return jsii.get(self, "zoneId")

    @zone_id.setter # type: ignore
    def zone_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "zoneId", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosInstanceClone.DiskMappingsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "size": "size",
            "category": "category",
            "description": "description",
            "device": "device",
            "disk_name": "diskName",
            "performance_level": "performanceLevel",
            "snapshot_id": "snapshotId",
        },
    )
    class DiskMappingsProperty:
        def __init__(
            self,
            *,
            size: builtins.str,
            category: typing.Optional[builtins.str] = None,
            description: typing.Optional[builtins.str] = None,
            device: typing.Optional[builtins.str] = None,
            disk_name: typing.Optional[builtins.str] = None,
            performance_level: typing.Optional[builtins.str] = None,
            snapshot_id: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param size: 
            :param category: 
            :param description: 
            :param device: 
            :param disk_name: 
            :param performance_level: 
            :param snapshot_id: 
            """
            self._values: typing.Dict[str, typing.Any] = {
                "size": size,
            }
            if category is not None:
                self._values["category"] = category
            if description is not None:
                self._values["description"] = description
            if device is not None:
                self._values["device"] = device
            if disk_name is not None:
                self._values["disk_name"] = disk_name
            if performance_level is not None:
                self._values["performance_level"] = performance_level
            if snapshot_id is not None:
                self._values["snapshot_id"] = snapshot_id

        @builtins.property
        def size(self) -> builtins.str:
            """
            :Property: size: The size of the volume, unit in GB.Value range: cloud: [5,2000], cloud_efficiency: [20,32768], cloud_ssd: [20,32768], cloud_essd: [20,32768], ephemeral_ssd: [5,800].The value should be equal to or greater than the specific snapshot.
            """
            result = self._values.get("size")
            assert result is not None, "Required property 'size' is missing"
            return result

        @builtins.property
        def category(self) -> typing.Optional[builtins.str]:
            """
            :Property: category: The volume type.Now support: cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd. Default is cloud_efficiency.
            """
            result = self._values.get("category")
            return result

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            """
            :Property: description: Description of the disk, [2, 256] characters. Do not fill or empty, the default is empty.
            """
            result = self._values.get("description")
            return result

        @builtins.property
        def device(self) -> typing.Optional[builtins.str]:
            """
            :Property: device: The device where the volume is exposed on the instance. could be /dev/xvd[a-z]. If not specification, will use default value.
            """
            result = self._values.get("device")
            return result

        @builtins.property
        def disk_name(self) -> typing.Optional[builtins.str]:
            """
            :Property: diskName: Display name of the disk, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.
            """
            result = self._values.get("disk_name")
            return result

        @builtins.property
        def performance_level(self) -> typing.Optional[builtins.str]:
            """
            :Property: performanceLevel: The performance level of the enhanced SSD used as the Nth data disk.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
            """
            result = self._values.get("performance_level")
            return result

        @builtins.property
        def snapshot_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: snapshotId: ID of the snapshot to create the volume.
            """
            result = self._values.get("snapshot_id")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DiskMappingsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosInstanceCloneProps",
    jsii_struct_bases=[],
    name_mapping={
        "source_instance_id": "sourceInstanceId",
        "backend_server_weight": "backendServerWeight",
        "deletion_protection": "deletionProtection",
        "description": "description",
        "disk_mappings": "diskMappings",
        "image_id": "imageId",
        "instance_charge_type": "instanceChargeType",
        "instance_name": "instanceName",
        "internet_max_bandwidth_in": "internetMaxBandwidthIn",
        "key_pair_name": "keyPairName",
        "load_balancer_id_to_attach": "loadBalancerIdToAttach",
        "password": "password",
        "period": "period",
        "ram_role_name": "ramRoleName",
        "resource_group_id": "resourceGroupId",
        "security_group_id": "securityGroupId",
        "spot_price_limit": "spotPriceLimit",
        "spot_strategy": "spotStrategy",
        "tags": "tags",
        "zone_id": "zoneId",
    },
)
class RosInstanceCloneProps:
    def __init__(
        self,
        *,
        source_instance_id: builtins.str,
        backend_server_weight: typing.Optional[jsii.Number] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        description: typing.Optional[builtins.str] = None,
        disk_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosInstanceClone.DiskMappingsProperty]]]] = None,
        image_id: typing.Optional[builtins.str] = None,
        instance_charge_type: typing.Optional[builtins.str] = None,
        instance_name: typing.Optional[builtins.str] = None,
        internet_max_bandwidth_in: typing.Optional[jsii.Number] = None,
        key_pair_name: typing.Optional[builtins.str] = None,
        load_balancer_id_to_attach: typing.Optional[builtins.str] = None,
        password: typing.Optional[builtins.str] = None,
        period: typing.Optional[jsii.Number] = None,
        ram_role_name: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        spot_price_limit: typing.Optional[builtins.str] = None,
        spot_strategy: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.List[ros_cdk_core.RosTag]] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::InstanceClone``.

        :param source_instance_id: 
        :param backend_server_weight: 
        :param deletion_protection: 
        :param description: 
        :param disk_mappings: 
        :param image_id: 
        :param instance_charge_type: 
        :param instance_name: 
        :param internet_max_bandwidth_in: 
        :param key_pair_name: 
        :param load_balancer_id_to_attach: 
        :param password: 
        :param period: 
        :param ram_role_name: 
        :param resource_group_id: 
        :param security_group_id: 
        :param spot_price_limit: 
        :param spot_strategy: 
        :param tags: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "source_instance_id": source_instance_id,
        }
        if backend_server_weight is not None:
            self._values["backend_server_weight"] = backend_server_weight
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if description is not None:
            self._values["description"] = description
        if disk_mappings is not None:
            self._values["disk_mappings"] = disk_mappings
        if image_id is not None:
            self._values["image_id"] = image_id
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if internet_max_bandwidth_in is not None:
            self._values["internet_max_bandwidth_in"] = internet_max_bandwidth_in
        if key_pair_name is not None:
            self._values["key_pair_name"] = key_pair_name
        if load_balancer_id_to_attach is not None:
            self._values["load_balancer_id_to_attach"] = load_balancer_id_to_attach
        if password is not None:
            self._values["password"] = password
        if period is not None:
            self._values["period"] = period
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if spot_price_limit is not None:
            self._values["spot_price_limit"] = spot_price_limit
        if spot_strategy is not None:
            self._values["spot_strategy"] = spot_strategy
        if tags is not None:
            self._values["tags"] = tags
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def source_instance_id(self) -> builtins.str:
        """
        :Property: sourceInstanceId: Source ecs instance used to copy properties to clone new ecs instance. It will copy the InstanceType, ImageId, InternetChargeType, InternetMaxBandwidthIn, InternetMaxBandwidthOut and the system disk and data disk configurations. If the instance network is VPC, it will also clone the relative properties. If specified instance with more than one security group, it will use the first security group to create instance. you can also specify the SecurityGroupId to override it.
        """
        result = self._values.get("source_instance_id")
        assert result is not None, "Required property 'source_instance_id' is missing"
        return result

    @builtins.property
    def backend_server_weight(self) -> typing.Optional[jsii.Number]:
        """
        :Property: backendServerWeight: The weight of backend server of load balancer. From 0 to 100, 0 means offline. Default is 100.
        """
        result = self._values.get("backend_server_weight")
        return result

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deletionProtection: Whether an instance can be released manually through the console or API, deletion protection only support postPaid instance
        """
        result = self._values.get("deletion_protection")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosInstanceClone.DiskMappingsProperty]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.
        """
        result = self._values.get("disk_mappings")
        return result

    @builtins.property
    def image_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        result = self._values.get("image_id")
        return result

    @builtins.property
    def instance_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceChargeType: Instance Charge type, allowed value: Prepaid and Postpaid. If specified Prepaid, please ensure you have sufficient balance in your account. Or instance creation will be failure. Default value is Postpaid.
        """
        result = self._values.get("instance_charge_type")
        return result

    @builtins.property
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("instance_name")
        return result

    @builtins.property
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        result = self._values.get("internet_max_bandwidth_in")
        return result

    @builtins.property
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.
        """
        result = self._values.get("key_pair_name")
        return result

    @builtins.property
    def load_balancer_id_to_attach(self) -> typing.Optional[builtins.str]:
        """
        :Property: loadBalancerIdToAttach: After the instance is created. Automatic attach it to the load balancer.
        """
        result = self._values.get("load_balancer_id_to_attach")
        return result

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        result = self._values.get("password")
        return result

    @builtins.property
    def period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: period: Prepaid time period. Unit is month, it could be from 1 to 9 or 12, 24, 36, 48, 60. Default value is 1.
        """
        result = self._values.get("period")
        return result

    @builtins.property
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        result = self._values.get("ram_role_name")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def spot_price_limit(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotPriceLimit: The hourly price threshold of a instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Three decimals is allowed at most.
        """
        result = self._values.get("spot_price_limit")
        return result

    @builtins.property
    def spot_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotStrategy: The spot strategy of a Pay-As-You-Go instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Value range: "NoSpot: A regular Pay-As-You-Go instance", "SpotWithPriceLimit: A price threshold for a spot instance, ""SpotAsPriceGo: A price that is based on the highest Pay-As-You-Go instance. "Default value: NoSpot.
        """
        result = self._values.get("spot_strategy")
        return result

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[ros_cdk_core.RosTag]]:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosInstanceCloneProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosInstanceGroup(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosInstanceGroup",
):
    """A ROS template type:  ``ALIYUN::ECS::InstanceGroup``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosInstanceGroupProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::InstanceGroup``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosInstanceGroup, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrHostNames")
    def attr_host_names(self) -> typing.Any:
        """
        :Attribute: HostNames: Host names of created instance.
        """
        return jsii.get(self, "attrHostNames")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInnerIps")
    def attr_inner_ips(self) -> typing.Any:
        """
        :Attribute: InnerIps: Inner IP address list of the specified instance. Only for classical instance.
        """
        return jsii.get(self, "attrInnerIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInstanceIds")
    def attr_instance_ids(self) -> typing.Any:
        """
        :Attribute: InstanceIds: The instance id list of created ecs instance
        """
        return jsii.get(self, "attrInstanceIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> typing.Any:
        """
        :Attribute: OrderId: The order id list of created instance.
        """
        return jsii.get(self, "attrOrderId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateIps")
    def attr_private_ips(self) -> typing.Any:
        """
        :Attribute: PrivateIps: Private IP address list of created ecs instance. Only for VPC instance.
        """
        return jsii.get(self, "attrPrivateIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPublicIps")
    def attr_public_ips(self) -> typing.Any:
        """
        :Attribute: PublicIps: Public IP address list of created ecs instance.
        """
        return jsii.get(self, "attrPublicIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrZoneIds")
    def attr_zone_ids(self) -> typing.Any:
        """
        :Attribute: ZoneIds: Zone id of created instance.
        """
        return jsii.get(self, "attrZoneIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="tags")
    def tags(self) -> ros_cdk_core.TagManager:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        return jsii.get(self, "tags")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="imageId")
    def image_id(self) -> builtins.str:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        return jsii.get(self, "imageId")

    @image_id.setter # type: ignore
    def image_id(self, value: builtins.str) -> None:
        jsii.set(self, "imageId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceType")
    def instance_type(self) -> builtins.str:
        """
        :Property: instanceType: Ecs instance supported instance type, make sure it should be correct.
        """
        return jsii.get(self, "instanceType")

    @instance_type.setter # type: ignore
    def instance_type(self, value: builtins.str) -> None:
        jsii.set(self, "instanceType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="maxAmount")
    def max_amount(self) -> jsii.Number:
        """
        :Property: maxAmount: Max number of instances to create, should be bigger than 'MinAmount' and smaller than 1000.
        """
        return jsii.get(self, "maxAmount")

    @max_amount.setter # type: ignore
    def max_amount(self, value: jsii.Number) -> None:
        jsii.set(self, "maxAmount", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="allocatePublicIp")
    def allocate_public_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: allocatePublicIp: The public ip for ecs instance, if properties is true, will allocate public ip. If property InternetMaxBandwidthOut set to 0, it will not assign public ip.
        """
        return jsii.get(self, "allocatePublicIp")

    @allocate_public_ip.setter # type: ignore
    def allocate_public_ip(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "allocatePublicIp", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoReleaseTime")
    def auto_release_time(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoReleaseTime: Auto release time for created instance, Follow ISO8601 standard using UTC time. format is 'yyyy-MM-ddTHH:mm:ssZ'. Not bigger than 3 years from this day onwards
        """
        return jsii.get(self, "autoReleaseTime")

    @auto_release_time.setter # type: ignore
    def auto_release_time(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "autoReleaseTime", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoRenew")
    def auto_renew(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoRenew: Whether renew the fee automatically? When the parameter InstanceChargeType is PrePaid, it will take effect. Range of value:True: automatic renewal.False: no automatic renewal. Default value is False.Old instances will not be changed.
        """
        return jsii.get(self, "autoRenew")

    @auto_renew.setter # type: ignore
    def auto_renew(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "autoRenew", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoRenewPeriod")
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.Old instances will not be changed.
        """
        return jsii.get(self, "autoRenewPeriod")

    @auto_renew_period.setter # type: ignore
    def auto_renew_period(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "autoRenewPeriod", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="dedicatedHostId")
    def dedicated_host_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: dedicatedHostId: which dedicated host will be deployed
        """
        return jsii.get(self, "dedicatedHostId")

    @dedicated_host_id.setter # type: ignore
    def dedicated_host_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "dedicatedHostId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="deletionProtection")
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deletionProtection: Whether an instance can be released manually through the console or API, deletion protection only support postPaid instance
        """
        return jsii.get(self, "deletionProtection")

    @deletion_protection.setter # type: ignore
    def deletion_protection(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "deletionProtection", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="deploymentSetId")
    def deployment_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: deploymentSetId: Deployment set ID. The change of the property does not affect existing instances.
        """
        return jsii.get(self, "deploymentSetId")

    @deployment_set_id.setter # type: ignore
    def deployment_set_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "deploymentSetId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty. Old instances will not be changed.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="diskMappings")
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceGroup.DiskMappingsProperty"]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.Old instances will not be changed.
        """
        return jsii.get(self, "diskMappings")

    @disk_mappings.setter # type: ignore
    def disk_mappings(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceGroup.DiskMappingsProperty"]]]],
    ) -> None:
        jsii.set(self, "diskMappings", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="eniMappings")
    def eni_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceGroup.EniMappingsProperty"]]]]:
        """
        :Property: eniMappings: NetworkInterface to attach to instance. Max support 1 ENI.
        """
        return jsii.get(self, "eniMappings")

    @eni_mappings.setter # type: ignore
    def eni_mappings(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceGroup.EniMappingsProperty"]]]],
    ) -> None:
        jsii.set(self, "eniMappings", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="hostName")
    def host_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        hostName: Host name of created ecs instance. at least 2 characters, and '.' '-' Is not the first and last characters as hostname, not continuous use. Windows platform can be up to 15 characters, allowing letters (without limiting case), numbers and '-', and does not support the number of points, not all is digital ('.').Other (Linux, etc.) platform up to 30 characters, allowing support number multiple points for the period between the points, each permit letters (without limiting case), numbers and '-' components.
        Support to use the regular expression to set the different instance name for each ECS instance. HostName could be specified as 'name_prefix[begin_number,bits]name_suffix', such as 'host[123,4]tail'. If you creates 3 instances with hostname 'host[123,4]tail', all the host names of instances are host0123tail, host0124tail, host0125tail. The 'name_prefix[begin_number,bits]name_suffix' should follow those rules:

        1. 'name_prefix' is required.
        2. 'name_suffix' is optional.
        3. The name regular expression can't include any spaces.
        4. The 'bits' must be in range [1, 6].
        5. The 'begin_number' must be in range [0, 999999].
        6. You could only specify 'begin_number'. The 'bits' will be set as 6 by default.
        7. You also could only specify the [] or [,]. The 'begin_number' will be set as 0 by default, the 'bits' will be set as 6 by default.
        8. If the bits of 'begin_number' is less than the 'bits' you specified, like [1234,1], the 'bits' will be set as 6 by default.
        The host name is specified by regular expression works after restart instance manually.
        """
        return jsii.get(self, "hostName")

    @host_name.setter # type: ignore
    def host_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "hostName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="hpcClusterId")
    def hpc_cluster_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.The change of the property does not affect existing instances.
        """
        return jsii.get(self, "hpcClusterId")

    @hpc_cluster_id.setter # type: ignore
    def hpc_cluster_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "hpcClusterId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceChargeType")
    def instance_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceChargeType: Instance Charge type, allowed value: Prepaid and Postpaid. If specified Prepaid, please ensure you have sufficient balance in your account. Or instance creation will be failure. Default value is Postpaid.Old instances will not be changed.
        """
        return jsii.get(self, "instanceChargeType")

    @instance_charge_type.setter # type: ignore
    def instance_charge_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceChargeType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceName")
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.
        Support to use the regular expression to set the different instance name for each ECS instance. InstanceName could be specified as 'name_prefix[begin_number,bits]name_suffix', such as 'testinstance[123,4]tail'. If you creates 3 instances with the instance name 'testinstance[123,4]tail', all the instances' names are testinstance0123tail, testinstance0124tail, testinstance0125tail.
        The 'name_prefix[begin_number,bits]name_suffix' should follow those rules:

        1. 'name_prefix' is required.
        2. 'name_suffix' is optional.
        3. The name regular expression can't include any spaces.
        4. The 'bits' must be in range [1, 6].
        5. The 'begin_number' must be in range [0, 999999].
        6. You could only specify 'begin_number'. The 'bits' will be set as 6 by default.
        7. You also could only specify the [] or [,]. The 'begin_number' will be set as 0 by default, the 'bits' will be set as 6 by default.
        8. If the bits of 'begin_number' is less than the 'bits' you specified, like [1234,1], the 'bits' will be set as 6 by default.
        """
        return jsii.get(self, "instanceName")

    @instance_name.setter # type: ignore
    def instance_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetChargeType")
    def internet_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: internetChargeType: Instance internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByTraffic
        """
        return jsii.get(self, "internetChargeType")

    @internet_charge_type.setter # type: ignore
    def internet_charge_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "internetChargeType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetMaxBandwidthIn")
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        return jsii.get(self, "internetMaxBandwidthIn")

    @internet_max_bandwidth_in.setter # type: ignore
    def internet_max_bandwidth_in(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "internetMaxBandwidthIn", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Set internet output bandwidth of instance. Unit is Mbps(Mega bit per second). Range is [0,200]. Default is 1.While the property is not 0, public ip will be assigned for instance.
        """
        return jsii.get(self, "internetMaxBandwidthOut")

    @internet_max_bandwidth_out.setter # type: ignore
    def internet_max_bandwidth_out(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "internetMaxBandwidthOut", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ioOptimized")
    def io_optimized(self) -> typing.Optional[builtins.str]:
        """
        :Property: ioOptimized: The 'optimized' instance can provide better IO performance. Support 'none' and 'optimized' only, default is 'optimized'.
        """
        return jsii.get(self, "ioOptimized")

    @io_optimized.setter # type: ignore
    def io_optimized(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ioOptimized", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ipv6AddressCount")
    def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        ipv6AddressCount: Specifies the number of randomly generated IPv6 addresses for the elastic NIC.
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        The change of the property does not affect existing instances.
        """
        return jsii.get(self, "ipv6AddressCount")

    @ipv6_address_count.setter # type: ignore
    def ipv6_address_count(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "ipv6AddressCount", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ipv6Addresses")
    def ipv6_addresses(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property:

        ipv6Addresses: Specify one or more IPv6 addresses for the elastic NIC. Currently, the maximum list size is 1. Example value: 2001:db8:1234:1a00::*** .
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        The change of the property does not affect existing instances.
        """
        return jsii.get(self, "ipv6Addresses")

    @ipv6_addresses.setter # type: ignore
    def ipv6_addresses(
        self,
        value: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "ipv6Addresses", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="keyPairName")
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.Old instances will not be changed.
        """
        return jsii.get(self, "keyPairName")

    @key_pair_name.setter # type: ignore
    def key_pair_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "keyPairName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="launchTemplateId")
    def launch_template_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateId: ID of launch template. Launch template id or name must be specified to use launch template
        """
        return jsii.get(self, "launchTemplateId")

    @launch_template_id.setter # type: ignore
    def launch_template_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "launchTemplateId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="launchTemplateName")
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateName: Name of launch template. Launch template id or name must be specified to use launch template
        """
        return jsii.get(self, "launchTemplateName")

    @launch_template_name.setter # type: ignore
    def launch_template_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "launchTemplateName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="launchTemplateVersion")
    def launch_template_version(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateVersion: Version of launch template. Default version is used if version is not specified.
        """
        return jsii.get(self, "launchTemplateVersion")

    @launch_template_version.setter # type: ignore
    def launch_template_version(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "launchTemplateVersion", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="networkType")
    def network_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: networkType: Instance network type. Support 'vpc' and 'classic', for compatible reason, default is 'classic'. If vswitch id and vpc id is specified, the property will be forced to be set to 'vpc'
        """
        return jsii.get(self, "networkType")

    @network_type.setter # type: ignore
    def network_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "networkType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="password")
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        return jsii.get(self, "password")

    @password.setter # type: ignore
    def password(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "password", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="passwordInherit")
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: passwordInherit: Specifies whether to use the password preset in the image. To use the PasswordInherit parameter, the Password parameter must be empty and you must make sure that the selected image has a password configured.
        """
        return jsii.get(self, "passwordInherit")

    @password_inherit.setter # type: ignore
    def password_inherit(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "passwordInherit", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="period")
    def period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: period: Prepaid time period. Unit is month, it could be from 1 to 9 or 12, 24, 36, 48, 60. Default value is 1.Old instances will not be changed.
        """
        return jsii.get(self, "period")

    @period.setter # type: ignore
    def period(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "period", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="periodUnit")
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month. Default value is Month.Old instances will not be changed.
        """
        return jsii.get(self, "periodUnit")

    @period_unit.setter # type: ignore
    def period_unit(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "periodUnit", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="privateIpAddress")
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        """
        :Property: privateIpAddress: Private IP for the instance created. Only works for VPC instance and cannot duplicated with existing instance.
        """
        return jsii.get(self, "privateIpAddress")

    @private_ip_address.setter # type: ignore
    def private_ip_address(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "privateIpAddress", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ramRoleName")
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        return jsii.get(self, "ramRoleName")

    @ram_role_name.setter # type: ignore
    def ram_role_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ramRoleName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        return jsii.get(self, "resourceGroupId")

    @resource_group_id.setter # type: ignore
    def resource_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "resourceGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityEnhancementStrategy")
    def security_enhancement_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityEnhancementStrategy:
        """
        return jsii.get(self, "securityEnhancementStrategy")

    @security_enhancement_strategy.setter # type: ignore
    def security_enhancement_strategy(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "securityEnhancementStrategy", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupId")
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        return jsii.get(self, "securityGroupId")

    @security_group_id.setter # type: ignore
    def security_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "securityGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupIds")
    def security_group_ids(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property: securityGroupIds: The IDs of security groups N to which the instance belongs. The valid values of N are based on the maximum number of security groups to which an instance can belong. For more information, see Security group limits.Note: You cannot specify both SecurityGroupId and SecurityGroupIds at the same time.
        """
        return jsii.get(self, "securityGroupIds")

    @security_group_ids.setter # type: ignore
    def security_group_ids(
        self,
        value: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "securityGroupIds", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="spotPriceLimit")
    def spot_price_limit(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotPriceLimit: The hourly price threshold of a instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Three decimals is allowed at most.
        """
        return jsii.get(self, "spotPriceLimit")

    @spot_price_limit.setter # type: ignore
    def spot_price_limit(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "spotPriceLimit", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="spotStrategy")
    def spot_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotStrategy: The spot strategy of a Pay-As-You-Go instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Value range: "NoSpot: A regular Pay-As-You-Go instance", "SpotWithPriceLimit: A price threshold for a spot instance, ""SpotAsPriceGo: A price that is based on the highest Pay-As-You-Go instance. "Default value: NoSpot.
        """
        return jsii.get(self, "spotStrategy")

    @spot_strategy.setter # type: ignore
    def spot_strategy(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "spotStrategy", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskAutoSnapshotPolicyId")
    def system_disk_auto_snapshot_policy_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskAutoSnapshotPolicyId: Auto snapshot policy ID.
        """
        return jsii.get(self, "systemDiskAutoSnapshotPolicyId")

    @system_disk_auto_snapshot_policy_id.setter # type: ignore
    def system_disk_auto_snapshot_policy_id(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "systemDiskAutoSnapshotPolicyId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskCategory")
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. Default is cloud_efficiency. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd.Old instances will not be changed.
        """
        return jsii.get(self, "systemDiskCategory")

    @system_disk_category.setter # type: ignore
    def system_disk_category(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskCategory", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskDescription")
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.Old instances will not be changed.
        """
        return jsii.get(self, "systemDiskDescription")

    @system_disk_description.setter # type: ignore
    def system_disk_description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskDescription", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskDiskName")
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.Old instances will not be changed.
        """
        return jsii.get(self, "systemDiskDiskName")

    @system_disk_disk_name.setter # type: ignore
    def system_disk_disk_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskDiskName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskPerformanceLevel")
    def system_disk_performance_level(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskPerformanceLevel: The performance level of the enhanced SSD used as the system disk.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
        """
        return jsii.get(self, "systemDiskPerformanceLevel")

    @system_disk_performance_level.setter # type: ignore
    def system_disk_performance_level(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "systemDiskPerformanceLevel", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskSize")
    def system_disk_size(self) -> typing.Optional[jsii.Number]:
        """
        :Property: systemDiskSize: Disk size of the system disk, range from 20 to 500 GB. If you specify with your own image, make sure the system disk size bigger than image size.
        """
        return jsii.get(self, "systemDiskSize")

    @system_disk_size.setter # type: ignore
    def system_disk_size(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "systemDiskSize", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="userData")
    def user_data(self) -> typing.Optional[builtins.str]:
        """
        :Property: userData: User data to pass to instance. [1, 16KB] characters.User data should not be base64 encoded. If you want to pass base64 encoded string to the property, use function Fn::Base64Decode to decode the base64 string first.
        """
        return jsii.get(self, "userData")

    @user_data.setter # type: ignore
    def user_data(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "userData", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcId: The VPC id to create ecs instance.
        """
        return jsii.get(self, "vpcId")

    @vpc_id.setter # type: ignore
    def vpc_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vpcId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="vSwitchId")
    def v_switch_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vSwitchId: The vSwitch Id to create ecs instance.
        """
        return jsii.get(self, "vSwitchId")

    @v_switch_id.setter # type: ignore
    def v_switch_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vSwitchId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="zoneId")
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        return jsii.get(self, "zoneId")

    @zone_id.setter # type: ignore
    def zone_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "zoneId", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosInstanceGroup.DiskMappingsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "size": "size",
            "auto_snapshot_policy_id": "autoSnapshotPolicyId",
            "category": "category",
            "description": "description",
            "device": "device",
            "disk_name": "diskName",
            "encrypted": "encrypted",
            "kms_key_id": "kmsKeyId",
            "performance_level": "performanceLevel",
            "snapshot_id": "snapshotId",
        },
    )
    class DiskMappingsProperty:
        def __init__(
            self,
            *,
            size: builtins.str,
            auto_snapshot_policy_id: typing.Optional[builtins.str] = None,
            category: typing.Optional[builtins.str] = None,
            description: typing.Optional[builtins.str] = None,
            device: typing.Optional[builtins.str] = None,
            disk_name: typing.Optional[builtins.str] = None,
            encrypted: typing.Optional[builtins.str] = None,
            kms_key_id: typing.Optional[builtins.str] = None,
            performance_level: typing.Optional[builtins.str] = None,
            snapshot_id: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param size: 
            :param auto_snapshot_policy_id: 
            :param category: 
            :param description: 
            :param device: 
            :param disk_name: 
            :param encrypted: 
            :param kms_key_id: 
            :param performance_level: 
            :param snapshot_id: 
            """
            self._values: typing.Dict[str, typing.Any] = {
                "size": size,
            }
            if auto_snapshot_policy_id is not None:
                self._values["auto_snapshot_policy_id"] = auto_snapshot_policy_id
            if category is not None:
                self._values["category"] = category
            if description is not None:
                self._values["description"] = description
            if device is not None:
                self._values["device"] = device
            if disk_name is not None:
                self._values["disk_name"] = disk_name
            if encrypted is not None:
                self._values["encrypted"] = encrypted
            if kms_key_id is not None:
                self._values["kms_key_id"] = kms_key_id
            if performance_level is not None:
                self._values["performance_level"] = performance_level
            if snapshot_id is not None:
                self._values["snapshot_id"] = snapshot_id

        @builtins.property
        def size(self) -> builtins.str:
            """
            :Property: size: The size of the volume, unit in GB.Value range: cloud: [5,2000], cloud_efficiency: [20,32768], cloud_ssd: [20,32768], cloud_essd: [20,32768], ephemeral_ssd: [5,800].The value should be equal to or greater than the specific snapshot.
            """
            result = self._values.get("size")
            assert result is not None, "Required property 'size' is missing"
            return result

        @builtins.property
        def auto_snapshot_policy_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: autoSnapshotPolicyId: Auto snapshot policy ID.
            """
            result = self._values.get("auto_snapshot_policy_id")
            return result

        @builtins.property
        def category(self) -> typing.Optional[builtins.str]:
            """
            :Property: category: The volume type.Now support: cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd. Default is cloud_efficiency.
            """
            result = self._values.get("category")
            return result

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            """
            :Property: description: Description of the disk, [2, 256] characters. Do not fill or empty, the default is empty.
            """
            result = self._values.get("description")
            return result

        @builtins.property
        def device(self) -> typing.Optional[builtins.str]:
            """
            :Property: device: The device where the volume is exposed on the instance. could be /dev/xvd[a-z]. If not specification, will use default value.
            """
            result = self._values.get("device")
            return result

        @builtins.property
        def disk_name(self) -> typing.Optional[builtins.str]:
            """
            :Property: diskName: Display name of the disk, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.
            """
            result = self._values.get("disk_name")
            return result

        @builtins.property
        def encrypted(self) -> typing.Optional[builtins.str]:
            """
            :Property:

            encrypted: Whether the data disk is encrypted or not. Options:
            true: Encrypted.
            false: Not encrypted.
            Default value: false.
            """
            result = self._values.get("encrypted")
            return result

        @builtins.property
        def kms_key_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: kmsKeyId: The KMS key ID for the data disk.
            """
            result = self._values.get("kms_key_id")
            return result

        @builtins.property
        def performance_level(self) -> typing.Optional[builtins.str]:
            """
            :Property: performanceLevel: The performance level of the enhanced SSD used as the Nth data disk.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
            """
            result = self._values.get("performance_level")
            return result

        @builtins.property
        def snapshot_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: snapshotId: ID of the snapshot to create the volume.
            """
            result = self._values.get("snapshot_id")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DiskMappingsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosInstanceGroup.EniMappingsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "security_group_id": "securityGroupId",
            "v_switch_id": "vSwitchId",
            "description": "description",
            "network_interface_name": "networkInterfaceName",
            "primary_ip_address": "primaryIpAddress",
        },
    )
    class EniMappingsProperty:
        def __init__(
            self,
            *,
            security_group_id: builtins.str,
            v_switch_id: builtins.str,
            description: typing.Optional[builtins.str] = None,
            network_interface_name: typing.Optional[builtins.str] = None,
            primary_ip_address: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param security_group_id: 
            :param v_switch_id: 
            :param description: 
            :param network_interface_name: 
            :param primary_ip_address: 
            """
            self._values: typing.Dict[str, typing.Any] = {
                "security_group_id": security_group_id,
                "v_switch_id": v_switch_id,
            }
            if description is not None:
                self._values["description"] = description
            if network_interface_name is not None:
                self._values["network_interface_name"] = network_interface_name
            if primary_ip_address is not None:
                self._values["primary_ip_address"] = primary_ip_address

        @builtins.property
        def security_group_id(self) -> builtins.str:
            """
            :Property: securityGroupId: The ID of the security group that the ENI joins. The security group and the ENI must be in a same VPC.
            """
            result = self._values.get("security_group_id")
            assert result is not None, "Required property 'security_group_id' is missing"
            return result

        @builtins.property
        def v_switch_id(self) -> builtins.str:
            """
            :Property: vSwitchId: VSwitch ID of the specified VPC. Specifies the switch ID for the VPC.
            """
            result = self._values.get("v_switch_id")
            assert result is not None, "Required property 'v_switch_id' is missing"
            return result

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            """
            :Property: description: Description of your ENI. It is a string of [2, 256] English or Chinese characters.
            """
            result = self._values.get("description")
            return result

        @builtins.property
        def network_interface_name(self) -> typing.Optional[builtins.str]:
            """
            :Property: networkInterfaceName: Name of your ENI. It is a string of [2, 128]  Chinese or English characters. It must begin with a letter and can contain numbers, underscores (_), colons (:), or hyphens (-).
            """
            result = self._values.get("network_interface_name")
            return result

        @builtins.property
        def primary_ip_address(self) -> typing.Optional[builtins.str]:
            """
            :Property: primaryIpAddress: The primary private IP address of the ENI.  The specified IP address must have the same Host ID as the VSwitch. If no IP addresses are specified, a random network ID is assigned for the ENI.
            """
            result = self._values.get("primary_ip_address")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EniMappingsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


class RosInstanceGroupClone(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosInstanceGroupClone",
):
    """A ROS template type:  ``ALIYUN::ECS::InstanceGroupClone``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosInstanceGroupCloneProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::InstanceGroupClone``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosInstanceGroupClone, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrHostNames")
    def attr_host_names(self) -> typing.Any:
        """
        :Attribute: HostNames: Host names of created instance.
        """
        return jsii.get(self, "attrHostNames")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInnerIps")
    def attr_inner_ips(self) -> typing.Any:
        """
        :Attribute: InnerIps: Inner IP address list of the specified instance. Only for classical instance.
        """
        return jsii.get(self, "attrInnerIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInstanceIds")
    def attr_instance_ids(self) -> typing.Any:
        """
        :Attribute: InstanceIds: The instance id list of created ecs instance
        """
        return jsii.get(self, "attrInstanceIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> typing.Any:
        """
        :Attribute: OrderId: The order id list of created instance.
        """
        return jsii.get(self, "attrOrderId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateIps")
    def attr_private_ips(self) -> typing.Any:
        """
        :Attribute: PrivateIps: Private IP address list of created ecs instance. Only for VPC instance.
        """
        return jsii.get(self, "attrPrivateIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPublicIps")
    def attr_public_ips(self) -> typing.Any:
        """
        :Attribute: PublicIps: Public IP address list of created ecs instance.
        """
        return jsii.get(self, "attrPublicIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrZoneIds")
    def attr_zone_ids(self) -> typing.Any:
        """
        :Attribute: ZoneIds: Zone id of created instance.
        """
        return jsii.get(self, "attrZoneIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="tags")
    def tags(self) -> ros_cdk_core.TagManager:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        return jsii.get(self, "tags")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="maxAmount")
    def max_amount(self) -> jsii.Number:
        """
        :Property: maxAmount: Max number of instances to create, should be bigger than 'MinAmount' and smaller than 1000.
        """
        return jsii.get(self, "maxAmount")

    @max_amount.setter # type: ignore
    def max_amount(self, value: jsii.Number) -> None:
        jsii.set(self, "maxAmount", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="sourceInstanceId")
    def source_instance_id(self) -> builtins.str:
        """
        :Property: sourceInstanceId: Source ecs instance used to copy properties to clone new ecs instance. It will copy the InstanceType, ImageId, InternetChargeType, InternetMaxBandwidthIn, InternetMaxBandwidthOut and the system disk and data disk configurations. If the instance network is VPC, it will also clone the relative properties. If specified instance with more than one security group, it will use the first security group to create instance. you can also specify the SecurityGroupId to override it.
        """
        return jsii.get(self, "sourceInstanceId")

    @source_instance_id.setter # type: ignore
    def source_instance_id(self, value: builtins.str) -> None:
        jsii.set(self, "sourceInstanceId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoReleaseTime")
    def auto_release_time(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoReleaseTime: Auto release time for created instance, Follow ISO8601 standard using UTC time. format is 'yyyy-MM-ddTHH:mm:ssZ'. Not bigger than 3 years from this day onwards
        """
        return jsii.get(self, "autoReleaseTime")

    @auto_release_time.setter # type: ignore
    def auto_release_time(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "autoReleaseTime", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoRenew")
    def auto_renew(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoRenew: Whether renew the fee automatically? When the parameter InstanceChargeType is PrePaid, it will take effect. Range of value:True: automatic renewal.False: no automatic renewal. Default value is False.Old instances will not be changed.
        """
        return jsii.get(self, "autoRenew")

    @auto_renew.setter # type: ignore
    def auto_renew(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "autoRenew", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoRenewPeriod")
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.Old instances will not be changed.
        """
        return jsii.get(self, "autoRenewPeriod")

    @auto_renew_period.setter # type: ignore
    def auto_renew_period(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "autoRenewPeriod", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="backendServerWeight")
    def backend_server_weight(self) -> typing.Optional[jsii.Number]:
        """
        :Property: backendServerWeight: The weight of backend server of load balancer. From 0 to 100, 0 means offline. Default is 100.
        """
        return jsii.get(self, "backendServerWeight")

    @backend_server_weight.setter # type: ignore
    def backend_server_weight(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "backendServerWeight", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="deletionProtection")
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deletionProtection: Whether an instance can be released manually through the console or API, deletion protection only support postPaid instance
        """
        return jsii.get(self, "deletionProtection")

    @deletion_protection.setter # type: ignore
    def deletion_protection(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "deletionProtection", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="deploymentSetId")
    def deployment_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: deploymentSetId: Deployment set ID. The change of the property does not affect existing instances.
        """
        return jsii.get(self, "deploymentSetId")

    @deployment_set_id.setter # type: ignore
    def deployment_set_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "deploymentSetId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty. Old instances will not be changed.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="diskMappings")
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceGroupClone.DiskMappingsProperty"]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.Old instances will not be changed.
        """
        return jsii.get(self, "diskMappings")

    @disk_mappings.setter # type: ignore
    def disk_mappings(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceGroupClone.DiskMappingsProperty"]]]],
    ) -> None:
        jsii.set(self, "diskMappings", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="eniMappings")
    def eni_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceGroupClone.EniMappingsProperty"]]]]:
        """
        :Property: eniMappings: NetworkInterface to attach to instance. Max support 1 ENI.
        """
        return jsii.get(self, "eniMappings")

    @eni_mappings.setter # type: ignore
    def eni_mappings(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosInstanceGroupClone.EniMappingsProperty"]]]],
    ) -> None:
        jsii.set(self, "eniMappings", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="hpcClusterId")
    def hpc_cluster_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.The change of the property does not affect existing instances.
        """
        return jsii.get(self, "hpcClusterId")

    @hpc_cluster_id.setter # type: ignore
    def hpc_cluster_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "hpcClusterId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="imageId")
    def image_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        return jsii.get(self, "imageId")

    @image_id.setter # type: ignore
    def image_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "imageId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceName")
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.
        Support to use the regular expression to set the different instance name for each ECS instance. InstanceName could be specified as 'name_prefix[begin_number,bits]name_suffix', such as 'testinstance[123,4]tail'. If you creates 3 instances with the instance name 'testinstance[123,4]tail', all the instances' names are testinstance0123tail, testinstance0124tail, testinstance0125tail.
        The 'name_prefix[begin_number,bits]name_suffix' should follow those rules:

        1. 'name_prefix' is required.
        2. 'name_suffix' is optional.
        3. The name regular expression can't include any spaces.
        4. The 'bits' must be in range [1, 6].
        5. The 'begin_number' must be in range [0, 999999].
        6. You could only specify 'begin_number'. The 'bits' will be set as 6 by default.
        7. You also could only specify the [] or [,]. The 'begin_number' will be set as 0 by default, the 'bits' will be set as 6 by default.
        8. If the bits of 'begin_number' is less than the 'bits' you specified, like [1234,1], the 'bits' will be set as 6 by default.
        """
        return jsii.get(self, "instanceName")

    @instance_name.setter # type: ignore
    def instance_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetMaxBandwidthIn")
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        return jsii.get(self, "internetMaxBandwidthIn")

    @internet_max_bandwidth_in.setter # type: ignore
    def internet_max_bandwidth_in(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "internetMaxBandwidthIn", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Set internet output bandwidth of instance. Unit is Mbps(Mega bit per second). Range is [0,200]. Default is 1.While the property is not 0, public ip will be assigned for instance.
        """
        return jsii.get(self, "internetMaxBandwidthOut")

    @internet_max_bandwidth_out.setter # type: ignore
    def internet_max_bandwidth_out(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "internetMaxBandwidthOut", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ipv6AddressCount")
    def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        ipv6AddressCount: Specifies the number of randomly generated IPv6 addresses for the elastic NIC.
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        The change of the property does not affect existing instances.
        """
        return jsii.get(self, "ipv6AddressCount")

    @ipv6_address_count.setter # type: ignore
    def ipv6_address_count(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "ipv6AddressCount", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ipv6Addresses")
    def ipv6_addresses(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property:

        ipv6Addresses: Specify one or more IPv6 addresses for the elastic NIC. Currently, the maximum list size is 1. Example value: 2001:db8:1234:1a00::*** .
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        The change of the property does not affect existing instances.
        """
        return jsii.get(self, "ipv6Addresses")

    @ipv6_addresses.setter # type: ignore
    def ipv6_addresses(
        self,
        value: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "ipv6Addresses", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="keyPairName")
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.Old instances will not be changed.
        """
        return jsii.get(self, "keyPairName")

    @key_pair_name.setter # type: ignore
    def key_pair_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "keyPairName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="launchTemplateId")
    def launch_template_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateId: ID of launch template. Launch template id or name must be specified to use launch template
        """
        return jsii.get(self, "launchTemplateId")

    @launch_template_id.setter # type: ignore
    def launch_template_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "launchTemplateId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="launchTemplateName")
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateName: Name of launch template. Launch template id or name must be specified to use launch template
        """
        return jsii.get(self, "launchTemplateName")

    @launch_template_name.setter # type: ignore
    def launch_template_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "launchTemplateName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="launchTemplateVersion")
    def launch_template_version(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateVersion: Version of launch template. Default version is used if version is not specified.
        """
        return jsii.get(self, "launchTemplateVersion")

    @launch_template_version.setter # type: ignore
    def launch_template_version(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "launchTemplateVersion", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="loadBalancerIdToAttach")
    def load_balancer_id_to_attach(self) -> typing.Optional[builtins.str]:
        """
        :Property: loadBalancerIdToAttach: After the instance is created. Automatic attach it to the load balancer.
        """
        return jsii.get(self, "loadBalancerIdToAttach")

    @load_balancer_id_to_attach.setter # type: ignore
    def load_balancer_id_to_attach(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "loadBalancerIdToAttach", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="password")
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        return jsii.get(self, "password")

    @password.setter # type: ignore
    def password(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "password", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="passwordInherit")
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: passwordInherit: Specifies whether to use the password preset in the image. To use the PasswordInherit parameter, the Password parameter must be empty and you must make sure that the selected image has a password configured.
        """
        return jsii.get(self, "passwordInherit")

    @password_inherit.setter # type: ignore
    def password_inherit(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "passwordInherit", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="period")
    def period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: period: Prepaid time period. Unit is month, it could be from 1 to 9 or 12, 24, 36, 48, 60. Default value is 1.Old instances will not be changed.
        """
        return jsii.get(self, "period")

    @period.setter # type: ignore
    def period(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "period", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="periodUnit")
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month. Default value is Month.Old instances will not be changed.
        """
        return jsii.get(self, "periodUnit")

    @period_unit.setter # type: ignore
    def period_unit(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "periodUnit", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ramRoleName")
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        return jsii.get(self, "ramRoleName")

    @ram_role_name.setter # type: ignore
    def ram_role_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ramRoleName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        return jsii.get(self, "resourceGroupId")

    @resource_group_id.setter # type: ignore
    def resource_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "resourceGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupId")
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        return jsii.get(self, "securityGroupId")

    @security_group_id.setter # type: ignore
    def security_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "securityGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupIds")
    def security_group_ids(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property: securityGroupIds: The IDs of security groups N to which the instance belongs. The valid values of N are based on the maximum number of security groups to which an instance can belong. For more information, see Security group limits.Note: You cannot specify both SecurityGroupId and SecurityGroupIds at the same time.
        """
        return jsii.get(self, "securityGroupIds")

    @security_group_ids.setter # type: ignore
    def security_group_ids(
        self,
        value: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "securityGroupIds", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="spotPriceLimit")
    def spot_price_limit(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotPriceLimit: The hourly price threshold of a instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Three decimals is allowed at most.
        """
        return jsii.get(self, "spotPriceLimit")

    @spot_price_limit.setter # type: ignore
    def spot_price_limit(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "spotPriceLimit", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="spotStrategy")
    def spot_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotStrategy: The spot strategy of a Pay-As-You-Go instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Value range: "NoSpot: A regular Pay-As-You-Go instance", "SpotWithPriceLimit: A price threshold for a spot instance, ""SpotAsPriceGo: A price that is based on the highest Pay-As-You-Go instance. "Default value: NoSpot.
        """
        return jsii.get(self, "spotStrategy")

    @spot_strategy.setter # type: ignore
    def spot_strategy(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "spotStrategy", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskAutoSnapshotPolicyId")
    def system_disk_auto_snapshot_policy_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskAutoSnapshotPolicyId: Auto snapshot policy ID.
        """
        return jsii.get(self, "systemDiskAutoSnapshotPolicyId")

    @system_disk_auto_snapshot_policy_id.setter # type: ignore
    def system_disk_auto_snapshot_policy_id(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "systemDiskAutoSnapshotPolicyId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskCategory")
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. Default is cloud_efficiency. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd.Old instances will not be changed.
        """
        return jsii.get(self, "systemDiskCategory")

    @system_disk_category.setter # type: ignore
    def system_disk_category(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskCategory", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskDescription")
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.Old instances will not be changed.
        """
        return jsii.get(self, "systemDiskDescription")

    @system_disk_description.setter # type: ignore
    def system_disk_description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskDescription", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskDiskName")
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.Old instances will not be changed.
        """
        return jsii.get(self, "systemDiskDiskName")

    @system_disk_disk_name.setter # type: ignore
    def system_disk_disk_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskDiskName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="zoneId")
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        return jsii.get(self, "zoneId")

    @zone_id.setter # type: ignore
    def zone_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "zoneId", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosInstanceGroupClone.DiskMappingsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "size": "size",
            "auto_snapshot_policy_id": "autoSnapshotPolicyId",
            "category": "category",
            "description": "description",
            "device": "device",
            "disk_name": "diskName",
            "encrypted": "encrypted",
            "kms_key_id": "kmsKeyId",
            "performance_level": "performanceLevel",
            "snapshot_id": "snapshotId",
        },
    )
    class DiskMappingsProperty:
        def __init__(
            self,
            *,
            size: builtins.str,
            auto_snapshot_policy_id: typing.Optional[builtins.str] = None,
            category: typing.Optional[builtins.str] = None,
            description: typing.Optional[builtins.str] = None,
            device: typing.Optional[builtins.str] = None,
            disk_name: typing.Optional[builtins.str] = None,
            encrypted: typing.Optional[builtins.str] = None,
            kms_key_id: typing.Optional[builtins.str] = None,
            performance_level: typing.Optional[builtins.str] = None,
            snapshot_id: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param size: 
            :param auto_snapshot_policy_id: 
            :param category: 
            :param description: 
            :param device: 
            :param disk_name: 
            :param encrypted: 
            :param kms_key_id: 
            :param performance_level: 
            :param snapshot_id: 
            """
            self._values: typing.Dict[str, typing.Any] = {
                "size": size,
            }
            if auto_snapshot_policy_id is not None:
                self._values["auto_snapshot_policy_id"] = auto_snapshot_policy_id
            if category is not None:
                self._values["category"] = category
            if description is not None:
                self._values["description"] = description
            if device is not None:
                self._values["device"] = device
            if disk_name is not None:
                self._values["disk_name"] = disk_name
            if encrypted is not None:
                self._values["encrypted"] = encrypted
            if kms_key_id is not None:
                self._values["kms_key_id"] = kms_key_id
            if performance_level is not None:
                self._values["performance_level"] = performance_level
            if snapshot_id is not None:
                self._values["snapshot_id"] = snapshot_id

        @builtins.property
        def size(self) -> builtins.str:
            """
            :Property: size: The size of the volume, unit in GB.Value range: cloud: [5,2000], cloud_efficiency: [20,32768], cloud_ssd: [20,32768], cloud_essd: [20,32768], ephemeral_ssd: [5,800].The value should be equal to or greater than the specific snapshot.
            """
            result = self._values.get("size")
            assert result is not None, "Required property 'size' is missing"
            return result

        @builtins.property
        def auto_snapshot_policy_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: autoSnapshotPolicyId: Auto snapshot policy ID.
            """
            result = self._values.get("auto_snapshot_policy_id")
            return result

        @builtins.property
        def category(self) -> typing.Optional[builtins.str]:
            """
            :Property: category: The volume type.Now support: cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd. Default is cloud_efficiency.
            """
            result = self._values.get("category")
            return result

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            """
            :Property: description: Description of the disk, [2, 256] characters. Do not fill or empty, the default is empty.
            """
            result = self._values.get("description")
            return result

        @builtins.property
        def device(self) -> typing.Optional[builtins.str]:
            """
            :Property: device: The device where the volume is exposed on the instance. could be /dev/xvd[a-z]. If not specification, will use default value.
            """
            result = self._values.get("device")
            return result

        @builtins.property
        def disk_name(self) -> typing.Optional[builtins.str]:
            """
            :Property: diskName: Display name of the disk, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.
            """
            result = self._values.get("disk_name")
            return result

        @builtins.property
        def encrypted(self) -> typing.Optional[builtins.str]:
            """
            :Property:

            encrypted: Whether the data disk is encrypted or not. Options:
            true: Encrypted.
            false: Not encrypted.
            Default value: false.
            """
            result = self._values.get("encrypted")
            return result

        @builtins.property
        def kms_key_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: kmsKeyId: The KMS key ID for the data disk.
            """
            result = self._values.get("kms_key_id")
            return result

        @builtins.property
        def performance_level(self) -> typing.Optional[builtins.str]:
            """
            :Property: performanceLevel: The performance level of the enhanced SSD used as the Nth data disk.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
            """
            result = self._values.get("performance_level")
            return result

        @builtins.property
        def snapshot_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: snapshotId: ID of the snapshot to create the volume.
            """
            result = self._values.get("snapshot_id")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DiskMappingsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosInstanceGroupClone.EniMappingsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "security_group_id": "securityGroupId",
            "v_switch_id": "vSwitchId",
            "description": "description",
            "network_interface_name": "networkInterfaceName",
            "primary_ip_address": "primaryIpAddress",
        },
    )
    class EniMappingsProperty:
        def __init__(
            self,
            *,
            security_group_id: builtins.str,
            v_switch_id: builtins.str,
            description: typing.Optional[builtins.str] = None,
            network_interface_name: typing.Optional[builtins.str] = None,
            primary_ip_address: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param security_group_id: 
            :param v_switch_id: 
            :param description: 
            :param network_interface_name: 
            :param primary_ip_address: 
            """
            self._values: typing.Dict[str, typing.Any] = {
                "security_group_id": security_group_id,
                "v_switch_id": v_switch_id,
            }
            if description is not None:
                self._values["description"] = description
            if network_interface_name is not None:
                self._values["network_interface_name"] = network_interface_name
            if primary_ip_address is not None:
                self._values["primary_ip_address"] = primary_ip_address

        @builtins.property
        def security_group_id(self) -> builtins.str:
            """
            :Property: securityGroupId: The ID of the security group that the ENI joins. The security group and the ENI must be in a same VPC.
            """
            result = self._values.get("security_group_id")
            assert result is not None, "Required property 'security_group_id' is missing"
            return result

        @builtins.property
        def v_switch_id(self) -> builtins.str:
            """
            :Property: vSwitchId: VSwitch ID of the specified VPC. Specifies the switch ID for the VPC.
            """
            result = self._values.get("v_switch_id")
            assert result is not None, "Required property 'v_switch_id' is missing"
            return result

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            """
            :Property: description: Description of your ENI. It is a string of [2, 256] English or Chinese characters.
            """
            result = self._values.get("description")
            return result

        @builtins.property
        def network_interface_name(self) -> typing.Optional[builtins.str]:
            """
            :Property: networkInterfaceName: Name of your ENI. It is a string of [2, 128]  Chinese or English characters. It must begin with a letter and can contain numbers, underscores (_), colons (:), or hyphens (-).
            """
            result = self._values.get("network_interface_name")
            return result

        @builtins.property
        def primary_ip_address(self) -> typing.Optional[builtins.str]:
            """
            :Property: primaryIpAddress: The primary private IP address of the ENI.  The specified IP address must have the same Host ID as the VSwitch. If no IP addresses are specified, a random network ID is assigned for the ENI.
            """
            result = self._values.get("primary_ip_address")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EniMappingsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosInstanceGroupCloneProps",
    jsii_struct_bases=[],
    name_mapping={
        "max_amount": "maxAmount",
        "source_instance_id": "sourceInstanceId",
        "auto_release_time": "autoReleaseTime",
        "auto_renew": "autoRenew",
        "auto_renew_period": "autoRenewPeriod",
        "backend_server_weight": "backendServerWeight",
        "deletion_protection": "deletionProtection",
        "deployment_set_id": "deploymentSetId",
        "description": "description",
        "disk_mappings": "diskMappings",
        "eni_mappings": "eniMappings",
        "hpc_cluster_id": "hpcClusterId",
        "image_id": "imageId",
        "instance_name": "instanceName",
        "internet_max_bandwidth_in": "internetMaxBandwidthIn",
        "internet_max_bandwidth_out": "internetMaxBandwidthOut",
        "ipv6_address_count": "ipv6AddressCount",
        "ipv6_addresses": "ipv6Addresses",
        "key_pair_name": "keyPairName",
        "launch_template_id": "launchTemplateId",
        "launch_template_name": "launchTemplateName",
        "launch_template_version": "launchTemplateVersion",
        "load_balancer_id_to_attach": "loadBalancerIdToAttach",
        "password": "password",
        "password_inherit": "passwordInherit",
        "period": "period",
        "period_unit": "periodUnit",
        "ram_role_name": "ramRoleName",
        "resource_group_id": "resourceGroupId",
        "security_group_id": "securityGroupId",
        "security_group_ids": "securityGroupIds",
        "spot_price_limit": "spotPriceLimit",
        "spot_strategy": "spotStrategy",
        "system_disk_auto_snapshot_policy_id": "systemDiskAutoSnapshotPolicyId",
        "system_disk_category": "systemDiskCategory",
        "system_disk_description": "systemDiskDescription",
        "system_disk_disk_name": "systemDiskDiskName",
        "tags": "tags",
        "zone_id": "zoneId",
    },
)
class RosInstanceGroupCloneProps:
    def __init__(
        self,
        *,
        max_amount: jsii.Number,
        source_instance_id: builtins.str,
        auto_release_time: typing.Optional[builtins.str] = None,
        auto_renew: typing.Optional[builtins.str] = None,
        auto_renew_period: typing.Optional[jsii.Number] = None,
        backend_server_weight: typing.Optional[jsii.Number] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        deployment_set_id: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        disk_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosInstanceGroupClone.DiskMappingsProperty]]]] = None,
        eni_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosInstanceGroupClone.EniMappingsProperty]]]] = None,
        hpc_cluster_id: typing.Optional[builtins.str] = None,
        image_id: typing.Optional[builtins.str] = None,
        instance_name: typing.Optional[builtins.str] = None,
        internet_max_bandwidth_in: typing.Optional[jsii.Number] = None,
        internet_max_bandwidth_out: typing.Optional[jsii.Number] = None,
        ipv6_address_count: typing.Optional[jsii.Number] = None,
        ipv6_addresses: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
        key_pair_name: typing.Optional[builtins.str] = None,
        launch_template_id: typing.Optional[builtins.str] = None,
        launch_template_name: typing.Optional[builtins.str] = None,
        launch_template_version: typing.Optional[builtins.str] = None,
        load_balancer_id_to_attach: typing.Optional[builtins.str] = None,
        password: typing.Optional[builtins.str] = None,
        password_inherit: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        period: typing.Optional[jsii.Number] = None,
        period_unit: typing.Optional[builtins.str] = None,
        ram_role_name: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        security_group_ids: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
        spot_price_limit: typing.Optional[builtins.str] = None,
        spot_strategy: typing.Optional[builtins.str] = None,
        system_disk_auto_snapshot_policy_id: typing.Optional[builtins.str] = None,
        system_disk_category: typing.Optional[builtins.str] = None,
        system_disk_description: typing.Optional[builtins.str] = None,
        system_disk_disk_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.List[ros_cdk_core.RosTag]] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::InstanceGroupClone``.

        :param max_amount: 
        :param source_instance_id: 
        :param auto_release_time: 
        :param auto_renew: 
        :param auto_renew_period: 
        :param backend_server_weight: 
        :param deletion_protection: 
        :param deployment_set_id: 
        :param description: 
        :param disk_mappings: 
        :param eni_mappings: 
        :param hpc_cluster_id: 
        :param image_id: 
        :param instance_name: 
        :param internet_max_bandwidth_in: 
        :param internet_max_bandwidth_out: 
        :param ipv6_address_count: 
        :param ipv6_addresses: 
        :param key_pair_name: 
        :param launch_template_id: 
        :param launch_template_name: 
        :param launch_template_version: 
        :param load_balancer_id_to_attach: 
        :param password: 
        :param password_inherit: 
        :param period: 
        :param period_unit: 
        :param ram_role_name: 
        :param resource_group_id: 
        :param security_group_id: 
        :param security_group_ids: 
        :param spot_price_limit: 
        :param spot_strategy: 
        :param system_disk_auto_snapshot_policy_id: 
        :param system_disk_category: 
        :param system_disk_description: 
        :param system_disk_disk_name: 
        :param tags: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "max_amount": max_amount,
            "source_instance_id": source_instance_id,
        }
        if auto_release_time is not None:
            self._values["auto_release_time"] = auto_release_time
        if auto_renew is not None:
            self._values["auto_renew"] = auto_renew
        if auto_renew_period is not None:
            self._values["auto_renew_period"] = auto_renew_period
        if backend_server_weight is not None:
            self._values["backend_server_weight"] = backend_server_weight
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if deployment_set_id is not None:
            self._values["deployment_set_id"] = deployment_set_id
        if description is not None:
            self._values["description"] = description
        if disk_mappings is not None:
            self._values["disk_mappings"] = disk_mappings
        if eni_mappings is not None:
            self._values["eni_mappings"] = eni_mappings
        if hpc_cluster_id is not None:
            self._values["hpc_cluster_id"] = hpc_cluster_id
        if image_id is not None:
            self._values["image_id"] = image_id
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if internet_max_bandwidth_in is not None:
            self._values["internet_max_bandwidth_in"] = internet_max_bandwidth_in
        if internet_max_bandwidth_out is not None:
            self._values["internet_max_bandwidth_out"] = internet_max_bandwidth_out
        if ipv6_address_count is not None:
            self._values["ipv6_address_count"] = ipv6_address_count
        if ipv6_addresses is not None:
            self._values["ipv6_addresses"] = ipv6_addresses
        if key_pair_name is not None:
            self._values["key_pair_name"] = key_pair_name
        if launch_template_id is not None:
            self._values["launch_template_id"] = launch_template_id
        if launch_template_name is not None:
            self._values["launch_template_name"] = launch_template_name
        if launch_template_version is not None:
            self._values["launch_template_version"] = launch_template_version
        if load_balancer_id_to_attach is not None:
            self._values["load_balancer_id_to_attach"] = load_balancer_id_to_attach
        if password is not None:
            self._values["password"] = password
        if password_inherit is not None:
            self._values["password_inherit"] = password_inherit
        if period is not None:
            self._values["period"] = period
        if period_unit is not None:
            self._values["period_unit"] = period_unit
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if spot_price_limit is not None:
            self._values["spot_price_limit"] = spot_price_limit
        if spot_strategy is not None:
            self._values["spot_strategy"] = spot_strategy
        if system_disk_auto_snapshot_policy_id is not None:
            self._values["system_disk_auto_snapshot_policy_id"] = system_disk_auto_snapshot_policy_id
        if system_disk_category is not None:
            self._values["system_disk_category"] = system_disk_category
        if system_disk_description is not None:
            self._values["system_disk_description"] = system_disk_description
        if system_disk_disk_name is not None:
            self._values["system_disk_disk_name"] = system_disk_disk_name
        if tags is not None:
            self._values["tags"] = tags
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def max_amount(self) -> jsii.Number:
        """
        :Property: maxAmount: Max number of instances to create, should be bigger than 'MinAmount' and smaller than 1000.
        """
        result = self._values.get("max_amount")
        assert result is not None, "Required property 'max_amount' is missing"
        return result

    @builtins.property
    def source_instance_id(self) -> builtins.str:
        """
        :Property: sourceInstanceId: Source ecs instance used to copy properties to clone new ecs instance. It will copy the InstanceType, ImageId, InternetChargeType, InternetMaxBandwidthIn, InternetMaxBandwidthOut and the system disk and data disk configurations. If the instance network is VPC, it will also clone the relative properties. If specified instance with more than one security group, it will use the first security group to create instance. you can also specify the SecurityGroupId to override it.
        """
        result = self._values.get("source_instance_id")
        assert result is not None, "Required property 'source_instance_id' is missing"
        return result

    @builtins.property
    def auto_release_time(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoReleaseTime: Auto release time for created instance, Follow ISO8601 standard using UTC time. format is 'yyyy-MM-ddTHH:mm:ssZ'. Not bigger than 3 years from this day onwards
        """
        result = self._values.get("auto_release_time")
        return result

    @builtins.property
    def auto_renew(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoRenew: Whether renew the fee automatically? When the parameter InstanceChargeType is PrePaid, it will take effect. Range of value:True: automatic renewal.False: no automatic renewal. Default value is False.Old instances will not be changed.
        """
        result = self._values.get("auto_renew")
        return result

    @builtins.property
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.Old instances will not be changed.
        """
        result = self._values.get("auto_renew_period")
        return result

    @builtins.property
    def backend_server_weight(self) -> typing.Optional[jsii.Number]:
        """
        :Property: backendServerWeight: The weight of backend server of load balancer. From 0 to 100, 0 means offline. Default is 100.
        """
        result = self._values.get("backend_server_weight")
        return result

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deletionProtection: Whether an instance can be released manually through the console or API, deletion protection only support postPaid instance
        """
        result = self._values.get("deletion_protection")
        return result

    @builtins.property
    def deployment_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: deploymentSetId: Deployment set ID. The change of the property does not affect existing instances.
        """
        result = self._values.get("deployment_set_id")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty. Old instances will not be changed.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosInstanceGroupClone.DiskMappingsProperty]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.Old instances will not be changed.
        """
        result = self._values.get("disk_mappings")
        return result

    @builtins.property
    def eni_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosInstanceGroupClone.EniMappingsProperty]]]]:
        """
        :Property: eniMappings: NetworkInterface to attach to instance. Max support 1 ENI.
        """
        result = self._values.get("eni_mappings")
        return result

    @builtins.property
    def hpc_cluster_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.The change of the property does not affect existing instances.
        """
        result = self._values.get("hpc_cluster_id")
        return result

    @builtins.property
    def image_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        result = self._values.get("image_id")
        return result

    @builtins.property
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.
        Support to use the regular expression to set the different instance name for each ECS instance. InstanceName could be specified as 'name_prefix[begin_number,bits]name_suffix', such as 'testinstance[123,4]tail'. If you creates 3 instances with the instance name 'testinstance[123,4]tail', all the instances' names are testinstance0123tail, testinstance0124tail, testinstance0125tail.
        The 'name_prefix[begin_number,bits]name_suffix' should follow those rules:

        1. 'name_prefix' is required.
        2. 'name_suffix' is optional.
        3. The name regular expression can't include any spaces.
        4. The 'bits' must be in range [1, 6].
        5. The 'begin_number' must be in range [0, 999999].
        6. You could only specify 'begin_number'. The 'bits' will be set as 6 by default.
        7. You also could only specify the [] or [,]. The 'begin_number' will be set as 0 by default, the 'bits' will be set as 6 by default.
        8. If the bits of 'begin_number' is less than the 'bits' you specified, like [1234,1], the 'bits' will be set as 6 by default.
        """
        result = self._values.get("instance_name")
        return result

    @builtins.property
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        result = self._values.get("internet_max_bandwidth_in")
        return result

    @builtins.property
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Set internet output bandwidth of instance. Unit is Mbps(Mega bit per second). Range is [0,200]. Default is 1.While the property is not 0, public ip will be assigned for instance.
        """
        result = self._values.get("internet_max_bandwidth_out")
        return result

    @builtins.property
    def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        ipv6AddressCount: Specifies the number of randomly generated IPv6 addresses for the elastic NIC.
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        The change of the property does not affect existing instances.
        """
        result = self._values.get("ipv6_address_count")
        return result

    @builtins.property
    def ipv6_addresses(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property:

        ipv6Addresses: Specify one or more IPv6 addresses for the elastic NIC. Currently, the maximum list size is 1. Example value: 2001:db8:1234:1a00::*** .
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        The change of the property does not affect existing instances.
        """
        result = self._values.get("ipv6_addresses")
        return result

    @builtins.property
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.Old instances will not be changed.
        """
        result = self._values.get("key_pair_name")
        return result

    @builtins.property
    def launch_template_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateId: ID of launch template. Launch template id or name must be specified to use launch template
        """
        result = self._values.get("launch_template_id")
        return result

    @builtins.property
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateName: Name of launch template. Launch template id or name must be specified to use launch template
        """
        result = self._values.get("launch_template_name")
        return result

    @builtins.property
    def launch_template_version(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateVersion: Version of launch template. Default version is used if version is not specified.
        """
        result = self._values.get("launch_template_version")
        return result

    @builtins.property
    def load_balancer_id_to_attach(self) -> typing.Optional[builtins.str]:
        """
        :Property: loadBalancerIdToAttach: After the instance is created. Automatic attach it to the load balancer.
        """
        result = self._values.get("load_balancer_id_to_attach")
        return result

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        result = self._values.get("password")
        return result

    @builtins.property
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: passwordInherit: Specifies whether to use the password preset in the image. To use the PasswordInherit parameter, the Password parameter must be empty and you must make sure that the selected image has a password configured.
        """
        result = self._values.get("password_inherit")
        return result

    @builtins.property
    def period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: period: Prepaid time period. Unit is month, it could be from 1 to 9 or 12, 24, 36, 48, 60. Default value is 1.Old instances will not be changed.
        """
        result = self._values.get("period")
        return result

    @builtins.property
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month. Default value is Month.Old instances will not be changed.
        """
        result = self._values.get("period_unit")
        return result

    @builtins.property
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        result = self._values.get("ram_role_name")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def security_group_ids(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property: securityGroupIds: The IDs of security groups N to which the instance belongs. The valid values of N are based on the maximum number of security groups to which an instance can belong. For more information, see Security group limits.Note: You cannot specify both SecurityGroupId and SecurityGroupIds at the same time.
        """
        result = self._values.get("security_group_ids")
        return result

    @builtins.property
    def spot_price_limit(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotPriceLimit: The hourly price threshold of a instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Three decimals is allowed at most.
        """
        result = self._values.get("spot_price_limit")
        return result

    @builtins.property
    def spot_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotStrategy: The spot strategy of a Pay-As-You-Go instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Value range: "NoSpot: A regular Pay-As-You-Go instance", "SpotWithPriceLimit: A price threshold for a spot instance, ""SpotAsPriceGo: A price that is based on the highest Pay-As-You-Go instance. "Default value: NoSpot.
        """
        result = self._values.get("spot_strategy")
        return result

    @builtins.property
    def system_disk_auto_snapshot_policy_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskAutoSnapshotPolicyId: Auto snapshot policy ID.
        """
        result = self._values.get("system_disk_auto_snapshot_policy_id")
        return result

    @builtins.property
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. Default is cloud_efficiency. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd.Old instances will not be changed.
        """
        result = self._values.get("system_disk_category")
        return result

    @builtins.property
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.Old instances will not be changed.
        """
        result = self._values.get("system_disk_description")
        return result

    @builtins.property
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.Old instances will not be changed.
        """
        result = self._values.get("system_disk_disk_name")
        return result

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[ros_cdk_core.RosTag]]:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosInstanceGroupCloneProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosInstanceGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "image_id": "imageId",
        "instance_type": "instanceType",
        "max_amount": "maxAmount",
        "allocate_public_ip": "allocatePublicIp",
        "auto_release_time": "autoReleaseTime",
        "auto_renew": "autoRenew",
        "auto_renew_period": "autoRenewPeriod",
        "dedicated_host_id": "dedicatedHostId",
        "deletion_protection": "deletionProtection",
        "deployment_set_id": "deploymentSetId",
        "description": "description",
        "disk_mappings": "diskMappings",
        "eni_mappings": "eniMappings",
        "host_name": "hostName",
        "hpc_cluster_id": "hpcClusterId",
        "instance_charge_type": "instanceChargeType",
        "instance_name": "instanceName",
        "internet_charge_type": "internetChargeType",
        "internet_max_bandwidth_in": "internetMaxBandwidthIn",
        "internet_max_bandwidth_out": "internetMaxBandwidthOut",
        "io_optimized": "ioOptimized",
        "ipv6_address_count": "ipv6AddressCount",
        "ipv6_addresses": "ipv6Addresses",
        "key_pair_name": "keyPairName",
        "launch_template_id": "launchTemplateId",
        "launch_template_name": "launchTemplateName",
        "launch_template_version": "launchTemplateVersion",
        "network_type": "networkType",
        "password": "password",
        "password_inherit": "passwordInherit",
        "period": "period",
        "period_unit": "periodUnit",
        "private_ip_address": "privateIpAddress",
        "ram_role_name": "ramRoleName",
        "resource_group_id": "resourceGroupId",
        "security_enhancement_strategy": "securityEnhancementStrategy",
        "security_group_id": "securityGroupId",
        "security_group_ids": "securityGroupIds",
        "spot_price_limit": "spotPriceLimit",
        "spot_strategy": "spotStrategy",
        "system_disk_auto_snapshot_policy_id": "systemDiskAutoSnapshotPolicyId",
        "system_disk_category": "systemDiskCategory",
        "system_disk_description": "systemDiskDescription",
        "system_disk_disk_name": "systemDiskDiskName",
        "system_disk_performance_level": "systemDiskPerformanceLevel",
        "system_disk_size": "systemDiskSize",
        "tags": "tags",
        "user_data": "userData",
        "vpc_id": "vpcId",
        "v_switch_id": "vSwitchId",
        "zone_id": "zoneId",
    },
)
class RosInstanceGroupProps:
    def __init__(
        self,
        *,
        image_id: builtins.str,
        instance_type: builtins.str,
        max_amount: jsii.Number,
        allocate_public_ip: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        auto_release_time: typing.Optional[builtins.str] = None,
        auto_renew: typing.Optional[builtins.str] = None,
        auto_renew_period: typing.Optional[jsii.Number] = None,
        dedicated_host_id: typing.Optional[builtins.str] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        deployment_set_id: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        disk_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosInstanceGroup.DiskMappingsProperty]]]] = None,
        eni_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosInstanceGroup.EniMappingsProperty]]]] = None,
        host_name: typing.Optional[builtins.str] = None,
        hpc_cluster_id: typing.Optional[builtins.str] = None,
        instance_charge_type: typing.Optional[builtins.str] = None,
        instance_name: typing.Optional[builtins.str] = None,
        internet_charge_type: typing.Optional[builtins.str] = None,
        internet_max_bandwidth_in: typing.Optional[jsii.Number] = None,
        internet_max_bandwidth_out: typing.Optional[jsii.Number] = None,
        io_optimized: typing.Optional[builtins.str] = None,
        ipv6_address_count: typing.Optional[jsii.Number] = None,
        ipv6_addresses: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
        key_pair_name: typing.Optional[builtins.str] = None,
        launch_template_id: typing.Optional[builtins.str] = None,
        launch_template_name: typing.Optional[builtins.str] = None,
        launch_template_version: typing.Optional[builtins.str] = None,
        network_type: typing.Optional[builtins.str] = None,
        password: typing.Optional[builtins.str] = None,
        password_inherit: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        period: typing.Optional[jsii.Number] = None,
        period_unit: typing.Optional[builtins.str] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        ram_role_name: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_enhancement_strategy: typing.Optional[builtins.str] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        security_group_ids: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
        spot_price_limit: typing.Optional[builtins.str] = None,
        spot_strategy: typing.Optional[builtins.str] = None,
        system_disk_auto_snapshot_policy_id: typing.Optional[builtins.str] = None,
        system_disk_category: typing.Optional[builtins.str] = None,
        system_disk_description: typing.Optional[builtins.str] = None,
        system_disk_disk_name: typing.Optional[builtins.str] = None,
        system_disk_performance_level: typing.Optional[builtins.str] = None,
        system_disk_size: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.List[ros_cdk_core.RosTag]] = None,
        user_data: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
        v_switch_id: typing.Optional[builtins.str] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::InstanceGroup``.

        :param image_id: 
        :param instance_type: 
        :param max_amount: 
        :param allocate_public_ip: 
        :param auto_release_time: 
        :param auto_renew: 
        :param auto_renew_period: 
        :param dedicated_host_id: 
        :param deletion_protection: 
        :param deployment_set_id: 
        :param description: 
        :param disk_mappings: 
        :param eni_mappings: 
        :param host_name: 
        :param hpc_cluster_id: 
        :param instance_charge_type: 
        :param instance_name: 
        :param internet_charge_type: 
        :param internet_max_bandwidth_in: 
        :param internet_max_bandwidth_out: 
        :param io_optimized: 
        :param ipv6_address_count: 
        :param ipv6_addresses: 
        :param key_pair_name: 
        :param launch_template_id: 
        :param launch_template_name: 
        :param launch_template_version: 
        :param network_type: 
        :param password: 
        :param password_inherit: 
        :param period: 
        :param period_unit: 
        :param private_ip_address: 
        :param ram_role_name: 
        :param resource_group_id: 
        :param security_enhancement_strategy: 
        :param security_group_id: 
        :param security_group_ids: 
        :param spot_price_limit: 
        :param spot_strategy: 
        :param system_disk_auto_snapshot_policy_id: 
        :param system_disk_category: 
        :param system_disk_description: 
        :param system_disk_disk_name: 
        :param system_disk_performance_level: 
        :param system_disk_size: 
        :param tags: 
        :param user_data: 
        :param vpc_id: 
        :param v_switch_id: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "image_id": image_id,
            "instance_type": instance_type,
            "max_amount": max_amount,
        }
        if allocate_public_ip is not None:
            self._values["allocate_public_ip"] = allocate_public_ip
        if auto_release_time is not None:
            self._values["auto_release_time"] = auto_release_time
        if auto_renew is not None:
            self._values["auto_renew"] = auto_renew
        if auto_renew_period is not None:
            self._values["auto_renew_period"] = auto_renew_period
        if dedicated_host_id is not None:
            self._values["dedicated_host_id"] = dedicated_host_id
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if deployment_set_id is not None:
            self._values["deployment_set_id"] = deployment_set_id
        if description is not None:
            self._values["description"] = description
        if disk_mappings is not None:
            self._values["disk_mappings"] = disk_mappings
        if eni_mappings is not None:
            self._values["eni_mappings"] = eni_mappings
        if host_name is not None:
            self._values["host_name"] = host_name
        if hpc_cluster_id is not None:
            self._values["hpc_cluster_id"] = hpc_cluster_id
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if internet_max_bandwidth_in is not None:
            self._values["internet_max_bandwidth_in"] = internet_max_bandwidth_in
        if internet_max_bandwidth_out is not None:
            self._values["internet_max_bandwidth_out"] = internet_max_bandwidth_out
        if io_optimized is not None:
            self._values["io_optimized"] = io_optimized
        if ipv6_address_count is not None:
            self._values["ipv6_address_count"] = ipv6_address_count
        if ipv6_addresses is not None:
            self._values["ipv6_addresses"] = ipv6_addresses
        if key_pair_name is not None:
            self._values["key_pair_name"] = key_pair_name
        if launch_template_id is not None:
            self._values["launch_template_id"] = launch_template_id
        if launch_template_name is not None:
            self._values["launch_template_name"] = launch_template_name
        if launch_template_version is not None:
            self._values["launch_template_version"] = launch_template_version
        if network_type is not None:
            self._values["network_type"] = network_type
        if password is not None:
            self._values["password"] = password
        if password_inherit is not None:
            self._values["password_inherit"] = password_inherit
        if period is not None:
            self._values["period"] = period
        if period_unit is not None:
            self._values["period_unit"] = period_unit
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_enhancement_strategy is not None:
            self._values["security_enhancement_strategy"] = security_enhancement_strategy
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if spot_price_limit is not None:
            self._values["spot_price_limit"] = spot_price_limit
        if spot_strategy is not None:
            self._values["spot_strategy"] = spot_strategy
        if system_disk_auto_snapshot_policy_id is not None:
            self._values["system_disk_auto_snapshot_policy_id"] = system_disk_auto_snapshot_policy_id
        if system_disk_category is not None:
            self._values["system_disk_category"] = system_disk_category
        if system_disk_description is not None:
            self._values["system_disk_description"] = system_disk_description
        if system_disk_disk_name is not None:
            self._values["system_disk_disk_name"] = system_disk_disk_name
        if system_disk_performance_level is not None:
            self._values["system_disk_performance_level"] = system_disk_performance_level
        if system_disk_size is not None:
            self._values["system_disk_size"] = system_disk_size
        if tags is not None:
            self._values["tags"] = tags
        if user_data is not None:
            self._values["user_data"] = user_data
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id
        if v_switch_id is not None:
            self._values["v_switch_id"] = v_switch_id
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def image_id(self) -> builtins.str:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        result = self._values.get("image_id")
        assert result is not None, "Required property 'image_id' is missing"
        return result

    @builtins.property
    def instance_type(self) -> builtins.str:
        """
        :Property: instanceType: Ecs instance supported instance type, make sure it should be correct.
        """
        result = self._values.get("instance_type")
        assert result is not None, "Required property 'instance_type' is missing"
        return result

    @builtins.property
    def max_amount(self) -> jsii.Number:
        """
        :Property: maxAmount: Max number of instances to create, should be bigger than 'MinAmount' and smaller than 1000.
        """
        result = self._values.get("max_amount")
        assert result is not None, "Required property 'max_amount' is missing"
        return result

    @builtins.property
    def allocate_public_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: allocatePublicIp: The public ip for ecs instance, if properties is true, will allocate public ip. If property InternetMaxBandwidthOut set to 0, it will not assign public ip.
        """
        result = self._values.get("allocate_public_ip")
        return result

    @builtins.property
    def auto_release_time(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoReleaseTime: Auto release time for created instance, Follow ISO8601 standard using UTC time. format is 'yyyy-MM-ddTHH:mm:ssZ'. Not bigger than 3 years from this day onwards
        """
        result = self._values.get("auto_release_time")
        return result

    @builtins.property
    def auto_renew(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoRenew: Whether renew the fee automatically? When the parameter InstanceChargeType is PrePaid, it will take effect. Range of value:True: automatic renewal.False: no automatic renewal. Default value is False.Old instances will not be changed.
        """
        result = self._values.get("auto_renew")
        return result

    @builtins.property
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.Old instances will not be changed.
        """
        result = self._values.get("auto_renew_period")
        return result

    @builtins.property
    def dedicated_host_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: dedicatedHostId: which dedicated host will be deployed
        """
        result = self._values.get("dedicated_host_id")
        return result

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deletionProtection: Whether an instance can be released manually through the console or API, deletion protection only support postPaid instance
        """
        result = self._values.get("deletion_protection")
        return result

    @builtins.property
    def deployment_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: deploymentSetId: Deployment set ID. The change of the property does not affect existing instances.
        """
        result = self._values.get("deployment_set_id")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty. Old instances will not be changed.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosInstanceGroup.DiskMappingsProperty]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.Old instances will not be changed.
        """
        result = self._values.get("disk_mappings")
        return result

    @builtins.property
    def eni_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosInstanceGroup.EniMappingsProperty]]]]:
        """
        :Property: eniMappings: NetworkInterface to attach to instance. Max support 1 ENI.
        """
        result = self._values.get("eni_mappings")
        return result

    @builtins.property
    def host_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        hostName: Host name of created ecs instance. at least 2 characters, and '.' '-' Is not the first and last characters as hostname, not continuous use. Windows platform can be up to 15 characters, allowing letters (without limiting case), numbers and '-', and does not support the number of points, not all is digital ('.').Other (Linux, etc.) platform up to 30 characters, allowing support number multiple points for the period between the points, each permit letters (without limiting case), numbers and '-' components.
        Support to use the regular expression to set the different instance name for each ECS instance. HostName could be specified as 'name_prefix[begin_number,bits]name_suffix', such as 'host[123,4]tail'. If you creates 3 instances with hostname 'host[123,4]tail', all the host names of instances are host0123tail, host0124tail, host0125tail. The 'name_prefix[begin_number,bits]name_suffix' should follow those rules:

        1. 'name_prefix' is required.
        2. 'name_suffix' is optional.
        3. The name regular expression can't include any spaces.
        4. The 'bits' must be in range [1, 6].
        5. The 'begin_number' must be in range [0, 999999].
        6. You could only specify 'begin_number'. The 'bits' will be set as 6 by default.
        7. You also could only specify the [] or [,]. The 'begin_number' will be set as 0 by default, the 'bits' will be set as 6 by default.
        8. If the bits of 'begin_number' is less than the 'bits' you specified, like [1234,1], the 'bits' will be set as 6 by default.
        The host name is specified by regular expression works after restart instance manually.
        """
        result = self._values.get("host_name")
        return result

    @builtins.property
    def hpc_cluster_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.The change of the property does not affect existing instances.
        """
        result = self._values.get("hpc_cluster_id")
        return result

    @builtins.property
    def instance_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceChargeType: Instance Charge type, allowed value: Prepaid and Postpaid. If specified Prepaid, please ensure you have sufficient balance in your account. Or instance creation will be failure. Default value is Postpaid.Old instances will not be changed.
        """
        result = self._values.get("instance_charge_type")
        return result

    @builtins.property
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.
        Support to use the regular expression to set the different instance name for each ECS instance. InstanceName could be specified as 'name_prefix[begin_number,bits]name_suffix', such as 'testinstance[123,4]tail'. If you creates 3 instances with the instance name 'testinstance[123,4]tail', all the instances' names are testinstance0123tail, testinstance0124tail, testinstance0125tail.
        The 'name_prefix[begin_number,bits]name_suffix' should follow those rules:

        1. 'name_prefix' is required.
        2. 'name_suffix' is optional.
        3. The name regular expression can't include any spaces.
        4. The 'bits' must be in range [1, 6].
        5. The 'begin_number' must be in range [0, 999999].
        6. You could only specify 'begin_number'. The 'bits' will be set as 6 by default.
        7. You also could only specify the [] or [,]. The 'begin_number' will be set as 0 by default, the 'bits' will be set as 6 by default.
        8. If the bits of 'begin_number' is less than the 'bits' you specified, like [1234,1], the 'bits' will be set as 6 by default.
        """
        result = self._values.get("instance_name")
        return result

    @builtins.property
    def internet_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: internetChargeType: Instance internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByTraffic
        """
        result = self._values.get("internet_charge_type")
        return result

    @builtins.property
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        result = self._values.get("internet_max_bandwidth_in")
        return result

    @builtins.property
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Set internet output bandwidth of instance. Unit is Mbps(Mega bit per second). Range is [0,200]. Default is 1.While the property is not 0, public ip will be assigned for instance.
        """
        result = self._values.get("internet_max_bandwidth_out")
        return result

    @builtins.property
    def io_optimized(self) -> typing.Optional[builtins.str]:
        """
        :Property: ioOptimized: The 'optimized' instance can provide better IO performance. Support 'none' and 'optimized' only, default is 'optimized'.
        """
        result = self._values.get("io_optimized")
        return result

    @builtins.property
    def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        ipv6AddressCount: Specifies the number of randomly generated IPv6 addresses for the elastic NIC.
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        The change of the property does not affect existing instances.
        """
        result = self._values.get("ipv6_address_count")
        return result

    @builtins.property
    def ipv6_addresses(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property:

        ipv6Addresses: Specify one or more IPv6 addresses for the elastic NIC. Currently, the maximum list size is 1. Example value: 2001:db8:1234:1a00::*** .
        Note You cannot specify the parameters Ipv6Addresses and Ipv6AddressCount at the same time.
        The change of the property does not affect existing instances.
        """
        result = self._values.get("ipv6_addresses")
        return result

    @builtins.property
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.Old instances will not be changed.
        """
        result = self._values.get("key_pair_name")
        return result

    @builtins.property
    def launch_template_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateId: ID of launch template. Launch template id or name must be specified to use launch template
        """
        result = self._values.get("launch_template_id")
        return result

    @builtins.property
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateName: Name of launch template. Launch template id or name must be specified to use launch template
        """
        result = self._values.get("launch_template_name")
        return result

    @builtins.property
    def launch_template_version(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateVersion: Version of launch template. Default version is used if version is not specified.
        """
        result = self._values.get("launch_template_version")
        return result

    @builtins.property
    def network_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: networkType: Instance network type. Support 'vpc' and 'classic', for compatible reason, default is 'classic'. If vswitch id and vpc id is specified, the property will be forced to be set to 'vpc'
        """
        result = self._values.get("network_type")
        return result

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        result = self._values.get("password")
        return result

    @builtins.property
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: passwordInherit: Specifies whether to use the password preset in the image. To use the PasswordInherit parameter, the Password parameter must be empty and you must make sure that the selected image has a password configured.
        """
        result = self._values.get("password_inherit")
        return result

    @builtins.property
    def period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: period: Prepaid time period. Unit is month, it could be from 1 to 9 or 12, 24, 36, 48, 60. Default value is 1.Old instances will not be changed.
        """
        result = self._values.get("period")
        return result

    @builtins.property
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month. Default value is Month.Old instances will not be changed.
        """
        result = self._values.get("period_unit")
        return result

    @builtins.property
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        """
        :Property: privateIpAddress: Private IP for the instance created. Only works for VPC instance and cannot duplicated with existing instance.
        """
        result = self._values.get("private_ip_address")
        return result

    @builtins.property
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        result = self._values.get("ram_role_name")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def security_enhancement_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityEnhancementStrategy:
        """
        result = self._values.get("security_enhancement_strategy")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def security_group_ids(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property: securityGroupIds: The IDs of security groups N to which the instance belongs. The valid values of N are based on the maximum number of security groups to which an instance can belong. For more information, see Security group limits.Note: You cannot specify both SecurityGroupId and SecurityGroupIds at the same time.
        """
        result = self._values.get("security_group_ids")
        return result

    @builtins.property
    def spot_price_limit(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotPriceLimit: The hourly price threshold of a instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Three decimals is allowed at most.
        """
        result = self._values.get("spot_price_limit")
        return result

    @builtins.property
    def spot_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotStrategy: The spot strategy of a Pay-As-You-Go instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Value range: "NoSpot: A regular Pay-As-You-Go instance", "SpotWithPriceLimit: A price threshold for a spot instance, ""SpotAsPriceGo: A price that is based on the highest Pay-As-You-Go instance. "Default value: NoSpot.
        """
        result = self._values.get("spot_strategy")
        return result

    @builtins.property
    def system_disk_auto_snapshot_policy_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskAutoSnapshotPolicyId: Auto snapshot policy ID.
        """
        result = self._values.get("system_disk_auto_snapshot_policy_id")
        return result

    @builtins.property
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. Default is cloud_efficiency. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd.Old instances will not be changed.
        """
        result = self._values.get("system_disk_category")
        return result

    @builtins.property
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.Old instances will not be changed.
        """
        result = self._values.get("system_disk_description")
        return result

    @builtins.property
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.Old instances will not be changed.
        """
        result = self._values.get("system_disk_disk_name")
        return result

    @builtins.property
    def system_disk_performance_level(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskPerformanceLevel: The performance level of the enhanced SSD used as the system disk.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
        """
        result = self._values.get("system_disk_performance_level")
        return result

    @builtins.property
    def system_disk_size(self) -> typing.Optional[jsii.Number]:
        """
        :Property: systemDiskSize: Disk size of the system disk, range from 20 to 500 GB. If you specify with your own image, make sure the system disk size bigger than image size.
        """
        result = self._values.get("system_disk_size")
        return result

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[ros_cdk_core.RosTag]]:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def user_data(self) -> typing.Optional[builtins.str]:
        """
        :Property: userData: User data to pass to instance. [1, 16KB] characters.User data should not be base64 encoded. If you want to pass base64 encoded string to the property, use function Fn::Base64Decode to decode the base64 string first.
        """
        result = self._values.get("user_data")
        return result

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcId: The VPC id to create ecs instance.
        """
        result = self._values.get("vpc_id")
        return result

    @builtins.property
    def v_switch_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vSwitchId: The vSwitch Id to create ecs instance.
        """
        result = self._values.get("v_switch_id")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosInstanceGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosInstanceProps",
    jsii_struct_bases=[],
    name_mapping={
        "image_id": "imageId",
        "instance_type": "instanceType",
        "allocate_public_ip": "allocatePublicIp",
        "auto_renew": "autoRenew",
        "auto_renew_period": "autoRenewPeriod",
        "dedicated_host_id": "dedicatedHostId",
        "deletion_protection": "deletionProtection",
        "deployment_set_id": "deploymentSetId",
        "description": "description",
        "disk_mappings": "diskMappings",
        "host_name": "hostName",
        "hpc_cluster_id": "hpcClusterId",
        "instance_charge_type": "instanceChargeType",
        "instance_name": "instanceName",
        "internet_charge_type": "internetChargeType",
        "internet_max_bandwidth_in": "internetMaxBandwidthIn",
        "internet_max_bandwidth_out": "internetMaxBandwidthOut",
        "io_optimized": "ioOptimized",
        "key_pair_name": "keyPairName",
        "password": "password",
        "password_inherit": "passwordInherit",
        "period": "period",
        "period_unit": "periodUnit",
        "private_ip_address": "privateIpAddress",
        "ram_role_name": "ramRoleName",
        "resource_group_id": "resourceGroupId",
        "security_enhancement_strategy": "securityEnhancementStrategy",
        "security_group_id": "securityGroupId",
        "spot_price_limit": "spotPriceLimit",
        "spot_strategy": "spotStrategy",
        "system_disk_category": "systemDiskCategory",
        "system_disk_description": "systemDiskDescription",
        "system_disk_disk_name": "systemDiskDiskName",
        "system_disk_performance_level": "systemDiskPerformanceLevel",
        "system_disk_size": "systemDiskSize",
        "tags": "tags",
        "user_data": "userData",
        "vpc_id": "vpcId",
        "v_switch_id": "vSwitchId",
        "zone_id": "zoneId",
    },
)
class RosInstanceProps:
    def __init__(
        self,
        *,
        image_id: builtins.str,
        instance_type: builtins.str,
        allocate_public_ip: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        auto_renew: typing.Optional[builtins.str] = None,
        auto_renew_period: typing.Optional[jsii.Number] = None,
        dedicated_host_id: typing.Optional[builtins.str] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        deployment_set_id: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        disk_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosInstance.DiskMappingsProperty]]]] = None,
        host_name: typing.Optional[builtins.str] = None,
        hpc_cluster_id: typing.Optional[builtins.str] = None,
        instance_charge_type: typing.Optional[builtins.str] = None,
        instance_name: typing.Optional[builtins.str] = None,
        internet_charge_type: typing.Optional[builtins.str] = None,
        internet_max_bandwidth_in: typing.Optional[jsii.Number] = None,
        internet_max_bandwidth_out: typing.Optional[jsii.Number] = None,
        io_optimized: typing.Optional[builtins.str] = None,
        key_pair_name: typing.Optional[builtins.str] = None,
        password: typing.Optional[builtins.str] = None,
        password_inherit: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        period: typing.Optional[jsii.Number] = None,
        period_unit: typing.Optional[builtins.str] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        ram_role_name: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_enhancement_strategy: typing.Optional[builtins.str] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        spot_price_limit: typing.Optional[builtins.str] = None,
        spot_strategy: typing.Optional[builtins.str] = None,
        system_disk_category: typing.Optional[builtins.str] = None,
        system_disk_description: typing.Optional[builtins.str] = None,
        system_disk_disk_name: typing.Optional[builtins.str] = None,
        system_disk_performance_level: typing.Optional[builtins.str] = None,
        system_disk_size: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.List[ros_cdk_core.RosTag]] = None,
        user_data: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
        v_switch_id: typing.Optional[builtins.str] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::Instance``.

        :param image_id: 
        :param instance_type: 
        :param allocate_public_ip: 
        :param auto_renew: 
        :param auto_renew_period: 
        :param dedicated_host_id: 
        :param deletion_protection: 
        :param deployment_set_id: 
        :param description: 
        :param disk_mappings: 
        :param host_name: 
        :param hpc_cluster_id: 
        :param instance_charge_type: 
        :param instance_name: 
        :param internet_charge_type: 
        :param internet_max_bandwidth_in: 
        :param internet_max_bandwidth_out: 
        :param io_optimized: 
        :param key_pair_name: 
        :param password: 
        :param password_inherit: 
        :param period: 
        :param period_unit: 
        :param private_ip_address: 
        :param ram_role_name: 
        :param resource_group_id: 
        :param security_enhancement_strategy: 
        :param security_group_id: 
        :param spot_price_limit: 
        :param spot_strategy: 
        :param system_disk_category: 
        :param system_disk_description: 
        :param system_disk_disk_name: 
        :param system_disk_performance_level: 
        :param system_disk_size: 
        :param tags: 
        :param user_data: 
        :param vpc_id: 
        :param v_switch_id: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "image_id": image_id,
            "instance_type": instance_type,
        }
        if allocate_public_ip is not None:
            self._values["allocate_public_ip"] = allocate_public_ip
        if auto_renew is not None:
            self._values["auto_renew"] = auto_renew
        if auto_renew_period is not None:
            self._values["auto_renew_period"] = auto_renew_period
        if dedicated_host_id is not None:
            self._values["dedicated_host_id"] = dedicated_host_id
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if deployment_set_id is not None:
            self._values["deployment_set_id"] = deployment_set_id
        if description is not None:
            self._values["description"] = description
        if disk_mappings is not None:
            self._values["disk_mappings"] = disk_mappings
        if host_name is not None:
            self._values["host_name"] = host_name
        if hpc_cluster_id is not None:
            self._values["hpc_cluster_id"] = hpc_cluster_id
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if internet_max_bandwidth_in is not None:
            self._values["internet_max_bandwidth_in"] = internet_max_bandwidth_in
        if internet_max_bandwidth_out is not None:
            self._values["internet_max_bandwidth_out"] = internet_max_bandwidth_out
        if io_optimized is not None:
            self._values["io_optimized"] = io_optimized
        if key_pair_name is not None:
            self._values["key_pair_name"] = key_pair_name
        if password is not None:
            self._values["password"] = password
        if password_inherit is not None:
            self._values["password_inherit"] = password_inherit
        if period is not None:
            self._values["period"] = period
        if period_unit is not None:
            self._values["period_unit"] = period_unit
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_enhancement_strategy is not None:
            self._values["security_enhancement_strategy"] = security_enhancement_strategy
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if spot_price_limit is not None:
            self._values["spot_price_limit"] = spot_price_limit
        if spot_strategy is not None:
            self._values["spot_strategy"] = spot_strategy
        if system_disk_category is not None:
            self._values["system_disk_category"] = system_disk_category
        if system_disk_description is not None:
            self._values["system_disk_description"] = system_disk_description
        if system_disk_disk_name is not None:
            self._values["system_disk_disk_name"] = system_disk_disk_name
        if system_disk_performance_level is not None:
            self._values["system_disk_performance_level"] = system_disk_performance_level
        if system_disk_size is not None:
            self._values["system_disk_size"] = system_disk_size
        if tags is not None:
            self._values["tags"] = tags
        if user_data is not None:
            self._values["user_data"] = user_data
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id
        if v_switch_id is not None:
            self._values["v_switch_id"] = v_switch_id
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def image_id(self) -> builtins.str:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        result = self._values.get("image_id")
        assert result is not None, "Required property 'image_id' is missing"
        return result

    @builtins.property
    def instance_type(self) -> builtins.str:
        """
        :Property: instanceType: Ecs instance supported instance type, make sure it should be correct.
        """
        result = self._values.get("instance_type")
        assert result is not None, "Required property 'instance_type' is missing"
        return result

    @builtins.property
    def allocate_public_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: allocatePublicIp: The public ip for ecs instance, if properties is true, will allocate public ip. If property InternetMaxBandwidthOut set to 0, it will not assign public ip.
        """
        result = self._values.get("allocate_public_ip")
        return result

    @builtins.property
    def auto_renew(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoRenew: Whether renew the fee automatically? When the parameter InstanceChargeType is PrePaid, it will take effect. Range of value:True: automatic renewal.False: no automatic renewal. Default value is False.
        """
        result = self._values.get("auto_renew")
        return result

    @builtins.property
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.
        """
        result = self._values.get("auto_renew_period")
        return result

    @builtins.property
    def dedicated_host_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: dedicatedHostId: which dedicated host will be deployed
        """
        result = self._values.get("dedicated_host_id")
        return result

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: deletionProtection: Whether an instance can be released manually through the console or API, deletion protection only support postPaid instance
        """
        result = self._values.get("deletion_protection")
        return result

    @builtins.property
    def deployment_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: deploymentSetId: Deployment set ID.
        """
        result = self._values.get("deployment_set_id")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosInstance.DiskMappingsProperty]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.
        """
        result = self._values.get("disk_mappings")
        return result

    @builtins.property
    def host_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: hostName: Host name of created ecs instance. at least 2 characters, and '.' '-' Is not the first and last characters as hostname, not continuous use. Windows platform can be up to 15 characters, allowing letters (without limiting case), numbers and '-', and does not support the number of points, not all is digital ('.').Other (Linux, etc.) platform up to 30 characters, allowing support number multiple points for the period between the points, each permit letters (without limiting case), numbers and '-' components.
        """
        result = self._values.get("host_name")
        return result

    @builtins.property
    def hpc_cluster_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.
        """
        result = self._values.get("hpc_cluster_id")
        return result

    @builtins.property
    def instance_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceChargeType: Instance Charge type, allowed value: Prepaid and Postpaid. If specified Prepaid, please ensure you have sufficient balance in your account. Or instance creation will be failure. Default value is Postpaid.
        """
        result = self._values.get("instance_charge_type")
        return result

    @builtins.property
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("instance_name")
        return result

    @builtins.property
    def internet_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: internetChargeType: Instance internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only. Default is PayByTraffic
        """
        result = self._values.get("internet_charge_type")
        return result

    @builtins.property
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        result = self._values.get("internet_max_bandwidth_in")
        return result

    @builtins.property
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Set internet output bandwidth of instance. Unit is Mbps(Mega bit per second). Range is [0,200]. Default is 1.While the property is not 0, public ip will be assigned for instance.
        """
        result = self._values.get("internet_max_bandwidth_out")
        return result

    @builtins.property
    def io_optimized(self) -> typing.Optional[builtins.str]:
        """
        :Property: ioOptimized: The 'optimized' instance can provide better IO performance. Support 'none' and 'optimized' only, default is 'optimized'.
        """
        result = self._values.get("io_optimized")
        return result

    @builtins.property
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.
        """
        result = self._values.get("key_pair_name")
        return result

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        result = self._values.get("password")
        return result

    @builtins.property
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: passwordInherit: Specifies whether to use the password preset in the image. To use the PasswordInherit parameter, the Password parameter must be empty and you must make sure that the selected image has a password configured.
        """
        result = self._values.get("password_inherit")
        return result

    @builtins.property
    def period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: period: Prepaid time period. Unit is month, it could be from 1 to 9 or 12, 24, 36, 48, 60. Default value is 1.
        """
        result = self._values.get("period")
        return result

    @builtins.property
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month/Year. Default value is Month.
        """
        result = self._values.get("period_unit")
        return result

    @builtins.property
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        """
        :Property: privateIpAddress: Private IP for the instance created. Only works for VPC instance and cannot duplicated with existing instance.
        """
        result = self._values.get("private_ip_address")
        return result

    @builtins.property
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        result = self._values.get("ram_role_name")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def security_enhancement_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityEnhancementStrategy:
        """
        result = self._values.get("security_enhancement_strategy")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def spot_price_limit(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotPriceLimit: The hourly price threshold of a instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Three decimals is allowed at most.
        """
        result = self._values.get("spot_price_limit")
        return result

    @builtins.property
    def spot_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotStrategy: The spot strategy of a Pay-As-You-Go instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Value range: "NoSpot: A regular Pay-As-You-Go instance", "SpotWithPriceLimit: A price threshold for a spot instance, ""SpotAsPriceGo: A price that is based on the highest Pay-As-You-Go instance. "Default value: NoSpot.
        """
        result = self._values.get("spot_strategy")
        return result

    @builtins.property
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. Default is cloud_efficiency. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd
        """
        result = self._values.get("system_disk_category")
        return result

    @builtins.property
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.
        """
        result = self._values.get("system_disk_description")
        return result

    @builtins.property
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.
        """
        result = self._values.get("system_disk_disk_name")
        return result

    @builtins.property
    def system_disk_performance_level(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskPerformanceLevel: The performance level of the enhanced SSD used as the system disk.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
        """
        result = self._values.get("system_disk_performance_level")
        return result

    @builtins.property
    def system_disk_size(self) -> typing.Optional[jsii.Number]:
        """
        :Property: systemDiskSize: Disk size of the system disk, range from 20 to 500 GB. If you specify with your own image, make sure the system disk size bigger than image size.
        """
        result = self._values.get("system_disk_size")
        return result

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[ros_cdk_core.RosTag]]:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def user_data(self) -> typing.Optional[builtins.str]:
        """
        :Property: userData: User data to pass to instance. [1, 16KB] characters.User data should not be base64 encoded. If you want to pass base64 encoded string to the property, use function Fn::Base64Decode to decode the base64 string first.
        """
        result = self._values.get("user_data")
        return result

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcId: The VPC id to create ecs instance.
        """
        result = self._values.get("vpc_id")
        return result

    @builtins.property
    def v_switch_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vSwitchId: The vSwitch Id to create ecs instance.
        """
        result = self._values.get("v_switch_id")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosInstanceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosInvocation(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosInvocation",
):
    """A ROS template type:  ``ALIYUN::ECS::Invocation``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosInvocationProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::Invocation``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosInvocation, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInvokeId")
    def attr_invoke_id(self) -> typing.Any:
        """
        :Attribute: InvokeId: The id of command execution.
        """
        return jsii.get(self, "attrInvokeId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="commandId")
    def command_id(self) -> builtins.str:
        """
        :Property: commandId: The id of command.
        """
        return jsii.get(self, "commandId")

    @command_id.setter # type: ignore
    def command_id(self, value: builtins.str) -> None:
        jsii.set(self, "commandId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceIds")
    def instance_ids(
        self,
    ) -> typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]:
        """
        :Property: instanceIds: The instance id list. Select up to 50 instances at a time.Instances status must be running.
        """
        return jsii.get(self, "instanceIds")

    @instance_ids.setter # type: ignore
    def instance_ids(
        self,
        value: typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable],
    ) -> None:
        jsii.set(self, "instanceIds", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="frequency")
    def frequency(self) -> typing.Optional[builtins.str]:
        """
        :Property: frequency: The frequency of timing execution (the shortest frequency is performed every 1 minute). It iss mandatory when Timing is True.The value rule follows the rules of the cron expression.
        """
        return jsii.get(self, "frequency")

    @frequency.setter # type: ignore
    def frequency(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "frequency", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="parameters")
    def parameters(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property:

        parameters: The key-value pairs of custom parameters passed in when the script contains custom parameters.
        Number of custom parameters: 0 to 10.
        The key cannot be an empty string. It can be up to 64 characters in length.
        The value can be an empty string.
        After the custom parameters and the original script content are Base64 encoded, the total size cannot exceed 16 KB.
        The set of custom parameter names must be a subset of the parameter set that is defined when you created the script. You can use an empty string to represent the parameters that are not passed in.
        Default value: null, indicating that this parameter is canceled and customer parameters are disabled.
        """
        return jsii.get(self, "parameters")

    @parameters.setter # type: ignore
    def parameters(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.Mapping[builtins.str, typing.Any]]],
    ) -> None:
        jsii.set(self, "parameters", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="timed")
    def timed(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: timed: Whether it is timed execution. Default is False.
        """
        return jsii.get(self, "timed")

    @timed.setter # type: ignore
    def timed(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "timed", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosInvocationProps",
    jsii_struct_bases=[],
    name_mapping={
        "command_id": "commandId",
        "instance_ids": "instanceIds",
        "frequency": "frequency",
        "parameters": "parameters",
        "timed": "timed",
    },
)
class RosInvocationProps:
    def __init__(
        self,
        *,
        command_id: builtins.str,
        instance_ids: typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable],
        frequency: typing.Optional[builtins.str] = None,
        parameters: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.Mapping[builtins.str, typing.Any]]] = None,
        timed: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::Invocation``.

        :param command_id: 
        :param instance_ids: 
        :param frequency: 
        :param parameters: 
        :param timed: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "command_id": command_id,
            "instance_ids": instance_ids,
        }
        if frequency is not None:
            self._values["frequency"] = frequency
        if parameters is not None:
            self._values["parameters"] = parameters
        if timed is not None:
            self._values["timed"] = timed

    @builtins.property
    def command_id(self) -> builtins.str:
        """
        :Property: commandId: The id of command.
        """
        result = self._values.get("command_id")
        assert result is not None, "Required property 'command_id' is missing"
        return result

    @builtins.property
    def instance_ids(
        self,
    ) -> typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]:
        """
        :Property: instanceIds: The instance id list. Select up to 50 instances at a time.Instances status must be running.
        """
        result = self._values.get("instance_ids")
        assert result is not None, "Required property 'instance_ids' is missing"
        return result

    @builtins.property
    def frequency(self) -> typing.Optional[builtins.str]:
        """
        :Property: frequency: The frequency of timing execution (the shortest frequency is performed every 1 minute). It iss mandatory when Timing is True.The value rule follows the rules of the cron expression.
        """
        result = self._values.get("frequency")
        return result

    @builtins.property
    def parameters(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property:

        parameters: The key-value pairs of custom parameters passed in when the script contains custom parameters.
        Number of custom parameters: 0 to 10.
        The key cannot be an empty string. It can be up to 64 characters in length.
        The value can be an empty string.
        After the custom parameters and the original script content are Base64 encoded, the total size cannot exceed 16 KB.
        The set of custom parameter names must be a subset of the parameter set that is defined when you created the script. You can use an empty string to represent the parameters that are not passed in.
        Default value: null, indicating that this parameter is canceled and customer parameters are disabled.
        """
        result = self._values.get("parameters")
        return result

    @builtins.property
    def timed(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: timed: Whether it is timed execution. Default is False.
        """
        result = self._values.get("timed")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosInvocationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosJoinSecurityGroup(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosJoinSecurityGroup",
):
    """A ROS template type:  ``ALIYUN::ECS::JoinSecurityGroup``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosJoinSecurityGroupProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::JoinSecurityGroup``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosJoinSecurityGroup, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        """A factory method that creates a new instance of this class from an object
containing the properties of this ROS resource."""
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupId")
    def security_group_id(self) -> builtins.str:
        """
        :Property: securityGroupId: Security group id to join.
        """
        return jsii.get(self, "securityGroupId")

    @security_group_id.setter # type: ignore
    def security_group_id(self, value: builtins.str) -> None:
        jsii.set(self, "securityGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceId")
    def instance_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceId: Instance Id to the join the security group.
        """
        return jsii.get(self, "instanceId")

    @instance_id.setter # type: ignore
    def instance_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceIdList")
    def instance_id_list(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property: instanceIdList: The comma delimited instance id list.If the property "InstanceId" is setting, this property will be ignored.
        """
        return jsii.get(self, "instanceIdList")

    @instance_id_list.setter # type: ignore
    def instance_id_list(
        self,
        value: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "instanceIdList", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="networkInterfaceList")
    def network_interface_list(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property: networkInterfaceList: Network interface list.
        """
        return jsii.get(self, "networkInterfaceList")

    @network_interface_list.setter # type: ignore
    def network_interface_list(
        self,
        value: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "networkInterfaceList", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosJoinSecurityGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "security_group_id": "securityGroupId",
        "instance_id": "instanceId",
        "instance_id_list": "instanceIdList",
        "network_interface_list": "networkInterfaceList",
    },
)
class RosJoinSecurityGroupProps:
    def __init__(
        self,
        *,
        security_group_id: builtins.str,
        instance_id: typing.Optional[builtins.str] = None,
        instance_id_list: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
        network_interface_list: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::JoinSecurityGroup``.

        :param security_group_id: 
        :param instance_id: 
        :param instance_id_list: 
        :param network_interface_list: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "security_group_id": security_group_id,
        }
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if instance_id_list is not None:
            self._values["instance_id_list"] = instance_id_list
        if network_interface_list is not None:
            self._values["network_interface_list"] = network_interface_list

    @builtins.property
    def security_group_id(self) -> builtins.str:
        """
        :Property: securityGroupId: Security group id to join.
        """
        result = self._values.get("security_group_id")
        assert result is not None, "Required property 'security_group_id' is missing"
        return result

    @builtins.property
    def instance_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceId: Instance Id to the join the security group.
        """
        result = self._values.get("instance_id")
        return result

    @builtins.property
    def instance_id_list(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property: instanceIdList: The comma delimited instance id list.If the property "InstanceId" is setting, this property will be ignored.
        """
        result = self._values.get("instance_id_list")
        return result

    @builtins.property
    def network_interface_list(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property: networkInterfaceList: Network interface list.
        """
        result = self._values.get("network_interface_list")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosJoinSecurityGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosLaunchTemplate(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosLaunchTemplate",
):
    """A ROS template type:  ``ALIYUN::ECS::LaunchTemplate``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosLaunchTemplateProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::LaunchTemplate``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosLaunchTemplate, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrDefaultVersionNumber")
    def attr_default_version_number(self) -> typing.Any:
        """
        :Attribute: DefaultVersionNumber: The default version number of launch template.
        """
        return jsii.get(self, "attrDefaultVersionNumber")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrLatestVersionNumber")
    def attr_latest_version_number(self) -> typing.Any:
        """
        :Attribute: LatestVersionNumber: The latest version number of launch template.
        """
        return jsii.get(self, "attrLatestVersionNumber")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrLaunchTemplateId")
    def attr_launch_template_id(self) -> typing.Any:
        """
        :Attribute: LaunchTemplateId: The id of launch template.
        """
        return jsii.get(self, "attrLaunchTemplateId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrLaunchTemplateName")
    def attr_launch_template_name(self) -> typing.Any:
        """
        :Attribute: LaunchTemplateName: The name of launch template.
        """
        return jsii.get(self, "attrLaunchTemplateName")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="tags")
    def tags(self) -> ros_cdk_core.TagManager:
        """
        :Property: tags: Tags to attach to instance, security group, disk and network interface.
        """
        return jsii.get(self, "tags")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="launchTemplateName")
    def launch_template_name(self) -> builtins.str:
        """
        :Property: launchTemplateName: The name of launch template.
        """
        return jsii.get(self, "launchTemplateName")

    @launch_template_name.setter # type: ignore
    def launch_template_name(self, value: builtins.str) -> None:
        jsii.set(self, "launchTemplateName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoReleaseTime")
    def auto_release_time(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoReleaseTime: Auto release time for created instance, Follow ISO8601 standard using UTC time. format is 'yyyy-MM-ddTHH:mm:ssZ'. Not bigger than 3 years from this day onwards
        """
        return jsii.get(self, "autoReleaseTime")

    @auto_release_time.setter # type: ignore
    def auto_release_time(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "autoReleaseTime", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="diskMappings")
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosLaunchTemplate.DiskMappingsProperty"]]]]:
        """
        :Property: diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        """
        return jsii.get(self, "diskMappings")

    @disk_mappings.setter # type: ignore
    def disk_mappings(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosLaunchTemplate.DiskMappingsProperty"]]]],
    ) -> None:
        jsii.set(self, "diskMappings", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="hostName")
    def host_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: hostName: Host name of created ecs instance. at least 2 characters, and '.' '-' Is not the first and last characters as hostname, not continuous use. Windows platform can be up to 15 characters, allowing letters (without limiting case), numbers and '-', and does not support the number of points, not all is digital ('.').Other (Linux, etc.) platform up to 30 characters, allowing support number multiple points for the period between the points, each permit letters (without limiting case), numbers and '-' components.
        """
        return jsii.get(self, "hostName")

    @host_name.setter # type: ignore
    def host_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "hostName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="imageId")
    def image_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        return jsii.get(self, "imageId")

    @image_id.setter # type: ignore
    def image_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "imageId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceName")
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        return jsii.get(self, "instanceName")

    @instance_name.setter # type: ignore
    def instance_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceType")
    def instance_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceType: Ecs instance supported instance type, make sure it should be correct.
        """
        return jsii.get(self, "instanceType")

    @instance_type.setter # type: ignore
    def instance_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetChargeType")
    def internet_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: internetChargeType: Instance internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only.
        """
        return jsii.get(self, "internetChargeType")

    @internet_charge_type.setter # type: ignore
    def internet_charge_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "internetChargeType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetMaxBandwidthIn")
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet in bandwidth in Mbps(Mega bit per second). The range is [1,200].
        """
        return jsii.get(self, "internetMaxBandwidthIn")

    @internet_max_bandwidth_in.setter # type: ignore
    def internet_max_bandwidth_in(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "internetMaxBandwidthIn", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Max internet out bandwidth in Mbps(Mega bit per second). Range is [0,200].While the property is not 0, public ip will be assigned for instance.
        """
        return jsii.get(self, "internetMaxBandwidthOut")

    @internet_max_bandwidth_out.setter # type: ignore
    def internet_max_bandwidth_out(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "internetMaxBandwidthOut", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ioOptimized")
    def io_optimized(self) -> typing.Optional[builtins.str]:
        """
        :Property: ioOptimized: The 'optimized' instance can provide better IO performance. Support 'none' and 'optimized' only.
        """
        return jsii.get(self, "ioOptimized")

    @io_optimized.setter # type: ignore
    def io_optimized(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ioOptimized", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="keyPairName")
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.
        """
        return jsii.get(self, "keyPairName")

    @key_pair_name.setter # type: ignore
    def key_pair_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "keyPairName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="networkInterfaces")
    def network_interfaces(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosLaunchTemplate.NetworkInterfacesProperty"]]]]:
        """
        :Property: networkInterfaces: Elastic network interfaces to be attached to instance.
        """
        return jsii.get(self, "networkInterfaces")

    @network_interfaces.setter # type: ignore
    def network_interfaces(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosLaunchTemplate.NetworkInterfacesProperty"]]]],
    ) -> None:
        jsii.set(self, "networkInterfaces", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="networkType")
    def network_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: networkType: Instance network type. Support 'vpc' and 'classic'
        """
        return jsii.get(self, "networkType")

    @network_type.setter # type: ignore
    def network_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "networkType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ramRoleName")
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        return jsii.get(self, "ramRoleName")

    @ram_role_name.setter # type: ignore
    def ram_role_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ramRoleName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityEnhancementStrategy")
    def security_enhancement_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityEnhancementStrategy: Activate or deactivate security enhancement,Value range: "Active" and "Deactive"
        """
        return jsii.get(self, "securityEnhancementStrategy")

    @security_enhancement_strategy.setter # type: ignore
    def security_enhancement_strategy(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "securityEnhancementStrategy", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupId")
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        return jsii.get(self, "securityGroupId")

    @security_group_id.setter # type: ignore
    def security_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "securityGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="spotPriceLimit")
    def spot_price_limit(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotPriceLimit: The hourly price threshold of a instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Three decimals is allowed at most.
        """
        return jsii.get(self, "spotPriceLimit")

    @spot_price_limit.setter # type: ignore
    def spot_price_limit(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "spotPriceLimit", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="spotStrategy")
    def spot_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotStrategy: The spot strategy of a Pay-As-You-Go instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Value range: "NoSpot: A regular Pay-As-You-Go instance", "SpotWithPriceLimit: A price threshold for a spot instance, ""SpotAsPriceGo: A price that is based on the highest Pay-As-You-Go instance. "
        """
        return jsii.get(self, "spotStrategy")

    @spot_strategy.setter # type: ignore
    def spot_strategy(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "spotStrategy", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskCategory")
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd
        """
        return jsii.get(self, "systemDiskCategory")

    @system_disk_category.setter # type: ignore
    def system_disk_category(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskCategory", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskDescription")
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.
        """
        return jsii.get(self, "systemDiskDescription")

    @system_disk_description.setter # type: ignore
    def system_disk_description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskDescription", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskDiskName")
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.
        """
        return jsii.get(self, "systemDiskDiskName")

    @system_disk_disk_name.setter # type: ignore
    def system_disk_disk_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskDiskName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskSize")
    def system_disk_size(self) -> typing.Optional[jsii.Number]:
        """
        :Property: systemDiskSize: Disk size of the system disk, range from 20 to 500 GB. If you specify with your own image, make sure the system disk size bigger than image size.
        """
        return jsii.get(self, "systemDiskSize")

    @system_disk_size.setter # type: ignore
    def system_disk_size(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "systemDiskSize", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="templateTags")
    def template_tags(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosLaunchTemplate.TemplateTagsProperty"]]]]:
        """
        :Property: templateTags: Template tags to attach to launch template.
        """
        return jsii.get(self, "templateTags")

    @template_tags.setter # type: ignore
    def template_tags(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosLaunchTemplate.TemplateTagsProperty"]]]],
    ) -> None:
        jsii.set(self, "templateTags", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="userData")
    def user_data(self) -> typing.Optional[builtins.str]:
        """
        :Property: userData: User data to pass to instance. [1, 16KB] characters.
        """
        return jsii.get(self, "userData")

    @user_data.setter # type: ignore
    def user_data(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "userData", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="versionDescription")
    def version_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: versionDescription: Description for version 1 of launch template.
        """
        return jsii.get(self, "versionDescription")

    @version_description.setter # type: ignore
    def version_description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "versionDescription", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="vSwitchId")
    def v_switch_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vSwitchId: The vSwitch Id to create ecs instance.
        """
        return jsii.get(self, "vSwitchId")

    @v_switch_id.setter # type: ignore
    def v_switch_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vSwitchId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="zoneId")
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: zoneId: Current zone to create the instance.
        """
        return jsii.get(self, "zoneId")

    @zone_id.setter # type: ignore
    def zone_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "zoneId", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosLaunchTemplate.DiskMappingsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "category": "category",
            "delete_with_instance": "deleteWithInstance",
            "description": "description",
            "disk_name": "diskName",
            "encrypted": "encrypted",
            "size": "size",
            "snapshot_id": "snapshotId",
        },
    )
    class DiskMappingsProperty:
        def __init__(
            self,
            *,
            category: typing.Optional[builtins.str] = None,
            delete_with_instance: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
            description: typing.Optional[builtins.str] = None,
            disk_name: typing.Optional[builtins.str] = None,
            encrypted: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
            size: typing.Optional[builtins.str] = None,
            snapshot_id: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param category: 
            :param delete_with_instance: 
            :param description: 
            :param disk_name: 
            :param encrypted: 
            :param size: 
            :param snapshot_id: 
            """
            self._values: typing.Dict[str, typing.Any] = {}
            if category is not None:
                self._values["category"] = category
            if delete_with_instance is not None:
                self._values["delete_with_instance"] = delete_with_instance
            if description is not None:
                self._values["description"] = description
            if disk_name is not None:
                self._values["disk_name"] = disk_name
            if encrypted is not None:
                self._values["encrypted"] = encrypted
            if size is not None:
                self._values["size"] = size
            if snapshot_id is not None:
                self._values["snapshot_id"] = snapshot_id

        @builtins.property
        def category(self) -> typing.Optional[builtins.str]:
            """
            :Property: category: The volume type.Now support: cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd.
            """
            result = self._values.get("category")
            return result

        @builtins.property
        def delete_with_instance(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
            """
            :Property: deleteWithInstance: Whether data disk should be released with instance.
            """
            result = self._values.get("delete_with_instance")
            return result

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            """
            :Property: description: Description of the disk, [2, 256] characters.
            """
            result = self._values.get("description")
            return result

        @builtins.property
        def disk_name(self) -> typing.Optional[builtins.str]:
            """
            :Property: diskName: Display name of the disk, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.
            """
            result = self._values.get("disk_name")
            return result

        @builtins.property
        def encrypted(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
            """
            :Property: encrypted: Whether data disk is encrypted.
            """
            result = self._values.get("encrypted")
            return result

        @builtins.property
        def size(self) -> typing.Optional[builtins.str]:
            """
            :Property: size: The size of the volume, unit in GB.Value range: cloud: [5,2000], cloud_efficiency: [20,32768], cloud_ssd: [20,32768], cloud_essd: [20,32768] ephemeral_ssd: [5,800].The value should be equal to or greater than the specific snapshot.
            """
            result = self._values.get("size")
            return result

        @builtins.property
        def snapshot_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: snapshotId: ID of the snapshot to create the volume.
            """
            result = self._values.get("snapshot_id")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DiskMappingsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosLaunchTemplate.NetworkInterfacesProperty",
        jsii_struct_bases=[],
        name_mapping={
            "description": "description",
            "network_interface_name": "networkInterfaceName",
            "primary_ip_address": "primaryIpAddress",
            "security_group_id": "securityGroupId",
            "v_switch_id": "vSwitchId",
        },
    )
    class NetworkInterfacesProperty:
        def __init__(
            self,
            *,
            description: typing.Optional[builtins.str] = None,
            network_interface_name: typing.Optional[builtins.str] = None,
            primary_ip_address: typing.Optional[builtins.str] = None,
            security_group_id: typing.Optional[builtins.str] = None,
            v_switch_id: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param description: 
            :param network_interface_name: 
            :param primary_ip_address: 
            :param security_group_id: 
            :param v_switch_id: 
            """
            self._values: typing.Dict[str, typing.Any] = {}
            if description is not None:
                self._values["description"] = description
            if network_interface_name is not None:
                self._values["network_interface_name"] = network_interface_name
            if primary_ip_address is not None:
                self._values["primary_ip_address"] = primary_ip_address
            if security_group_id is not None:
                self._values["security_group_id"] = security_group_id
            if v_switch_id is not None:
                self._values["v_switch_id"] = v_switch_id

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            """
            :Property: description: Description of your ENI. It is a string of [2, 256] English or Chinese characters.
            """
            result = self._values.get("description")
            return result

        @builtins.property
        def network_interface_name(self) -> typing.Optional[builtins.str]:
            """
            :Property: networkInterfaceName: Name of your ENI. It is a string of [2, 128]  Chinese or English characters. It must begin with a letter and can contain numbers, underscores (_), colons (:), or hyphens (-).
            """
            result = self._values.get("network_interface_name")
            return result

        @builtins.property
        def primary_ip_address(self) -> typing.Optional[builtins.str]:
            """
            :Property: primaryIpAddress: The primary private IP address of the ENI.
            """
            result = self._values.get("primary_ip_address")
            return result

        @builtins.property
        def security_group_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: securityGroupId: The ID of the security group that the ENI joins. The security group and the ENI must be in a same VPC.
            """
            result = self._values.get("security_group_id")
            return result

        @builtins.property
        def v_switch_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: vSwitchId: VSwitch ID of the specified VPC.
            """
            result = self._values.get("v_switch_id")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NetworkInterfacesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosLaunchTemplate.TemplateTagsProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TemplateTagsProperty:
        def __init__(
            self,
            *,
            key: typing.Optional[builtins.str] = None,
            value: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param key: 
            :param value: 
            """
            self._values: typing.Dict[str, typing.Any] = {}
            if key is not None:
                self._values["key"] = key
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Optional[builtins.str]:
            """
            :Property: key: undefined
            """
            result = self._values.get("key")
            return result

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            """
            :Property: value: undefined
            """
            result = self._values.get("value")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TemplateTagsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosLaunchTemplateProps",
    jsii_struct_bases=[],
    name_mapping={
        "launch_template_name": "launchTemplateName",
        "auto_release_time": "autoReleaseTime",
        "description": "description",
        "disk_mappings": "diskMappings",
        "host_name": "hostName",
        "image_id": "imageId",
        "instance_name": "instanceName",
        "instance_type": "instanceType",
        "internet_charge_type": "internetChargeType",
        "internet_max_bandwidth_in": "internetMaxBandwidthIn",
        "internet_max_bandwidth_out": "internetMaxBandwidthOut",
        "io_optimized": "ioOptimized",
        "key_pair_name": "keyPairName",
        "network_interfaces": "networkInterfaces",
        "network_type": "networkType",
        "ram_role_name": "ramRoleName",
        "security_enhancement_strategy": "securityEnhancementStrategy",
        "security_group_id": "securityGroupId",
        "spot_price_limit": "spotPriceLimit",
        "spot_strategy": "spotStrategy",
        "system_disk_category": "systemDiskCategory",
        "system_disk_description": "systemDiskDescription",
        "system_disk_disk_name": "systemDiskDiskName",
        "system_disk_size": "systemDiskSize",
        "tags": "tags",
        "template_tags": "templateTags",
        "user_data": "userData",
        "version_description": "versionDescription",
        "v_switch_id": "vSwitchId",
        "zone_id": "zoneId",
    },
)
class RosLaunchTemplateProps:
    def __init__(
        self,
        *,
        launch_template_name: builtins.str,
        auto_release_time: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        disk_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosLaunchTemplate.DiskMappingsProperty]]]] = None,
        host_name: typing.Optional[builtins.str] = None,
        image_id: typing.Optional[builtins.str] = None,
        instance_name: typing.Optional[builtins.str] = None,
        instance_type: typing.Optional[builtins.str] = None,
        internet_charge_type: typing.Optional[builtins.str] = None,
        internet_max_bandwidth_in: typing.Optional[jsii.Number] = None,
        internet_max_bandwidth_out: typing.Optional[jsii.Number] = None,
        io_optimized: typing.Optional[builtins.str] = None,
        key_pair_name: typing.Optional[builtins.str] = None,
        network_interfaces: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosLaunchTemplate.NetworkInterfacesProperty]]]] = None,
        network_type: typing.Optional[builtins.str] = None,
        ram_role_name: typing.Optional[builtins.str] = None,
        security_enhancement_strategy: typing.Optional[builtins.str] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        spot_price_limit: typing.Optional[builtins.str] = None,
        spot_strategy: typing.Optional[builtins.str] = None,
        system_disk_category: typing.Optional[builtins.str] = None,
        system_disk_description: typing.Optional[builtins.str] = None,
        system_disk_disk_name: typing.Optional[builtins.str] = None,
        system_disk_size: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.List[ros_cdk_core.RosTag]] = None,
        template_tags: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosLaunchTemplate.TemplateTagsProperty]]]] = None,
        user_data: typing.Optional[builtins.str] = None,
        version_description: typing.Optional[builtins.str] = None,
        v_switch_id: typing.Optional[builtins.str] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::LaunchTemplate``.

        :param launch_template_name: 
        :param auto_release_time: 
        :param description: 
        :param disk_mappings: 
        :param host_name: 
        :param image_id: 
        :param instance_name: 
        :param instance_type: 
        :param internet_charge_type: 
        :param internet_max_bandwidth_in: 
        :param internet_max_bandwidth_out: 
        :param io_optimized: 
        :param key_pair_name: 
        :param network_interfaces: 
        :param network_type: 
        :param ram_role_name: 
        :param security_enhancement_strategy: 
        :param security_group_id: 
        :param spot_price_limit: 
        :param spot_strategy: 
        :param system_disk_category: 
        :param system_disk_description: 
        :param system_disk_disk_name: 
        :param system_disk_size: 
        :param tags: 
        :param template_tags: 
        :param user_data: 
        :param version_description: 
        :param v_switch_id: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "launch_template_name": launch_template_name,
        }
        if auto_release_time is not None:
            self._values["auto_release_time"] = auto_release_time
        if description is not None:
            self._values["description"] = description
        if disk_mappings is not None:
            self._values["disk_mappings"] = disk_mappings
        if host_name is not None:
            self._values["host_name"] = host_name
        if image_id is not None:
            self._values["image_id"] = image_id
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if internet_max_bandwidth_in is not None:
            self._values["internet_max_bandwidth_in"] = internet_max_bandwidth_in
        if internet_max_bandwidth_out is not None:
            self._values["internet_max_bandwidth_out"] = internet_max_bandwidth_out
        if io_optimized is not None:
            self._values["io_optimized"] = io_optimized
        if key_pair_name is not None:
            self._values["key_pair_name"] = key_pair_name
        if network_interfaces is not None:
            self._values["network_interfaces"] = network_interfaces
        if network_type is not None:
            self._values["network_type"] = network_type
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if security_enhancement_strategy is not None:
            self._values["security_enhancement_strategy"] = security_enhancement_strategy
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if spot_price_limit is not None:
            self._values["spot_price_limit"] = spot_price_limit
        if spot_strategy is not None:
            self._values["spot_strategy"] = spot_strategy
        if system_disk_category is not None:
            self._values["system_disk_category"] = system_disk_category
        if system_disk_description is not None:
            self._values["system_disk_description"] = system_disk_description
        if system_disk_disk_name is not None:
            self._values["system_disk_disk_name"] = system_disk_disk_name
        if system_disk_size is not None:
            self._values["system_disk_size"] = system_disk_size
        if tags is not None:
            self._values["tags"] = tags
        if template_tags is not None:
            self._values["template_tags"] = template_tags
        if user_data is not None:
            self._values["user_data"] = user_data
        if version_description is not None:
            self._values["version_description"] = version_description
        if v_switch_id is not None:
            self._values["v_switch_id"] = v_switch_id
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def launch_template_name(self) -> builtins.str:
        """
        :Property: launchTemplateName: The name of launch template.
        """
        result = self._values.get("launch_template_name")
        assert result is not None, "Required property 'launch_template_name' is missing"
        return result

    @builtins.property
    def auto_release_time(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoReleaseTime: Auto release time for created instance, Follow ISO8601 standard using UTC time. format is 'yyyy-MM-ddTHH:mm:ssZ'. Not bigger than 3 years from this day onwards
        """
        result = self._values.get("auto_release_time")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosLaunchTemplate.DiskMappingsProperty]]]]:
        """
        :Property: diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        """
        result = self._values.get("disk_mappings")
        return result

    @builtins.property
    def host_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: hostName: Host name of created ecs instance. at least 2 characters, and '.' '-' Is not the first and last characters as hostname, not continuous use. Windows platform can be up to 15 characters, allowing letters (without limiting case), numbers and '-', and does not support the number of points, not all is digital ('.').Other (Linux, etc.) platform up to 30 characters, allowing support number multiple points for the period between the points, each permit letters (without limiting case), numbers and '-' components.
        """
        result = self._values.get("host_name")
        return result

    @builtins.property
    def image_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        result = self._values.get("image_id")
        return result

    @builtins.property
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("instance_name")
        return result

    @builtins.property
    def instance_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceType: Ecs instance supported instance type, make sure it should be correct.
        """
        result = self._values.get("instance_type")
        return result

    @builtins.property
    def internet_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: internetChargeType: Instance internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only.
        """
        result = self._values.get("internet_charge_type")
        return result

    @builtins.property
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet in bandwidth in Mbps(Mega bit per second). The range is [1,200].
        """
        result = self._values.get("internet_max_bandwidth_in")
        return result

    @builtins.property
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Max internet out bandwidth in Mbps(Mega bit per second). Range is [0,200].While the property is not 0, public ip will be assigned for instance.
        """
        result = self._values.get("internet_max_bandwidth_out")
        return result

    @builtins.property
    def io_optimized(self) -> typing.Optional[builtins.str]:
        """
        :Property: ioOptimized: The 'optimized' instance can provide better IO performance. Support 'none' and 'optimized' only.
        """
        result = self._values.get("io_optimized")
        return result

    @builtins.property
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.
        """
        result = self._values.get("key_pair_name")
        return result

    @builtins.property
    def network_interfaces(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosLaunchTemplate.NetworkInterfacesProperty]]]]:
        """
        :Property: networkInterfaces: Elastic network interfaces to be attached to instance.
        """
        result = self._values.get("network_interfaces")
        return result

    @builtins.property
    def network_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: networkType: Instance network type. Support 'vpc' and 'classic'
        """
        result = self._values.get("network_type")
        return result

    @builtins.property
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        result = self._values.get("ram_role_name")
        return result

    @builtins.property
    def security_enhancement_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityEnhancementStrategy: Activate or deactivate security enhancement,Value range: "Active" and "Deactive"
        """
        result = self._values.get("security_enhancement_strategy")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def spot_price_limit(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotPriceLimit: The hourly price threshold of a instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Three decimals is allowed at most.
        """
        result = self._values.get("spot_price_limit")
        return result

    @builtins.property
    def spot_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: spotStrategy: The spot strategy of a Pay-As-You-Go instance, and it takes effect only when parameter InstanceChargeType is PostPaid. Value range: "NoSpot: A regular Pay-As-You-Go instance", "SpotWithPriceLimit: A price threshold for a spot instance, ""SpotAsPriceGo: A price that is based on the highest Pay-As-You-Go instance. "
        """
        result = self._values.get("spot_strategy")
        return result

    @builtins.property
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd
        """
        result = self._values.get("system_disk_category")
        return result

    @builtins.property
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.
        """
        result = self._values.get("system_disk_description")
        return result

    @builtins.property
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.
        """
        result = self._values.get("system_disk_disk_name")
        return result

    @builtins.property
    def system_disk_size(self) -> typing.Optional[jsii.Number]:
        """
        :Property: systemDiskSize: Disk size of the system disk, range from 20 to 500 GB. If you specify with your own image, make sure the system disk size bigger than image size.
        """
        result = self._values.get("system_disk_size")
        return result

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[ros_cdk_core.RosTag]]:
        """
        :Property: tags: Tags to attach to instance, security group, disk and network interface.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def template_tags(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosLaunchTemplate.TemplateTagsProperty]]]]:
        """
        :Property: templateTags: Template tags to attach to launch template.
        """
        result = self._values.get("template_tags")
        return result

    @builtins.property
    def user_data(self) -> typing.Optional[builtins.str]:
        """
        :Property: userData: User data to pass to instance. [1, 16KB] characters.
        """
        result = self._values.get("user_data")
        return result

    @builtins.property
    def version_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: versionDescription: Description for version 1 of launch template.
        """
        result = self._values.get("version_description")
        return result

    @builtins.property
    def v_switch_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vSwitchId: The vSwitch Id to create ecs instance.
        """
        result = self._values.get("v_switch_id")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: zoneId: Current zone to create the instance.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosLaunchTemplateProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosNetworkInterface(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosNetworkInterface",
):
    """A ROS template type:  ``ALIYUN::ECS::NetworkInterface``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosNetworkInterfaceProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::NetworkInterface``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosNetworkInterface, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrMacAddress")
    def attr_mac_address(self) -> typing.Any:
        """
        :Attribute: MacAddress: The MAC address of your Network Interface.
        """
        return jsii.get(self, "attrMacAddress")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrNetworkInterfaceId")
    def attr_network_interface_id(self) -> typing.Any:
        """
        :Attribute: NetworkInterfaceId: ID of your Network Interface.
        """
        return jsii.get(self, "attrNetworkInterfaceId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateIpAddress")
    def attr_private_ip_address(self) -> typing.Any:
        """
        :Attribute: PrivateIpAddress: The primary private ip address of your Network Interface.
        """
        return jsii.get(self, "attrPrivateIpAddress")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrSecondaryPrivateIpAddresses")
    def attr_secondary_private_ip_addresses(self) -> typing.Any:
        """
        :Attribute: SecondaryPrivateIpAddresses: The secondary private IP addresses of your Network Interface.
        """
        return jsii.get(self, "attrSecondaryPrivateIpAddresses")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="vSwitchId")
    def v_switch_id(self) -> builtins.str:
        """
        :Property: vSwitchId: VSwitch ID of the specified VPC. Specifies the switch ID for the VPC.
        """
        return jsii.get(self, "vSwitchId")

    @v_switch_id.setter # type: ignore
    def v_switch_id(self, value: builtins.str) -> None:
        jsii.set(self, "vSwitchId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of your ENI. It is a string of [2, 256] English or Chinese characters.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="networkInterfaceName")
    def network_interface_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: networkInterfaceName: Name of your ENI. It is a string of [2, 128]  Chinese or English characters. It must begin with a letter and can contain numbers, underscores (_), colons (:), or hyphens (-).
        """
        return jsii.get(self, "networkInterfaceName")

    @network_interface_name.setter # type: ignore
    def network_interface_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "networkInterfaceName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="primaryIpAddress")
    def primary_ip_address(self) -> typing.Optional[builtins.str]:
        """
        :Property: primaryIpAddress: The primary private IP address of the ENI.  The specified IP address must have the same Host ID as the VSwitch. If no IP addresses are specified, a random network ID is assigned for the ENI.
        """
        return jsii.get(self, "primaryIpAddress")

    @primary_ip_address.setter # type: ignore
    def primary_ip_address(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "primaryIpAddress", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="privateIpAddresses")
    def private_ip_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
        """
        :Property: privateIpAddresses: Specifies secondary private IP addresses of the ENI. This IP address must be an available IP address in the CIDR block of the VSwitch to which the ENI belongs.
        """
        return jsii.get(self, "privateIpAddresses")

    @private_ip_addresses.setter # type: ignore
    def private_ip_addresses(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        jsii.set(self, "privateIpAddresses", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        return jsii.get(self, "resourceGroupId")

    @resource_group_id.setter # type: ignore
    def resource_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "resourceGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupId")
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: The ID of the security group that the ENI joins. The security group and the ENI must be in a same VPC.
        """
        return jsii.get(self, "securityGroupId")

    @security_group_id.setter # type: ignore
    def security_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "securityGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupIds")
    def security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        """
        :Property: securityGroupIds: The IDs of the security groups that the ENI joins. The security groups and the ENI must belong to the same VPC.
        """
        return jsii.get(self, "securityGroupIds")

    @security_group_ids.setter # type: ignore
    def security_group_ids(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        jsii.set(self, "securityGroupIds", value)


class RosNetworkInterfaceAttachment(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosNetworkInterfaceAttachment",
):
    """A ROS template type:  ``ALIYUN::ECS::NetworkInterfaceAttachment``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosNetworkInterfaceAttachmentProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::NetworkInterfaceAttachment``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosNetworkInterfaceAttachment, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrNetworkInterfaceId")
    def attr_network_interface_id(self) -> typing.Any:
        """
        :Attribute: NetworkInterfaceId: ID of your Network Interface.
        """
        return jsii.get(self, "attrNetworkInterfaceId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrTrunkNetworkInstanceId")
    def attr_trunk_network_instance_id(self) -> typing.Any:
        """
        :Attribute: TrunkNetworkInstanceId: ID of Trunk Network Interface.
        """
        return jsii.get(self, "attrTrunkNetworkInstanceId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceId")
    def instance_id(self) -> builtins.str:
        """
        :Property: instanceId: ECS instance id
        """
        return jsii.get(self, "instanceId")

    @instance_id.setter # type: ignore
    def instance_id(self, value: builtins.str) -> None:
        jsii.set(self, "instanceId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="networkInterfaceId")
    def network_interface_id(self) -> builtins.str:
        """
        :Property: networkInterfaceId: Network interface id
        """
        return jsii.get(self, "networkInterfaceId")

    @network_interface_id.setter # type: ignore
    def network_interface_id(self, value: builtins.str) -> None:
        jsii.set(self, "networkInterfaceId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="trunkNetworkInstanceId")
    def trunk_network_instance_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: trunkNetworkInstanceId: undefined
        """
        return jsii.get(self, "trunkNetworkInstanceId")

    @trunk_network_instance_id.setter # type: ignore
    def trunk_network_instance_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "trunkNetworkInstanceId", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosNetworkInterfaceAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "instance_id": "instanceId",
        "network_interface_id": "networkInterfaceId",
        "trunk_network_instance_id": "trunkNetworkInstanceId",
    },
)
class RosNetworkInterfaceAttachmentProps:
    def __init__(
        self,
        *,
        instance_id: builtins.str,
        network_interface_id: builtins.str,
        trunk_network_instance_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::NetworkInterfaceAttachment``.

        :param instance_id: 
        :param network_interface_id: 
        :param trunk_network_instance_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "instance_id": instance_id,
            "network_interface_id": network_interface_id,
        }
        if trunk_network_instance_id is not None:
            self._values["trunk_network_instance_id"] = trunk_network_instance_id

    @builtins.property
    def instance_id(self) -> builtins.str:
        """
        :Property: instanceId: ECS instance id
        """
        result = self._values.get("instance_id")
        assert result is not None, "Required property 'instance_id' is missing"
        return result

    @builtins.property
    def network_interface_id(self) -> builtins.str:
        """
        :Property: networkInterfaceId: Network interface id
        """
        result = self._values.get("network_interface_id")
        assert result is not None, "Required property 'network_interface_id' is missing"
        return result

    @builtins.property
    def trunk_network_instance_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: trunkNetworkInstanceId: undefined
        """
        result = self._values.get("trunk_network_instance_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosNetworkInterfaceAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosNetworkInterfacePermission(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosNetworkInterfacePermission",
):
    """A ROS template type:  ``ALIYUN::ECS::NetworkInterfacePermission``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosNetworkInterfacePermissionProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::NetworkInterfacePermission``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosNetworkInterfacePermission, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrNetworkInterfacePermissionId")
    def attr_network_interface_permission_id(self) -> typing.Any:
        """
        :Attribute: NetworkInterfacePermissionId: the network interface permission id
        """
        return jsii.get(self, "attrNetworkInterfacePermissionId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="accountId")
    def account_id(self) -> builtins.str:
        """
        :Property: accountId: the account id
        """
        return jsii.get(self, "accountId")

    @account_id.setter # type: ignore
    def account_id(self, value: builtins.str) -> None:
        jsii.set(self, "accountId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="networkInterfaceId")
    def network_interface_id(self) -> builtins.str:
        """
        :Property: networkInterfaceId: Network interface id
        """
        return jsii.get(self, "networkInterfaceId")

    @network_interface_id.setter # type: ignore
    def network_interface_id(self, value: builtins.str) -> None:
        jsii.set(self, "networkInterfaceId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="permission")
    def permission(self) -> builtins.str:
        """
        :Property: permission: the permission
        """
        return jsii.get(self, "permission")

    @permission.setter # type: ignore
    def permission(self, value: builtins.str) -> None:
        jsii.set(self, "permission", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosNetworkInterfacePermissionProps",
    jsii_struct_bases=[],
    name_mapping={
        "account_id": "accountId",
        "network_interface_id": "networkInterfaceId",
        "permission": "permission",
    },
)
class RosNetworkInterfacePermissionProps:
    def __init__(
        self,
        *,
        account_id: builtins.str,
        network_interface_id: builtins.str,
        permission: builtins.str,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::NetworkInterfacePermission``.

        :param account_id: 
        :param network_interface_id: 
        :param permission: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "account_id": account_id,
            "network_interface_id": network_interface_id,
            "permission": permission,
        }

    @builtins.property
    def account_id(self) -> builtins.str:
        """
        :Property: accountId: the account id
        """
        result = self._values.get("account_id")
        assert result is not None, "Required property 'account_id' is missing"
        return result

    @builtins.property
    def network_interface_id(self) -> builtins.str:
        """
        :Property: networkInterfaceId: Network interface id
        """
        result = self._values.get("network_interface_id")
        assert result is not None, "Required property 'network_interface_id' is missing"
        return result

    @builtins.property
    def permission(self) -> builtins.str:
        """
        :Property: permission: the permission
        """
        result = self._values.get("permission")
        assert result is not None, "Required property 'permission' is missing"
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosNetworkInterfacePermissionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosNetworkInterfaceProps",
    jsii_struct_bases=[],
    name_mapping={
        "v_switch_id": "vSwitchId",
        "description": "description",
        "network_interface_name": "networkInterfaceName",
        "primary_ip_address": "primaryIpAddress",
        "private_ip_addresses": "privateIpAddresses",
        "resource_group_id": "resourceGroupId",
        "security_group_id": "securityGroupId",
        "security_group_ids": "securityGroupIds",
    },
)
class RosNetworkInterfaceProps:
    def __init__(
        self,
        *,
        v_switch_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        network_interface_name: typing.Optional[builtins.str] = None,
        primary_ip_address: typing.Optional[builtins.str] = None,
        private_ip_addresses: typing.Optional[typing.List[builtins.str]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        security_group_ids: typing.Optional[typing.List[builtins.str]] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::NetworkInterface``.

        :param v_switch_id: 
        :param description: 
        :param network_interface_name: 
        :param primary_ip_address: 
        :param private_ip_addresses: 
        :param resource_group_id: 
        :param security_group_id: 
        :param security_group_ids: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "v_switch_id": v_switch_id,
        }
        if description is not None:
            self._values["description"] = description
        if network_interface_name is not None:
            self._values["network_interface_name"] = network_interface_name
        if primary_ip_address is not None:
            self._values["primary_ip_address"] = primary_ip_address
        if private_ip_addresses is not None:
            self._values["private_ip_addresses"] = private_ip_addresses
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids

    @builtins.property
    def v_switch_id(self) -> builtins.str:
        """
        :Property: vSwitchId: VSwitch ID of the specified VPC. Specifies the switch ID for the VPC.
        """
        result = self._values.get("v_switch_id")
        assert result is not None, "Required property 'v_switch_id' is missing"
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of your ENI. It is a string of [2, 256] English or Chinese characters.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def network_interface_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: networkInterfaceName: Name of your ENI. It is a string of [2, 128]  Chinese or English characters. It must begin with a letter and can contain numbers, underscores (_), colons (:), or hyphens (-).
        """
        result = self._values.get("network_interface_name")
        return result

    @builtins.property
    def primary_ip_address(self) -> typing.Optional[builtins.str]:
        """
        :Property: primaryIpAddress: The primary private IP address of the ENI.  The specified IP address must have the same Host ID as the VSwitch. If no IP addresses are specified, a random network ID is assigned for the ENI.
        """
        result = self._values.get("primary_ip_address")
        return result

    @builtins.property
    def private_ip_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
        """
        :Property: privateIpAddresses: Specifies secondary private IP addresses of the ENI. This IP address must be an available IP address in the CIDR block of the VSwitch to which the ENI belongs.
        """
        result = self._values.get("private_ip_addresses")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: The ID of the security group that the ENI joins. The security group and the ENI must be in a same VPC.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        """
        :Property: securityGroupIds: The IDs of the security groups that the ENI joins. The security groups and the ENI must belong to the same VPC.
        """
        result = self._values.get("security_group_ids")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosNetworkInterfaceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosPrepayInstance(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosPrepayInstance",
):
    """A ROS template type:  ``ALIYUN::ECS::PrepayInstance``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosPrepayInstanceProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::PrepayInstance``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosPrepayInstance, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrHostNames")
    def attr_host_names(self) -> typing.Any:
        """
        :Attribute: HostNames: Host names of created instance.
        """
        return jsii.get(self, "attrHostNames")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInnerIps")
    def attr_inner_ips(self) -> typing.Any:
        """
        :Attribute: InnerIps: Inner IP address list of the specified instance. Only for classical instance.
        """
        return jsii.get(self, "attrInnerIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInstanceIds")
    def attr_instance_ids(self) -> typing.Any:
        """
        :Attribute: InstanceIds: The instance id list of created ecs instance
        """
        return jsii.get(self, "attrInstanceIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> typing.Any:
        """
        :Attribute: OrderId: The order id list of created instance.
        """
        return jsii.get(self, "attrOrderId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateIps")
    def attr_private_ips(self) -> typing.Any:
        """
        :Attribute: PrivateIps: Private IP address list of created ecs instance. Only for VPC instance.
        """
        return jsii.get(self, "attrPrivateIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPublicIps")
    def attr_public_ips(self) -> typing.Any:
        """
        :Attribute: PublicIps: Public IP address list of created ecs instance.
        """
        return jsii.get(self, "attrPublicIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrRelatedOrderIds")
    def attr_related_order_ids(self) -> typing.Any:
        """
        :Attribute: RelatedOrderIds: The related order id list of created ecs instances
        """
        return jsii.get(self, "attrRelatedOrderIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrZoneIds")
    def attr_zone_ids(self) -> typing.Any:
        """
        :Attribute: ZoneIds: Zone id of created instance.
        """
        return jsii.get(self, "attrZoneIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="tags")
    def tags(self) -> ros_cdk_core.TagManager:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        return jsii.get(self, "tags")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="imageId")
    def image_id(self) -> builtins.str:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        return jsii.get(self, "imageId")

    @image_id.setter # type: ignore
    def image_id(self, value: builtins.str) -> None:
        jsii.set(self, "imageId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceType")
    def instance_type(self) -> builtins.str:
        """
        :Property: instanceType: Ecs instance supported instance type, make sure it should be correct.
        """
        return jsii.get(self, "instanceType")

    @instance_type.setter # type: ignore
    def instance_type(self, value: builtins.str) -> None:
        jsii.set(self, "instanceType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="maxAmount")
    def max_amount(self) -> jsii.Number:
        """
        :Property: maxAmount: Max number of instances to create, should be smaller than 'MaxAmount' and smaller than 100.
        """
        return jsii.get(self, "maxAmount")

    @max_amount.setter # type: ignore
    def max_amount(self, value: jsii.Number) -> None:
        jsii.set(self, "maxAmount", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="minAmount")
    def min_amount(self) -> jsii.Number:
        """
        :Property: minAmount: Max number of instances to create, should be bigger than 'MinAmount' and smaller than 100.
        """
        return jsii.get(self, "minAmount")

    @min_amount.setter # type: ignore
    def min_amount(self, value: jsii.Number) -> None:
        jsii.set(self, "minAmount", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="period")
    def period(self) -> jsii.Number:
        """
        :Property: period: Prepaid time period. While choose by pay by month, it could be from 1 to 9. While choose pay by year, it could be from 1 to 3.
        """
        return jsii.get(self, "period")

    @period.setter # type: ignore
    def period(self, value: jsii.Number) -> None:
        jsii.set(self, "period", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="periodType")
    def period_type(self) -> builtins.str:
        """
        :Property: periodType: Charge period for created instances.
        """
        return jsii.get(self, "periodType")

    @period_type.setter # type: ignore
    def period_type(self, value: builtins.str) -> None:
        jsii.set(self, "periodType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="allocatePublicIp")
    def allocate_public_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: allocatePublicIp: The public ip for ecs instance, if properties is true, will allocate public ip. If property InternetMaxBandwidthOut set to 0, it will not assign public ip.
        """
        return jsii.get(self, "allocatePublicIp")

    @allocate_public_ip.setter # type: ignore
    def allocate_public_ip(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "allocatePublicIp", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoRenew")
    def auto_renew(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: autoRenew: Auto renew the prepay instance. If the period type is by year, it will renew by year, else it will renew by month.
        """
        return jsii.get(self, "autoRenew")

    @auto_renew.setter # type: ignore
    def auto_renew(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "autoRenew", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoRenewPeriod")
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.
        """
        return jsii.get(self, "autoRenewPeriod")

    @auto_renew_period.setter # type: ignore
    def auto_renew_period(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "autoRenewPeriod", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="dedicatedHostId")
    def dedicated_host_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: dedicatedHostId: which dedicated host will be deployed
        """
        return jsii.get(self, "dedicatedHostId")

    @dedicated_host_id.setter # type: ignore
    def dedicated_host_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "dedicatedHostId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="deploymentSetId")
    def deployment_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: deploymentSetId: Deployment set ID.
        """
        return jsii.get(self, "deploymentSetId")

    @deployment_set_id.setter # type: ignore
    def deployment_set_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "deploymentSetId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="diskMappings")
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosPrepayInstance.DiskMappingsProperty"]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.
        """
        return jsii.get(self, "diskMappings")

    @disk_mappings.setter # type: ignore
    def disk_mappings(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosPrepayInstance.DiskMappingsProperty"]]]],
    ) -> None:
        jsii.set(self, "diskMappings", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="hostName")
    def host_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: hostName: Host name of created ecs instance. at least 2 characters, and '.' '-' Is not the first and last characters as hostname, not continuous use. Windows platform can be up to 15 characters, allowing letters (without limiting case), numbers and '-', and does not support the number of points, not all is digital ('.').Other (Linux, etc.) platform up to 30 characters, allowing support number multiple points for the period between the points, each permit letters (without limiting case), numbers and '-' components.
        """
        return jsii.get(self, "hostName")

    @host_name.setter # type: ignore
    def host_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "hostName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="hpcClusterId")
    def hpc_cluster_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.
        """
        return jsii.get(self, "hpcClusterId")

    @hpc_cluster_id.setter # type: ignore
    def hpc_cluster_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "hpcClusterId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceChargeType")
    def instance_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceChargeType: Instance Charge type, allowed value: Prepaid and Postpaid. If specified Prepaid, please ensure you have sufficient balance in your account. Or instance creation will be failure. Default value is Postpaid.
        """
        return jsii.get(self, "instanceChargeType")

    @instance_charge_type.setter # type: ignore
    def instance_charge_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceChargeType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceName")
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        return jsii.get(self, "instanceName")

    @instance_name.setter # type: ignore
    def instance_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetChargeType")
    def internet_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: internetChargeType: Instance internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only. For AfterPay instance, default is 'PayByBandwidth'.
        """
        return jsii.get(self, "internetChargeType")

    @internet_charge_type.setter # type: ignore
    def internet_charge_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "internetChargeType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetMaxBandwidthIn")
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        return jsii.get(self, "internetMaxBandwidthIn")

    @internet_max_bandwidth_in.setter # type: ignore
    def internet_max_bandwidth_in(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "internetMaxBandwidthIn", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Set internet output bandwidth of instance. Unit is Mbps(Mega bit per second). Range is [0,200]. Default is 1.While the property is not 0, public ip will be assigned for instance.
        """
        return jsii.get(self, "internetMaxBandwidthOut")

    @internet_max_bandwidth_out.setter # type: ignore
    def internet_max_bandwidth_out(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "internetMaxBandwidthOut", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ioOptimized")
    def io_optimized(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: ioOptimized: The 'optimized' instance can provide better IO performance. Support true or false, Default is true.
        """
        return jsii.get(self, "ioOptimized")

    @io_optimized.setter # type: ignore
    def io_optimized(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "ioOptimized", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="keyPairName")
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.
        """
        return jsii.get(self, "keyPairName")

    @key_pair_name.setter # type: ignore
    def key_pair_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "keyPairName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="password")
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        return jsii.get(self, "password")

    @password.setter # type: ignore
    def password(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "password", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="passwordInherit")
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: passwordInherit: Specifies whether to use the password preset in the image. To use the PasswordInherit parameter, the Password parameter must be empty and you must make sure that the selected image has a password configured.
        """
        return jsii.get(self, "passwordInherit")

    @password_inherit.setter # type: ignore
    def password_inherit(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "passwordInherit", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="periodUnit")
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month/Year. Default value is Month.
        """
        return jsii.get(self, "periodUnit")

    @period_unit.setter # type: ignore
    def period_unit(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "periodUnit", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="privateIpAddress")
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        """
        :Property: privateIpAddress: Private IP for the instance created. Only works for VPC instance and cannot duplicated with existing instance.
        """
        return jsii.get(self, "privateIpAddress")

    @private_ip_address.setter # type: ignore
    def private_ip_address(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "privateIpAddress", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ramRoleName")
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        return jsii.get(self, "ramRoleName")

    @ram_role_name.setter # type: ignore
    def ram_role_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ramRoleName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityEnhancementStrategy")
    def security_enhancement_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityEnhancementStrategy:
        """
        return jsii.get(self, "securityEnhancementStrategy")

    @security_enhancement_strategy.setter # type: ignore
    def security_enhancement_strategy(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "securityEnhancementStrategy", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupId")
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        return jsii.get(self, "securityGroupId")

    @security_group_id.setter # type: ignore
    def security_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "securityGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskCategory")
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. Default is cloud_efficiency. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd
        """
        return jsii.get(self, "systemDiskCategory")

    @system_disk_category.setter # type: ignore
    def system_disk_category(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskCategory", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskDescription")
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.
        """
        return jsii.get(self, "systemDiskDescription")

    @system_disk_description.setter # type: ignore
    def system_disk_description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskDescription", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskDiskName")
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.
        """
        return jsii.get(self, "systemDiskDiskName")

    @system_disk_disk_name.setter # type: ignore
    def system_disk_disk_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskDiskName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskPerformanceLevel")
    def system_disk_performance_level(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskPerformanceLevel: The performance level of the enhanced SSD used as the system disk.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
        """
        return jsii.get(self, "systemDiskPerformanceLevel")

    @system_disk_performance_level.setter # type: ignore
    def system_disk_performance_level(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "systemDiskPerformanceLevel", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskSize")
    def system_disk_size(self) -> typing.Optional[jsii.Number]:
        """
        :Property: systemDiskSize: Disk size of the system disk, range from 20 to 500 GB. If you specify with your own image, make sure the system disk size bigger than image size.
        """
        return jsii.get(self, "systemDiskSize")

    @system_disk_size.setter # type: ignore
    def system_disk_size(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "systemDiskSize", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="userData")
    def user_data(self) -> typing.Optional[builtins.str]:
        """
        :Property: userData: User data to pass to instance. [1, 16KB] characters.User data should not be base64 encoded. If you want to pass base64 encoded string to the property, use function Fn::Base64Decode to decode the base64 string first.
        """
        return jsii.get(self, "userData")

    @user_data.setter # type: ignore
    def user_data(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "userData", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcId: The VPC id to create ecs instance.
        """
        return jsii.get(self, "vpcId")

    @vpc_id.setter # type: ignore
    def vpc_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vpcId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="vSwitchId")
    def v_switch_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vSwitchId: The vSwitch Id to create ecs instance.
        """
        return jsii.get(self, "vSwitchId")

    @v_switch_id.setter # type: ignore
    def v_switch_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vSwitchId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="zoneId")
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        return jsii.get(self, "zoneId")

    @zone_id.setter # type: ignore
    def zone_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "zoneId", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosPrepayInstance.DiskMappingsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "size": "size",
            "category": "category",
            "description": "description",
            "device": "device",
            "disk_name": "diskName",
            "performance_level": "performanceLevel",
            "snapshot_id": "snapshotId",
        },
    )
    class DiskMappingsProperty:
        def __init__(
            self,
            *,
            size: builtins.str,
            category: typing.Optional[builtins.str] = None,
            description: typing.Optional[builtins.str] = None,
            device: typing.Optional[builtins.str] = None,
            disk_name: typing.Optional[builtins.str] = None,
            performance_level: typing.Optional[builtins.str] = None,
            snapshot_id: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param size: 
            :param category: 
            :param description: 
            :param device: 
            :param disk_name: 
            :param performance_level: 
            :param snapshot_id: 
            """
            self._values: typing.Dict[str, typing.Any] = {
                "size": size,
            }
            if category is not None:
                self._values["category"] = category
            if description is not None:
                self._values["description"] = description
            if device is not None:
                self._values["device"] = device
            if disk_name is not None:
                self._values["disk_name"] = disk_name
            if performance_level is not None:
                self._values["performance_level"] = performance_level
            if snapshot_id is not None:
                self._values["snapshot_id"] = snapshot_id

        @builtins.property
        def size(self) -> builtins.str:
            """
            :Property: size: The size of the volume, unit in GB.Value range: cloud: [5,2000], cloud_efficiency: [20,32768], cloud_ssd: [20,32768], cloud_essd: [20,32768], ephemeral_ssd: [5,800].The value should be equal to or greater than the specific snapshot.
            """
            result = self._values.get("size")
            assert result is not None, "Required property 'size' is missing"
            return result

        @builtins.property
        def category(self) -> typing.Optional[builtins.str]:
            """
            :Property: category: The volume type.Now support: cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd. Default is cloud_efficiency.
            """
            result = self._values.get("category")
            return result

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            """
            :Property: description: Description of the disk, [2, 256] characters. Do not fill or empty, the default is empty.
            """
            result = self._values.get("description")
            return result

        @builtins.property
        def device(self) -> typing.Optional[builtins.str]:
            """
            :Property: device: The device where the volume is exposed on the instance. could be /dev/xvd[a-z]. If not specification, will use default value.
            """
            result = self._values.get("device")
            return result

        @builtins.property
        def disk_name(self) -> typing.Optional[builtins.str]:
            """
            :Property: diskName: Display name of the disk, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.
            """
            result = self._values.get("disk_name")
            return result

        @builtins.property
        def performance_level(self) -> typing.Optional[builtins.str]:
            """
            :Property: performanceLevel: The performance level of the enhanced SSD used as the Nth data disk.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
            """
            result = self._values.get("performance_level")
            return result

        @builtins.property
        def snapshot_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: snapshotId: ID of the snapshot to create the volume.
            """
            result = self._values.get("snapshot_id")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DiskMappingsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


class RosPrepayInstanceGroupClone(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosPrepayInstanceGroupClone",
):
    """A ROS template type:  ``ALIYUN::ECS::PrepayInstanceGroupClone``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosPrepayInstanceGroupCloneProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::PrepayInstanceGroupClone``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosPrepayInstanceGroupClone, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrHostNames")
    def attr_host_names(self) -> typing.Any:
        """
        :Attribute: HostNames: Host names of created instance.
        """
        return jsii.get(self, "attrHostNames")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInnerIps")
    def attr_inner_ips(self) -> typing.Any:
        """
        :Attribute: InnerIps: Inner IP address list of the specified instance. Only for classical instance.
        """
        return jsii.get(self, "attrInnerIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInstanceIds")
    def attr_instance_ids(self) -> typing.Any:
        """
        :Attribute: InstanceIds: The instance id list of created ecs instance
        """
        return jsii.get(self, "attrInstanceIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrOrderId")
    def attr_order_id(self) -> typing.Any:
        """
        :Attribute: OrderId: The order id list of created instance.
        """
        return jsii.get(self, "attrOrderId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateIps")
    def attr_private_ips(self) -> typing.Any:
        """
        :Attribute: PrivateIps: Private IP address list of created ecs instance. Only for VPC instance.
        """
        return jsii.get(self, "attrPrivateIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPublicIps")
    def attr_public_ips(self) -> typing.Any:
        """
        :Attribute: PublicIps: Public IP address list of created ecs instance.
        """
        return jsii.get(self, "attrPublicIps")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrRelatedOrderIds")
    def attr_related_order_ids(self) -> typing.Any:
        """
        :Attribute: RelatedOrderIds: The related order id list of created ecs instances
        """
        return jsii.get(self, "attrRelatedOrderIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrZoneIds")
    def attr_zone_ids(self) -> typing.Any:
        """
        :Attribute: ZoneIds: Zone id of created instance.
        """
        return jsii.get(self, "attrZoneIds")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="tags")
    def tags(self) -> ros_cdk_core.TagManager:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        return jsii.get(self, "tags")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="maxAmount")
    def max_amount(self) -> jsii.Number:
        """
        :Property: maxAmount: Max number of instances to create, should be smaller than 'MaxAmount' and smaller than 100.
        """
        return jsii.get(self, "maxAmount")

    @max_amount.setter # type: ignore
    def max_amount(self, value: jsii.Number) -> None:
        jsii.set(self, "maxAmount", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="minAmount")
    def min_amount(self) -> jsii.Number:
        """
        :Property: minAmount: Max number of instances to create, should be bigger than 'MinAmount' and smaller than 100.
        """
        return jsii.get(self, "minAmount")

    @min_amount.setter # type: ignore
    def min_amount(self, value: jsii.Number) -> None:
        jsii.set(self, "minAmount", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="period")
    def period(self) -> jsii.Number:
        """
        :Property: period: Prepaid time period. While choose by pay by month, it could be from 1 to 9. While choose pay by year, it could be from 1 to 3.
        """
        return jsii.get(self, "period")

    @period.setter # type: ignore
    def period(self, value: jsii.Number) -> None:
        jsii.set(self, "period", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="periodType")
    def period_type(self) -> builtins.str:
        """
        :Property: periodType: Charge period for created instances.
        """
        return jsii.get(self, "periodType")

    @period_type.setter # type: ignore
    def period_type(self, value: builtins.str) -> None:
        jsii.set(self, "periodType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="sourceInstanceId")
    def source_instance_id(self) -> builtins.str:
        """
        :Property: sourceInstanceId: Source ecs instance used to copy properties to clone new ecs instance. It will copy the InstanceType, ImageId, InternetChargeType, InternetMaxBandwidthIn, InternetMaxBandwidthOut and the system disk and data disk configurations. If the instance network is VPC, it will also clone the relative properties. If specified instance with more than one security group, it will use the first security group to create instance. you can also specify the SecurityGroupId to override it.
        """
        return jsii.get(self, "sourceInstanceId")

    @source_instance_id.setter # type: ignore
    def source_instance_id(self, value: builtins.str) -> None:
        jsii.set(self, "sourceInstanceId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoRenew")
    def auto_renew(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoRenew: Whether renew the fee automatically? When the parameter InstanceChargeType is PrePaid, it will take effect. Range of value:True: automatic renewal.False: no automatic renewal. Default value is False.Old instances will not be changed.
        """
        return jsii.get(self, "autoRenew")

    @auto_renew.setter # type: ignore
    def auto_renew(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "autoRenew", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="autoRenewPeriod")
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.Old instances will not be changed.
        """
        return jsii.get(self, "autoRenewPeriod")

    @auto_renew_period.setter # type: ignore
    def auto_renew_period(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "autoRenewPeriod", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="deploymentSetId")
    def deployment_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: deploymentSetId: Deployment set ID. The change of the property does not affect existing instances.
        """
        return jsii.get(self, "deploymentSetId")

    @deployment_set_id.setter # type: ignore
    def deployment_set_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "deploymentSetId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty. Old instances will not be changed.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="diskMappings")
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosPrepayInstanceGroupClone.DiskMappingsProperty"]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.Old instances will not be changed.
        """
        return jsii.get(self, "diskMappings")

    @disk_mappings.setter # type: ignore
    def disk_mappings(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosPrepayInstanceGroupClone.DiskMappingsProperty"]]]],
    ) -> None:
        jsii.set(self, "diskMappings", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="eniMappings")
    def eni_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosPrepayInstanceGroupClone.EniMappingsProperty"]]]]:
        """
        :Property: eniMappings: NetworkInterface to attach to instance. Max support 1 ENI.
        """
        return jsii.get(self, "eniMappings")

    @eni_mappings.setter # type: ignore
    def eni_mappings(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosPrepayInstanceGroupClone.EniMappingsProperty"]]]],
    ) -> None:
        jsii.set(self, "eniMappings", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="hpcClusterId")
    def hpc_cluster_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.The change of the property does not affect existing instances.
        """
        return jsii.get(self, "hpcClusterId")

    @hpc_cluster_id.setter # type: ignore
    def hpc_cluster_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "hpcClusterId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="imageId")
    def image_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        return jsii.get(self, "imageId")

    @image_id.setter # type: ignore
    def image_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "imageId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceName")
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        return jsii.get(self, "instanceName")

    @instance_name.setter # type: ignore
    def instance_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetMaxBandwidthIn")
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        return jsii.get(self, "internetMaxBandwidthIn")

    @internet_max_bandwidth_in.setter # type: ignore
    def internet_max_bandwidth_in(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "internetMaxBandwidthIn", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Set internet output bandwidth of instance. Unit is Mbps(Mega bit per second). Range is [0,200]. Default is 1.While the property is not 0, public ip will be assigned for instance.
        """
        return jsii.get(self, "internetMaxBandwidthOut")

    @internet_max_bandwidth_out.setter # type: ignore
    def internet_max_bandwidth_out(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "internetMaxBandwidthOut", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="keyPairName")
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.Old instances will not be changed.
        """
        return jsii.get(self, "keyPairName")

    @key_pair_name.setter # type: ignore
    def key_pair_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "keyPairName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="launchTemplateId")
    def launch_template_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateId: ID of launch template. Launch template id or name must be specified to use launch template
        """
        return jsii.get(self, "launchTemplateId")

    @launch_template_id.setter # type: ignore
    def launch_template_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "launchTemplateId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="launchTemplateName")
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateName: Name of launch template. Launch template id or name must be specified to use launch template
        """
        return jsii.get(self, "launchTemplateName")

    @launch_template_name.setter # type: ignore
    def launch_template_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "launchTemplateName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="launchTemplateVersion")
    def launch_template_version(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateVersion: Version of launch template. Default version is used if version is not specified.
        """
        return jsii.get(self, "launchTemplateVersion")

    @launch_template_version.setter # type: ignore
    def launch_template_version(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "launchTemplateVersion", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="password")
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        return jsii.get(self, "password")

    @password.setter # type: ignore
    def password(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "password", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="passwordInherit")
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: passwordInherit: Specifies whether to use the password preset in the image. To use the PasswordInherit parameter, the Password parameter must be empty and you must make sure that the selected image has a password configured.
        """
        return jsii.get(self, "passwordInherit")

    @password_inherit.setter # type: ignore
    def password_inherit(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "passwordInherit", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="periodUnit")
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month. Default value is Month.Old instances will not be changed.
        """
        return jsii.get(self, "periodUnit")

    @period_unit.setter # type: ignore
    def period_unit(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "periodUnit", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ramRoleName")
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        return jsii.get(self, "ramRoleName")

    @ram_role_name.setter # type: ignore
    def ram_role_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ramRoleName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupId")
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        return jsii.get(self, "securityGroupId")

    @security_group_id.setter # type: ignore
    def security_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "securityGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupIds")
    def security_group_ids(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property: securityGroupIds: The IDs of security groups N to which the instance belongs. The valid values of N are based on the maximum number of security groups to which an instance can belong. For more information, see Security group limits.Note: You cannot specify both SecurityGroupId and SecurityGroupIds at the same time.
        """
        return jsii.get(self, "securityGroupIds")

    @security_group_ids.setter # type: ignore
    def security_group_ids(
        self,
        value: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "securityGroupIds", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskAutoSnapshotPolicyId")
    def system_disk_auto_snapshot_policy_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskAutoSnapshotPolicyId: Auto snapshot policy ID.
        """
        return jsii.get(self, "systemDiskAutoSnapshotPolicyId")

    @system_disk_auto_snapshot_policy_id.setter # type: ignore
    def system_disk_auto_snapshot_policy_id(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "systemDiskAutoSnapshotPolicyId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskCategory")
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. Default is cloud_efficiency. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd.Old instances will not be changed.
        """
        return jsii.get(self, "systemDiskCategory")

    @system_disk_category.setter # type: ignore
    def system_disk_category(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskCategory", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskDescription")
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.Old instances will not be changed.
        """
        return jsii.get(self, "systemDiskDescription")

    @system_disk_description.setter # type: ignore
    def system_disk_description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskDescription", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="systemDiskDiskName")
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.Old instances will not be changed.
        """
        return jsii.get(self, "systemDiskDiskName")

    @system_disk_disk_name.setter # type: ignore
    def system_disk_disk_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "systemDiskDiskName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="zoneId")
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        return jsii.get(self, "zoneId")

    @zone_id.setter # type: ignore
    def zone_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "zoneId", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosPrepayInstanceGroupClone.DiskMappingsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "size": "size",
            "auto_snapshot_policy_id": "autoSnapshotPolicyId",
            "category": "category",
            "description": "description",
            "device": "device",
            "disk_name": "diskName",
            "encrypted": "encrypted",
            "kms_key_id": "kmsKeyId",
            "performance_level": "performanceLevel",
            "snapshot_id": "snapshotId",
        },
    )
    class DiskMappingsProperty:
        def __init__(
            self,
            *,
            size: builtins.str,
            auto_snapshot_policy_id: typing.Optional[builtins.str] = None,
            category: typing.Optional[builtins.str] = None,
            description: typing.Optional[builtins.str] = None,
            device: typing.Optional[builtins.str] = None,
            disk_name: typing.Optional[builtins.str] = None,
            encrypted: typing.Optional[builtins.str] = None,
            kms_key_id: typing.Optional[builtins.str] = None,
            performance_level: typing.Optional[builtins.str] = None,
            snapshot_id: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param size: 
            :param auto_snapshot_policy_id: 
            :param category: 
            :param description: 
            :param device: 
            :param disk_name: 
            :param encrypted: 
            :param kms_key_id: 
            :param performance_level: 
            :param snapshot_id: 
            """
            self._values: typing.Dict[str, typing.Any] = {
                "size": size,
            }
            if auto_snapshot_policy_id is not None:
                self._values["auto_snapshot_policy_id"] = auto_snapshot_policy_id
            if category is not None:
                self._values["category"] = category
            if description is not None:
                self._values["description"] = description
            if device is not None:
                self._values["device"] = device
            if disk_name is not None:
                self._values["disk_name"] = disk_name
            if encrypted is not None:
                self._values["encrypted"] = encrypted
            if kms_key_id is not None:
                self._values["kms_key_id"] = kms_key_id
            if performance_level is not None:
                self._values["performance_level"] = performance_level
            if snapshot_id is not None:
                self._values["snapshot_id"] = snapshot_id

        @builtins.property
        def size(self) -> builtins.str:
            """
            :Property: size: The size of the volume, unit in GB.Value range: cloud: [5,2000], cloud_efficiency: [20,32768], cloud_ssd: [20,32768], cloud_essd: [20,32768], ephemeral_ssd: [5,800].The value should be equal to or greater than the specific snapshot.
            """
            result = self._values.get("size")
            assert result is not None, "Required property 'size' is missing"
            return result

        @builtins.property
        def auto_snapshot_policy_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: autoSnapshotPolicyId: Auto snapshot policy ID.
            """
            result = self._values.get("auto_snapshot_policy_id")
            return result

        @builtins.property
        def category(self) -> typing.Optional[builtins.str]:
            """
            :Property: category: The volume type.Now support: cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd. Default is cloud_efficiency.
            """
            result = self._values.get("category")
            return result

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            """
            :Property: description: Description of the disk, [2, 256] characters. Do not fill or empty, the default is empty.
            """
            result = self._values.get("description")
            return result

        @builtins.property
        def device(self) -> typing.Optional[builtins.str]:
            """
            :Property: device: The device where the volume is exposed on the instance. could be /dev/xvd[a-z]. If not specification, will use default value.
            """
            result = self._values.get("device")
            return result

        @builtins.property
        def disk_name(self) -> typing.Optional[builtins.str]:
            """
            :Property: diskName: Display name of the disk, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'.
            """
            result = self._values.get("disk_name")
            return result

        @builtins.property
        def encrypted(self) -> typing.Optional[builtins.str]:
            """
            :Property:

            encrypted: Whether the data disk is encrypted or not. Options:
            true: Encrypted.
            false: Not encrypted.
            Default value: false.
            """
            result = self._values.get("encrypted")
            return result

        @builtins.property
        def kms_key_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: kmsKeyId: The KMS key ID for the data disk.
            """
            result = self._values.get("kms_key_id")
            return result

        @builtins.property
        def performance_level(self) -> typing.Optional[builtins.str]:
            """
            :Property: performanceLevel: The performance level of the enhanced SSD used as the Nth data disk.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
            """
            result = self._values.get("performance_level")
            return result

        @builtins.property
        def snapshot_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: snapshotId: ID of the snapshot to create the volume.
            """
            result = self._values.get("snapshot_id")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DiskMappingsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosPrepayInstanceGroupClone.EniMappingsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "security_group_id": "securityGroupId",
            "v_switch_id": "vSwitchId",
            "description": "description",
            "network_interface_name": "networkInterfaceName",
            "primary_ip_address": "primaryIpAddress",
        },
    )
    class EniMappingsProperty:
        def __init__(
            self,
            *,
            security_group_id: builtins.str,
            v_switch_id: builtins.str,
            description: typing.Optional[builtins.str] = None,
            network_interface_name: typing.Optional[builtins.str] = None,
            primary_ip_address: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param security_group_id: 
            :param v_switch_id: 
            :param description: 
            :param network_interface_name: 
            :param primary_ip_address: 
            """
            self._values: typing.Dict[str, typing.Any] = {
                "security_group_id": security_group_id,
                "v_switch_id": v_switch_id,
            }
            if description is not None:
                self._values["description"] = description
            if network_interface_name is not None:
                self._values["network_interface_name"] = network_interface_name
            if primary_ip_address is not None:
                self._values["primary_ip_address"] = primary_ip_address

        @builtins.property
        def security_group_id(self) -> builtins.str:
            """
            :Property: securityGroupId: The ID of the security group that the ENI joins. The security group and the ENI must be in a same VPC.
            """
            result = self._values.get("security_group_id")
            assert result is not None, "Required property 'security_group_id' is missing"
            return result

        @builtins.property
        def v_switch_id(self) -> builtins.str:
            """
            :Property: vSwitchId: VSwitch ID of the specified VPC. Specifies the switch ID for the VPC.
            """
            result = self._values.get("v_switch_id")
            assert result is not None, "Required property 'v_switch_id' is missing"
            return result

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            """
            :Property: description: Description of your ENI. It is a string of [2, 256] English or Chinese characters.
            """
            result = self._values.get("description")
            return result

        @builtins.property
        def network_interface_name(self) -> typing.Optional[builtins.str]:
            """
            :Property: networkInterfaceName: Name of your ENI. It is a string of [2, 128]  Chinese or English characters. It must begin with a letter and can contain numbers, underscores (_), colons (:), or hyphens (-).
            """
            result = self._values.get("network_interface_name")
            return result

        @builtins.property
        def primary_ip_address(self) -> typing.Optional[builtins.str]:
            """
            :Property: primaryIpAddress: The primary private IP address of the ENI.  The specified IP address must have the same Host ID as the VSwitch. If no IP addresses are specified, a random network ID is assigned for the ENI.
            """
            result = self._values.get("primary_ip_address")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EniMappingsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosPrepayInstanceGroupCloneProps",
    jsii_struct_bases=[],
    name_mapping={
        "max_amount": "maxAmount",
        "min_amount": "minAmount",
        "period": "period",
        "period_type": "periodType",
        "source_instance_id": "sourceInstanceId",
        "auto_renew": "autoRenew",
        "auto_renew_period": "autoRenewPeriod",
        "deployment_set_id": "deploymentSetId",
        "description": "description",
        "disk_mappings": "diskMappings",
        "eni_mappings": "eniMappings",
        "hpc_cluster_id": "hpcClusterId",
        "image_id": "imageId",
        "instance_name": "instanceName",
        "internet_max_bandwidth_in": "internetMaxBandwidthIn",
        "internet_max_bandwidth_out": "internetMaxBandwidthOut",
        "key_pair_name": "keyPairName",
        "launch_template_id": "launchTemplateId",
        "launch_template_name": "launchTemplateName",
        "launch_template_version": "launchTemplateVersion",
        "password": "password",
        "password_inherit": "passwordInherit",
        "period_unit": "periodUnit",
        "ram_role_name": "ramRoleName",
        "security_group_id": "securityGroupId",
        "security_group_ids": "securityGroupIds",
        "system_disk_auto_snapshot_policy_id": "systemDiskAutoSnapshotPolicyId",
        "system_disk_category": "systemDiskCategory",
        "system_disk_description": "systemDiskDescription",
        "system_disk_disk_name": "systemDiskDiskName",
        "tags": "tags",
        "zone_id": "zoneId",
    },
)
class RosPrepayInstanceGroupCloneProps:
    def __init__(
        self,
        *,
        max_amount: jsii.Number,
        min_amount: jsii.Number,
        period: jsii.Number,
        period_type: builtins.str,
        source_instance_id: builtins.str,
        auto_renew: typing.Optional[builtins.str] = None,
        auto_renew_period: typing.Optional[jsii.Number] = None,
        deployment_set_id: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        disk_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosPrepayInstanceGroupClone.DiskMappingsProperty]]]] = None,
        eni_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosPrepayInstanceGroupClone.EniMappingsProperty]]]] = None,
        hpc_cluster_id: typing.Optional[builtins.str] = None,
        image_id: typing.Optional[builtins.str] = None,
        instance_name: typing.Optional[builtins.str] = None,
        internet_max_bandwidth_in: typing.Optional[jsii.Number] = None,
        internet_max_bandwidth_out: typing.Optional[jsii.Number] = None,
        key_pair_name: typing.Optional[builtins.str] = None,
        launch_template_id: typing.Optional[builtins.str] = None,
        launch_template_name: typing.Optional[builtins.str] = None,
        launch_template_version: typing.Optional[builtins.str] = None,
        password: typing.Optional[builtins.str] = None,
        password_inherit: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        period_unit: typing.Optional[builtins.str] = None,
        ram_role_name: typing.Optional[builtins.str] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        security_group_ids: typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]] = None,
        system_disk_auto_snapshot_policy_id: typing.Optional[builtins.str] = None,
        system_disk_category: typing.Optional[builtins.str] = None,
        system_disk_description: typing.Optional[builtins.str] = None,
        system_disk_disk_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.List[ros_cdk_core.RosTag]] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::PrepayInstanceGroupClone``.

        :param max_amount: 
        :param min_amount: 
        :param period: 
        :param period_type: 
        :param source_instance_id: 
        :param auto_renew: 
        :param auto_renew_period: 
        :param deployment_set_id: 
        :param description: 
        :param disk_mappings: 
        :param eni_mappings: 
        :param hpc_cluster_id: 
        :param image_id: 
        :param instance_name: 
        :param internet_max_bandwidth_in: 
        :param internet_max_bandwidth_out: 
        :param key_pair_name: 
        :param launch_template_id: 
        :param launch_template_name: 
        :param launch_template_version: 
        :param password: 
        :param password_inherit: 
        :param period_unit: 
        :param ram_role_name: 
        :param security_group_id: 
        :param security_group_ids: 
        :param system_disk_auto_snapshot_policy_id: 
        :param system_disk_category: 
        :param system_disk_description: 
        :param system_disk_disk_name: 
        :param tags: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "max_amount": max_amount,
            "min_amount": min_amount,
            "period": period,
            "period_type": period_type,
            "source_instance_id": source_instance_id,
        }
        if auto_renew is not None:
            self._values["auto_renew"] = auto_renew
        if auto_renew_period is not None:
            self._values["auto_renew_period"] = auto_renew_period
        if deployment_set_id is not None:
            self._values["deployment_set_id"] = deployment_set_id
        if description is not None:
            self._values["description"] = description
        if disk_mappings is not None:
            self._values["disk_mappings"] = disk_mappings
        if eni_mappings is not None:
            self._values["eni_mappings"] = eni_mappings
        if hpc_cluster_id is not None:
            self._values["hpc_cluster_id"] = hpc_cluster_id
        if image_id is not None:
            self._values["image_id"] = image_id
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if internet_max_bandwidth_in is not None:
            self._values["internet_max_bandwidth_in"] = internet_max_bandwidth_in
        if internet_max_bandwidth_out is not None:
            self._values["internet_max_bandwidth_out"] = internet_max_bandwidth_out
        if key_pair_name is not None:
            self._values["key_pair_name"] = key_pair_name
        if launch_template_id is not None:
            self._values["launch_template_id"] = launch_template_id
        if launch_template_name is not None:
            self._values["launch_template_name"] = launch_template_name
        if launch_template_version is not None:
            self._values["launch_template_version"] = launch_template_version
        if password is not None:
            self._values["password"] = password
        if password_inherit is not None:
            self._values["password_inherit"] = password_inherit
        if period_unit is not None:
            self._values["period_unit"] = period_unit
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if system_disk_auto_snapshot_policy_id is not None:
            self._values["system_disk_auto_snapshot_policy_id"] = system_disk_auto_snapshot_policy_id
        if system_disk_category is not None:
            self._values["system_disk_category"] = system_disk_category
        if system_disk_description is not None:
            self._values["system_disk_description"] = system_disk_description
        if system_disk_disk_name is not None:
            self._values["system_disk_disk_name"] = system_disk_disk_name
        if tags is not None:
            self._values["tags"] = tags
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def max_amount(self) -> jsii.Number:
        """
        :Property: maxAmount: Max number of instances to create, should be smaller than 'MaxAmount' and smaller than 100.
        """
        result = self._values.get("max_amount")
        assert result is not None, "Required property 'max_amount' is missing"
        return result

    @builtins.property
    def min_amount(self) -> jsii.Number:
        """
        :Property: minAmount: Max number of instances to create, should be bigger than 'MinAmount' and smaller than 100.
        """
        result = self._values.get("min_amount")
        assert result is not None, "Required property 'min_amount' is missing"
        return result

    @builtins.property
    def period(self) -> jsii.Number:
        """
        :Property: period: Prepaid time period. While choose by pay by month, it could be from 1 to 9. While choose pay by year, it could be from 1 to 3.
        """
        result = self._values.get("period")
        assert result is not None, "Required property 'period' is missing"
        return result

    @builtins.property
    def period_type(self) -> builtins.str:
        """
        :Property: periodType: Charge period for created instances.
        """
        result = self._values.get("period_type")
        assert result is not None, "Required property 'period_type' is missing"
        return result

    @builtins.property
    def source_instance_id(self) -> builtins.str:
        """
        :Property: sourceInstanceId: Source ecs instance used to copy properties to clone new ecs instance. It will copy the InstanceType, ImageId, InternetChargeType, InternetMaxBandwidthIn, InternetMaxBandwidthOut and the system disk and data disk configurations. If the instance network is VPC, it will also clone the relative properties. If specified instance with more than one security group, it will use the first security group to create instance. you can also specify the SecurityGroupId to override it.
        """
        result = self._values.get("source_instance_id")
        assert result is not None, "Required property 'source_instance_id' is missing"
        return result

    @builtins.property
    def auto_renew(self) -> typing.Optional[builtins.str]:
        """
        :Property: autoRenew: Whether renew the fee automatically? When the parameter InstanceChargeType is PrePaid, it will take effect. Range of value:True: automatic renewal.False: no automatic renewal. Default value is False.Old instances will not be changed.
        """
        result = self._values.get("auto_renew")
        return result

    @builtins.property
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.Old instances will not be changed.
        """
        result = self._values.get("auto_renew_period")
        return result

    @builtins.property
    def deployment_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: deploymentSetId: Deployment set ID. The change of the property does not affect existing instances.
        """
        result = self._values.get("deployment_set_id")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty. Old instances will not be changed.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosPrepayInstanceGroupClone.DiskMappingsProperty]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.Old instances will not be changed.
        """
        result = self._values.get("disk_mappings")
        return result

    @builtins.property
    def eni_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosPrepayInstanceGroupClone.EniMappingsProperty]]]]:
        """
        :Property: eniMappings: NetworkInterface to attach to instance. Max support 1 ENI.
        """
        result = self._values.get("eni_mappings")
        return result

    @builtins.property
    def hpc_cluster_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.The change of the property does not affect existing instances.
        """
        result = self._values.get("hpc_cluster_id")
        return result

    @builtins.property
    def image_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        result = self._values.get("image_id")
        return result

    @builtins.property
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("instance_name")
        return result

    @builtins.property
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        result = self._values.get("internet_max_bandwidth_in")
        return result

    @builtins.property
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Set internet output bandwidth of instance. Unit is Mbps(Mega bit per second). Range is [0,200]. Default is 1.While the property is not 0, public ip will be assigned for instance.
        """
        result = self._values.get("internet_max_bandwidth_out")
        return result

    @builtins.property
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.Old instances will not be changed.
        """
        result = self._values.get("key_pair_name")
        return result

    @builtins.property
    def launch_template_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateId: ID of launch template. Launch template id or name must be specified to use launch template
        """
        result = self._values.get("launch_template_id")
        return result

    @builtins.property
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateName: Name of launch template. Launch template id or name must be specified to use launch template
        """
        result = self._values.get("launch_template_name")
        return result

    @builtins.property
    def launch_template_version(self) -> typing.Optional[builtins.str]:
        """
        :Property: launchTemplateVersion: Version of launch template. Default version is used if version is not specified.
        """
        result = self._values.get("launch_template_version")
        return result

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        result = self._values.get("password")
        return result

    @builtins.property
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: passwordInherit: Specifies whether to use the password preset in the image. To use the PasswordInherit parameter, the Password parameter must be empty and you must make sure that the selected image has a password configured.
        """
        result = self._values.get("password_inherit")
        return result

    @builtins.property
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month. Default value is Month.Old instances will not be changed.
        """
        result = self._values.get("period_unit")
        return result

    @builtins.property
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        result = self._values.get("ram_role_name")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def security_group_ids(
        self,
    ) -> typing.Optional[typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]]:
        """
        :Property: securityGroupIds: The IDs of security groups N to which the instance belongs. The valid values of N are based on the maximum number of security groups to which an instance can belong. For more information, see Security group limits.Note: You cannot specify both SecurityGroupId and SecurityGroupIds at the same time.
        """
        result = self._values.get("security_group_ids")
        return result

    @builtins.property
    def system_disk_auto_snapshot_policy_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskAutoSnapshotPolicyId: Auto snapshot policy ID.
        """
        result = self._values.get("system_disk_auto_snapshot_policy_id")
        return result

    @builtins.property
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. Default is cloud_efficiency. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd.Old instances will not be changed.
        """
        result = self._values.get("system_disk_category")
        return result

    @builtins.property
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.Old instances will not be changed.
        """
        result = self._values.get("system_disk_description")
        return result

    @builtins.property
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.Old instances will not be changed.
        """
        result = self._values.get("system_disk_disk_name")
        return result

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[ros_cdk_core.RosTag]]:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosPrepayInstanceGroupCloneProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosPrepayInstanceProps",
    jsii_struct_bases=[],
    name_mapping={
        "image_id": "imageId",
        "instance_type": "instanceType",
        "max_amount": "maxAmount",
        "min_amount": "minAmount",
        "period": "period",
        "period_type": "periodType",
        "allocate_public_ip": "allocatePublicIp",
        "auto_renew": "autoRenew",
        "auto_renew_period": "autoRenewPeriod",
        "dedicated_host_id": "dedicatedHostId",
        "deployment_set_id": "deploymentSetId",
        "description": "description",
        "disk_mappings": "diskMappings",
        "host_name": "hostName",
        "hpc_cluster_id": "hpcClusterId",
        "instance_charge_type": "instanceChargeType",
        "instance_name": "instanceName",
        "internet_charge_type": "internetChargeType",
        "internet_max_bandwidth_in": "internetMaxBandwidthIn",
        "internet_max_bandwidth_out": "internetMaxBandwidthOut",
        "io_optimized": "ioOptimized",
        "key_pair_name": "keyPairName",
        "password": "password",
        "password_inherit": "passwordInherit",
        "period_unit": "periodUnit",
        "private_ip_address": "privateIpAddress",
        "ram_role_name": "ramRoleName",
        "security_enhancement_strategy": "securityEnhancementStrategy",
        "security_group_id": "securityGroupId",
        "system_disk_category": "systemDiskCategory",
        "system_disk_description": "systemDiskDescription",
        "system_disk_disk_name": "systemDiskDiskName",
        "system_disk_performance_level": "systemDiskPerformanceLevel",
        "system_disk_size": "systemDiskSize",
        "tags": "tags",
        "user_data": "userData",
        "vpc_id": "vpcId",
        "v_switch_id": "vSwitchId",
        "zone_id": "zoneId",
    },
)
class RosPrepayInstanceProps:
    def __init__(
        self,
        *,
        image_id: builtins.str,
        instance_type: builtins.str,
        max_amount: jsii.Number,
        min_amount: jsii.Number,
        period: jsii.Number,
        period_type: builtins.str,
        allocate_public_ip: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        auto_renew: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        auto_renew_period: typing.Optional[jsii.Number] = None,
        dedicated_host_id: typing.Optional[builtins.str] = None,
        deployment_set_id: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        disk_mappings: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosPrepayInstance.DiskMappingsProperty]]]] = None,
        host_name: typing.Optional[builtins.str] = None,
        hpc_cluster_id: typing.Optional[builtins.str] = None,
        instance_charge_type: typing.Optional[builtins.str] = None,
        instance_name: typing.Optional[builtins.str] = None,
        internet_charge_type: typing.Optional[builtins.str] = None,
        internet_max_bandwidth_in: typing.Optional[jsii.Number] = None,
        internet_max_bandwidth_out: typing.Optional[jsii.Number] = None,
        io_optimized: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        key_pair_name: typing.Optional[builtins.str] = None,
        password: typing.Optional[builtins.str] = None,
        password_inherit: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        period_unit: typing.Optional[builtins.str] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        ram_role_name: typing.Optional[builtins.str] = None,
        security_enhancement_strategy: typing.Optional[builtins.str] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        system_disk_category: typing.Optional[builtins.str] = None,
        system_disk_description: typing.Optional[builtins.str] = None,
        system_disk_disk_name: typing.Optional[builtins.str] = None,
        system_disk_performance_level: typing.Optional[builtins.str] = None,
        system_disk_size: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.List[ros_cdk_core.RosTag]] = None,
        user_data: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
        v_switch_id: typing.Optional[builtins.str] = None,
        zone_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::PrepayInstance``.

        :param image_id: 
        :param instance_type: 
        :param max_amount: 
        :param min_amount: 
        :param period: 
        :param period_type: 
        :param allocate_public_ip: 
        :param auto_renew: 
        :param auto_renew_period: 
        :param dedicated_host_id: 
        :param deployment_set_id: 
        :param description: 
        :param disk_mappings: 
        :param host_name: 
        :param hpc_cluster_id: 
        :param instance_charge_type: 
        :param instance_name: 
        :param internet_charge_type: 
        :param internet_max_bandwidth_in: 
        :param internet_max_bandwidth_out: 
        :param io_optimized: 
        :param key_pair_name: 
        :param password: 
        :param password_inherit: 
        :param period_unit: 
        :param private_ip_address: 
        :param ram_role_name: 
        :param security_enhancement_strategy: 
        :param security_group_id: 
        :param system_disk_category: 
        :param system_disk_description: 
        :param system_disk_disk_name: 
        :param system_disk_performance_level: 
        :param system_disk_size: 
        :param tags: 
        :param user_data: 
        :param vpc_id: 
        :param v_switch_id: 
        :param zone_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "image_id": image_id,
            "instance_type": instance_type,
            "max_amount": max_amount,
            "min_amount": min_amount,
            "period": period,
            "period_type": period_type,
        }
        if allocate_public_ip is not None:
            self._values["allocate_public_ip"] = allocate_public_ip
        if auto_renew is not None:
            self._values["auto_renew"] = auto_renew
        if auto_renew_period is not None:
            self._values["auto_renew_period"] = auto_renew_period
        if dedicated_host_id is not None:
            self._values["dedicated_host_id"] = dedicated_host_id
        if deployment_set_id is not None:
            self._values["deployment_set_id"] = deployment_set_id
        if description is not None:
            self._values["description"] = description
        if disk_mappings is not None:
            self._values["disk_mappings"] = disk_mappings
        if host_name is not None:
            self._values["host_name"] = host_name
        if hpc_cluster_id is not None:
            self._values["hpc_cluster_id"] = hpc_cluster_id
        if instance_charge_type is not None:
            self._values["instance_charge_type"] = instance_charge_type
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if internet_charge_type is not None:
            self._values["internet_charge_type"] = internet_charge_type
        if internet_max_bandwidth_in is not None:
            self._values["internet_max_bandwidth_in"] = internet_max_bandwidth_in
        if internet_max_bandwidth_out is not None:
            self._values["internet_max_bandwidth_out"] = internet_max_bandwidth_out
        if io_optimized is not None:
            self._values["io_optimized"] = io_optimized
        if key_pair_name is not None:
            self._values["key_pair_name"] = key_pair_name
        if password is not None:
            self._values["password"] = password
        if password_inherit is not None:
            self._values["password_inherit"] = password_inherit
        if period_unit is not None:
            self._values["period_unit"] = period_unit
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address
        if ram_role_name is not None:
            self._values["ram_role_name"] = ram_role_name
        if security_enhancement_strategy is not None:
            self._values["security_enhancement_strategy"] = security_enhancement_strategy
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if system_disk_category is not None:
            self._values["system_disk_category"] = system_disk_category
        if system_disk_description is not None:
            self._values["system_disk_description"] = system_disk_description
        if system_disk_disk_name is not None:
            self._values["system_disk_disk_name"] = system_disk_disk_name
        if system_disk_performance_level is not None:
            self._values["system_disk_performance_level"] = system_disk_performance_level
        if system_disk_size is not None:
            self._values["system_disk_size"] = system_disk_size
        if tags is not None:
            self._values["tags"] = tags
        if user_data is not None:
            self._values["user_data"] = user_data
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id
        if v_switch_id is not None:
            self._values["v_switch_id"] = v_switch_id
        if zone_id is not None:
            self._values["zone_id"] = zone_id

    @builtins.property
    def image_id(self) -> builtins.str:
        """
        :Property: imageId: Image ID to create ecs instance.
        """
        result = self._values.get("image_id")
        assert result is not None, "Required property 'image_id' is missing"
        return result

    @builtins.property
    def instance_type(self) -> builtins.str:
        """
        :Property: instanceType: Ecs instance supported instance type, make sure it should be correct.
        """
        result = self._values.get("instance_type")
        assert result is not None, "Required property 'instance_type' is missing"
        return result

    @builtins.property
    def max_amount(self) -> jsii.Number:
        """
        :Property: maxAmount: Max number of instances to create, should be smaller than 'MaxAmount' and smaller than 100.
        """
        result = self._values.get("max_amount")
        assert result is not None, "Required property 'max_amount' is missing"
        return result

    @builtins.property
    def min_amount(self) -> jsii.Number:
        """
        :Property: minAmount: Max number of instances to create, should be bigger than 'MinAmount' and smaller than 100.
        """
        result = self._values.get("min_amount")
        assert result is not None, "Required property 'min_amount' is missing"
        return result

    @builtins.property
    def period(self) -> jsii.Number:
        """
        :Property: period: Prepaid time period. While choose by pay by month, it could be from 1 to 9. While choose pay by year, it could be from 1 to 3.
        """
        result = self._values.get("period")
        assert result is not None, "Required property 'period' is missing"
        return result

    @builtins.property
    def period_type(self) -> builtins.str:
        """
        :Property: periodType: Charge period for created instances.
        """
        result = self._values.get("period_type")
        assert result is not None, "Required property 'period_type' is missing"
        return result

    @builtins.property
    def allocate_public_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: allocatePublicIp: The public ip for ecs instance, if properties is true, will allocate public ip. If property InternetMaxBandwidthOut set to 0, it will not assign public ip.
        """
        result = self._values.get("allocate_public_ip")
        return result

    @builtins.property
    def auto_renew(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: autoRenew: Auto renew the prepay instance. If the period type is by year, it will renew by year, else it will renew by month.
        """
        result = self._values.get("auto_renew")
        return result

    @builtins.property
    def auto_renew_period(self) -> typing.Optional[jsii.Number]:
        """
        :Property: autoRenewPeriod: The time period of auto renew. When the parameter InstanceChargeType is PrePaid, it will take effect.It could be 1, 2, 3, 6, 12. Default value is 1.
        """
        result = self._values.get("auto_renew_period")
        return result

    @builtins.property
    def dedicated_host_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: dedicatedHostId: which dedicated host will be deployed
        """
        result = self._values.get("dedicated_host_id")
        return result

    @builtins.property
    def deployment_set_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: deploymentSetId: Deployment set ID.
        """
        result = self._values.get("deployment_set_id")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the instance, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def disk_mappings(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosPrepayInstance.DiskMappingsProperty]]]]:
        """
        :Property:

        diskMappings: Disk mappings to attach to instance. Max support 16 disks.
        If the image contains a data disk, you can specify other parameters of the data disk via the same value of parameter "Device". If parameter "Category" is not specified, it will be cloud_efficiency instead of "Category" of data disk in the image.
        """
        result = self._values.get("disk_mappings")
        return result

    @builtins.property
    def host_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: hostName: Host name of created ecs instance. at least 2 characters, and '.' '-' Is not the first and last characters as hostname, not continuous use. Windows platform can be up to 15 characters, allowing letters (without limiting case), numbers and '-', and does not support the number of points, not all is digital ('.').Other (Linux, etc.) platform up to 30 characters, allowing support number multiple points for the period between the points, each permit letters (without limiting case), numbers and '-' components.
        """
        result = self._values.get("host_name")
        return result

    @builtins.property
    def hpc_cluster_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: hpcClusterId: The HPC cluster ID to which the instance belongs.
        """
        result = self._values.get("hpc_cluster_id")
        return result

    @builtins.property
    def instance_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceChargeType: Instance Charge type, allowed value: Prepaid and Postpaid. If specified Prepaid, please ensure you have sufficient balance in your account. Or instance creation will be failure. Default value is Postpaid.
        """
        result = self._values.get("instance_charge_type")
        return result

    @builtins.property
    def instance_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: instanceName: Display name of the instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("instance_name")
        return result

    @builtins.property
    def internet_charge_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: internetChargeType: Instance internet access charge type.Support 'PayByBandwidth' and 'PayByTraffic' only. For AfterPay instance, default is 'PayByBandwidth'.
        """
        result = self._values.get("internet_charge_type")
        return result

    @builtins.property
    def internet_max_bandwidth_in(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthIn: Max internet out band width setting, unit in Mbps(Mega bit per second). The range is [1,200], default is 200 Mbps.
        """
        result = self._values.get("internet_max_bandwidth_in")
        return result

    @builtins.property
    def internet_max_bandwidth_out(self) -> typing.Optional[jsii.Number]:
        """
        :Property: internetMaxBandwidthOut: Set internet output bandwidth of instance. Unit is Mbps(Mega bit per second). Range is [0,200]. Default is 1.While the property is not 0, public ip will be assigned for instance.
        """
        result = self._values.get("internet_max_bandwidth_out")
        return result

    @builtins.property
    def io_optimized(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: ioOptimized: The 'optimized' instance can provide better IO performance. Support true or false, Default is true.
        """
        result = self._values.get("io_optimized")
        return result

    @builtins.property
    def key_pair_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: keyPairName: SSH key pair name.
        """
        result = self._values.get("key_pair_name")
        return result

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        """
        :Property: password: Password of created ecs instance. Must contain at least 3 types of special character, lower character, upper character, number.
        """
        result = self._values.get("password")
        return result

    @builtins.property
    def password_inherit(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: passwordInherit: Specifies whether to use the password preset in the image. To use the PasswordInherit parameter, the Password parameter must be empty and you must make sure that the selected image has a password configured.
        """
        result = self._values.get("password_inherit")
        return result

    @builtins.property
    def period_unit(self) -> typing.Optional[builtins.str]:
        """
        :Property: periodUnit: Unit of prepaid time period, it could be Week/Month/Year. Default value is Month.
        """
        result = self._values.get("period_unit")
        return result

    @builtins.property
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        """
        :Property: privateIpAddress: Private IP for the instance created. Only works for VPC instance and cannot duplicated with existing instance.
        """
        result = self._values.get("private_ip_address")
        return result

    @builtins.property
    def ram_role_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: ramRoleName: Instance RAM role name. The name is provided and maintained by Resource Access Management (RAM) and can be queried using ListRoles. For more information, see RAM API CreateRole and ListRoles.
        """
        result = self._values.get("ram_role_name")
        return result

    @builtins.property
    def security_enhancement_strategy(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityEnhancementStrategy:
        """
        result = self._values.get("security_enhancement_strategy")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Security group to create ecs instance. For classic instance need the security group not belong to VPC, for VPC instance, please make sure the security group belong to specified VPC.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def system_disk_category(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskCategory: Category of system disk. Default is cloud_efficiency. support cloud|cloud_efficiency|cloud_ssd|cloud_essd|ephemeral_ssd
        """
        result = self._values.get("system_disk_category")
        return result

    @builtins.property
    def system_disk_description(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDescription: Description of created system disk.
        """
        result = self._values.get("system_disk_description")
        return result

    @builtins.property
    def system_disk_disk_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskDiskName: Name of created system disk.
        """
        result = self._values.get("system_disk_disk_name")
        return result

    @builtins.property
    def system_disk_performance_level(self) -> typing.Optional[builtins.str]:
        """
        :Property: systemDiskPerformanceLevel: The performance level of the enhanced SSD used as the system disk.Default value: PL1. Valid values:PL0: A single enhanced SSD delivers up to 10,000 random read/write IOPS.PL1: A single enhanced SSD delivers up to 50,000 random read/write IOPS.PL2: A single enhanced SSD delivers up to 100,000 random read/write IOPS.PL3: A single enhanced SSD delivers up to 1,000,000 random read/write IOPS.
        """
        result = self._values.get("system_disk_performance_level")
        return result

    @builtins.property
    def system_disk_size(self) -> typing.Optional[jsii.Number]:
        """
        :Property: systemDiskSize: Disk size of the system disk, range from 20 to 500 GB. If you specify with your own image, make sure the system disk size bigger than image size.
        """
        result = self._values.get("system_disk_size")
        return result

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[ros_cdk_core.RosTag]]:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def user_data(self) -> typing.Optional[builtins.str]:
        """
        :Property: userData: User data to pass to instance. [1, 16KB] characters.User data should not be base64 encoded. If you want to pass base64 encoded string to the property, use function Fn::Base64Decode to decode the base64 string first.
        """
        result = self._values.get("user_data")
        return result

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcId: The VPC id to create ecs instance.
        """
        result = self._values.get("vpc_id")
        return result

    @builtins.property
    def v_switch_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vSwitchId: The vSwitch Id to create ecs instance.
        """
        result = self._values.get("v_switch_id")
        return result

    @builtins.property
    def zone_id(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        zoneId: The ID of the zone to which the instance belongs. For more information,
        call the DescribeZones operation to query the most recent zone list.
        Default value is empty, which means random selection.
        """
        result = self._values.get("zone_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosPrepayInstanceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosRoute(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosRoute",
):
    """A ROS template type:  ``ALIYUN::ECS::Route``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosRouteProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::Route``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosRoute, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="destinationCidrBlock")
    def destination_cidr_block(self) -> builtins.str:
        """
        :Property: destinationCidrBlock: The RouteEntry's target network segment.
        """
        return jsii.get(self, "destinationCidrBlock")

    @destination_cidr_block.setter # type: ignore
    def destination_cidr_block(self, value: builtins.str) -> None:
        jsii.set(self, "destinationCidrBlock", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        """A factory method that creates a new instance of this class from an object
containing the properties of this ROS resource."""
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="routeId")
    def route_id(self) -> builtins.str:
        """
        :Property: routeId: RouteId of created route entry.
        """
        return jsii.get(self, "routeId")

    @route_id.setter # type: ignore
    def route_id(self, value: builtins.str) -> None:
        jsii.set(self, "routeId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="routeTableId")
    def route_table_id(self) -> builtins.str:
        """
        :Property: routeTableId: RouteTableId of created route entry.
        """
        return jsii.get(self, "routeTableId")

    @route_table_id.setter # type: ignore
    def route_table_id(self, value: builtins.str) -> None:
        jsii.set(self, "routeTableId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="nextHopId")
    def next_hop_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: nextHopId: The route entry's next hop. When the NextHopList is specified, the value will be ignored.
        """
        return jsii.get(self, "nextHopId")

    @next_hop_id.setter # type: ignore
    def next_hop_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "nextHopId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="nextHopList")
    def next_hop_list(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosRoute.NextHopListProperty"]]]]:
        """
        :Property: nextHopList: The route entry's next hop list. If router is virtual border router, the value will be ignore. The list should contain 2-4 next hop. NextHopId of each next hop must be RouterInterface that VRouter forwards to VBR.
        """
        return jsii.get(self, "nextHopList")

    @next_hop_list.setter # type: ignore
    def next_hop_list(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosRoute.NextHopListProperty"]]]],
    ) -> None:
        jsii.set(self, "nextHopList", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="nextHopType")
    def next_hop_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: nextHopType: The next hop type. Available value options: Instance | Tunnel | HaVip | RouterInterface. The default value is Instance.When the NextHopList is specified, the value will be ignored.
        """
        return jsii.get(self, "nextHopType")

    @next_hop_type.setter # type: ignore
    def next_hop_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "nextHopType", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosRoute.NextHopListProperty",
        jsii_struct_bases=[],
        name_mapping={"next_hop_id": "nextHopId", "next_hop_type": "nextHopType"},
    )
    class NextHopListProperty:
        def __init__(
            self,
            *,
            next_hop_id: builtins.str,
            next_hop_type: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param next_hop_id: 
            :param next_hop_type: 
            """
            self._values: typing.Dict[str, typing.Any] = {
                "next_hop_id": next_hop_id,
            }
            if next_hop_type is not None:
                self._values["next_hop_type"] = next_hop_type

        @builtins.property
        def next_hop_id(self) -> builtins.str:
            """
            :Property: nextHopId: Route entry next hop Instance id or Tunnel id.
            """
            result = self._values.get("next_hop_id")
            assert result is not None, "Required property 'next_hop_id' is missing"
            return result

        @builtins.property
        def next_hop_type(self) -> typing.Optional[builtins.str]:
            """
            :Property: nextHopType: Route entry next hop type. Now support 'Instance|Tunnel|HaVip|RouterInterface'.
            """
            result = self._values.get("next_hop_type")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NextHopListProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosRouteProps",
    jsii_struct_bases=[],
    name_mapping={
        "destination_cidr_block": "destinationCidrBlock",
        "route_id": "routeId",
        "route_table_id": "routeTableId",
        "next_hop_id": "nextHopId",
        "next_hop_list": "nextHopList",
        "next_hop_type": "nextHopType",
    },
)
class RosRouteProps:
    def __init__(
        self,
        *,
        destination_cidr_block: builtins.str,
        route_id: builtins.str,
        route_table_id: builtins.str,
        next_hop_id: typing.Optional[builtins.str] = None,
        next_hop_list: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosRoute.NextHopListProperty]]]] = None,
        next_hop_type: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::Route``.

        :param destination_cidr_block: 
        :param route_id: 
        :param route_table_id: 
        :param next_hop_id: 
        :param next_hop_list: 
        :param next_hop_type: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "destination_cidr_block": destination_cidr_block,
            "route_id": route_id,
            "route_table_id": route_table_id,
        }
        if next_hop_id is not None:
            self._values["next_hop_id"] = next_hop_id
        if next_hop_list is not None:
            self._values["next_hop_list"] = next_hop_list
        if next_hop_type is not None:
            self._values["next_hop_type"] = next_hop_type

    @builtins.property
    def destination_cidr_block(self) -> builtins.str:
        """
        :Property: destinationCidrBlock: The RouteEntry's target network segment.
        """
        result = self._values.get("destination_cidr_block")
        assert result is not None, "Required property 'destination_cidr_block' is missing"
        return result

    @builtins.property
    def route_id(self) -> builtins.str:
        """
        :Property: routeId: RouteId of created route entry.
        """
        result = self._values.get("route_id")
        assert result is not None, "Required property 'route_id' is missing"
        return result

    @builtins.property
    def route_table_id(self) -> builtins.str:
        """
        :Property: routeTableId: RouteTableId of created route entry.
        """
        result = self._values.get("route_table_id")
        assert result is not None, "Required property 'route_table_id' is missing"
        return result

    @builtins.property
    def next_hop_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: nextHopId: The route entry's next hop. When the NextHopList is specified, the value will be ignored.
        """
        result = self._values.get("next_hop_id")
        return result

    @builtins.property
    def next_hop_list(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosRoute.NextHopListProperty]]]]:
        """
        :Property: nextHopList: The route entry's next hop list. If router is virtual border router, the value will be ignore. The list should contain 2-4 next hop. NextHopId of each next hop must be RouterInterface that VRouter forwards to VBR.
        """
        result = self._values.get("next_hop_list")
        return result

    @builtins.property
    def next_hop_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: nextHopType: The next hop type. Available value options: Instance | Tunnel | HaVip | RouterInterface. The default value is Instance.When the NextHopList is specified, the value will be ignored.
        """
        result = self._values.get("next_hop_type")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosRouteProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosRunCommand(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosRunCommand",
):
    """A ROS template type:  ``ALIYUN::ECS::RunCommand``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosRunCommandProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::RunCommand``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosRunCommand, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrCommandId")
    def attr_command_id(self) -> typing.Any:
        """
        :Attribute: CommandId: The id of command created.
        """
        return jsii.get(self, "attrCommandId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInvokeId")
    def attr_invoke_id(self) -> typing.Any:
        """
        :Attribute: InvokeId: The invoke id of command.
        """
        return jsii.get(self, "attrInvokeId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="commandContent")
    def command_content(self) -> builtins.str:
        """
        :Property:

        commandContent: The plaintext content or the Base64-encoded content of the script. The Base64-encoded script content cannot exceed 16 KB.
        You can enable the custom parameter function by setting EnableParameter=true in the script content:
        Define custom parameters in the {{}} format. Within {{}}, the spaces and line breaks before and after the name of the parameter are ignored.
        The number of custom parameters cannot exceed 20.
        A custom parameter name can contain only letters, digits, underscores (_), and hyphens (-). It is case insensitive.
        Each custom parameter key cannot exceed 64 bytes.
        """
        return jsii.get(self, "commandContent")

    @command_content.setter # type: ignore
    def command_content(self, value: builtins.str) -> None:
        jsii.set(self, "commandContent", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceIds")
    def instance_ids(self) -> typing.List[builtins.str]:
        """
        :Property: instanceIds: The instance id list. Select up to 20 instances at a time.Instances status must be running.
        """
        return jsii.get(self, "instanceIds")

    @instance_ids.setter # type: ignore
    def instance_ids(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "instanceIds", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        """
        :Property:

        type: The language type of the O&M script. Valid values:
        RunBatScript: batch scripts for Windows instances
        RunPowerShellScript: PowerShell scripts for Windows instances
        RunShellScript: shell scripts for Linux instances
        """
        return jsii.get(self, "type")

    @type.setter # type: ignore
    def type(self, value: builtins.str) -> None:
        jsii.set(self, "type", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="contentEncoding")
    def content_encoding(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        contentEncoding: The encoding mode of script content (CommandContent). Valid values (case insensitive):
        PlainText: The script content is not encoded, and transmitted in plaintext.
        Base64: base64-encoded.
        Default value: PlainText. If the specified value of this parameter is invalid, PlainText is used by default.
        """
        return jsii.get(self, "contentEncoding")

    @content_encoding.setter # type: ignore
    def content_encoding(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "contentEncoding", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: The description of the script, which supports all character sets. It can be up to 512 characters in length.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableParameter")
    def enable_parameter(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        enableParameter: Specifies whether the script contains custom parameters.
        Default value: false
        """
        return jsii.get(self, "enableParameter")

    @enable_parameter.setter # type: ignore
    def enable_parameter(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "enableParameter", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="frequency")
    def frequency(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        frequency: The execution period of recurring tasks. If the Timed parameter is set to True, you must specify the Frequency parameter. The interval between two recurring tasks cannot be less than 10 seconds.
        The parameter value follows the cron expression. For more information, see Configure scheduled commands.
        """
        return jsii.get(self, "frequency")

    @frequency.setter # type: ignore
    def frequency(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "frequency", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="keepCommand")
    def keep_command(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        keepCommand: Specifies whether to retain the script after it is run. Valid values:
        true: The script is retained. You can call the InvokeCommand operation to run the script again, call the DescribeCommands operation to query the script, and call the DeleteCommands operation to delete the script. The retained script takes up the quota of Cloud Assistant scripts.
        false: The script is not retained. It is automatically deleted after running, without taking up the quota of Cloud Assistant scripts.
        Default value: false
        """
        return jsii.get(self, "keepCommand")

    @keep_command.setter # type: ignore
    def keep_command(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "keepCommand", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="name")
    def name(self) -> typing.Optional[builtins.str]:
        """
        :Property: name: The name of the script, which supports all character sets. It can be up to 128 characters in length.
        """
        return jsii.get(self, "name")

    @name.setter # type: ignore
    def name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "name", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="parameters")
    def parameters(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property:

        parameters: The key-value pairs of custom parameters passed in when the script contains custom parameters.
        Number of custom parameters: 0 to 10.
        The key cannot be an empty string. It can be up to 64 characters in length.
        The value can be an empty string.
        After the custom parameters and the original script content are Base64 encoded, the total size cannot exceed 16 KB.
        The set of custom parameter names must be a subset of the parameter set that is defined when you created the script. You can use an empty string to represent the parameters that are not passed in.
        Default value: null, indicating that this parameter is canceled and customer parameters are disabled.
        """
        return jsii.get(self, "parameters")

    @parameters.setter # type: ignore
    def parameters(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.Mapping[builtins.str, typing.Any]]],
    ) -> None:
        jsii.set(self, "parameters", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="timed")
    def timed(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        timed: Specifies whether to periodically run the script. Valid values:
        true: runs the script on a regular basis based on the value set for the Frequency parameter. The result of the previous execution task does not affect the next execution task.
        false: runs once only.
        Default value: false
        """
        return jsii.get(self, "timed")

    @timed.setter # type: ignore
    def timed(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "timed", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="timeout")
    def timeout(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        timeout: The timeout period for script execution. Unit: seconds. A timeout error occurs when a script cannot be run because the process slows down, a specific module or the Cloud Assistant client does not exist. When the script times out, the script process is forcibly terminated.
        Default value: 60.
        """
        return jsii.get(self, "timeout")

    @timeout.setter # type: ignore
    def timeout(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "timeout", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="workingDir")
    def working_dir(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        workingDir: The running directory of the script in the ECS instance.
        Default value:
        Linux instances: under the home directory of the administrator (root user): /root.
        Windows instances: under the directory where the process of the Cloud Assistant client is located, such as C:\\ProgramData\\aliyun\\assist$(version).
        """
        return jsii.get(self, "workingDir")

    @working_dir.setter # type: ignore
    def working_dir(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "workingDir", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosRunCommandProps",
    jsii_struct_bases=[],
    name_mapping={
        "command_content": "commandContent",
        "instance_ids": "instanceIds",
        "type": "type",
        "content_encoding": "contentEncoding",
        "description": "description",
        "enable_parameter": "enableParameter",
        "frequency": "frequency",
        "keep_command": "keepCommand",
        "name": "name",
        "parameters": "parameters",
        "timed": "timed",
        "timeout": "timeout",
        "working_dir": "workingDir",
    },
)
class RosRunCommandProps:
    def __init__(
        self,
        *,
        command_content: builtins.str,
        instance_ids: typing.List[builtins.str],
        type: builtins.str,
        content_encoding: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        enable_parameter: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        frequency: typing.Optional[builtins.str] = None,
        keep_command: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        name: typing.Optional[builtins.str] = None,
        parameters: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.Mapping[builtins.str, typing.Any]]] = None,
        timed: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        timeout: typing.Optional[jsii.Number] = None,
        working_dir: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::RunCommand``.

        :param command_content: 
        :param instance_ids: 
        :param type: 
        :param content_encoding: 
        :param description: 
        :param enable_parameter: 
        :param frequency: 
        :param keep_command: 
        :param name: 
        :param parameters: 
        :param timed: 
        :param timeout: 
        :param working_dir: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "command_content": command_content,
            "instance_ids": instance_ids,
            "type": type,
        }
        if content_encoding is not None:
            self._values["content_encoding"] = content_encoding
        if description is not None:
            self._values["description"] = description
        if enable_parameter is not None:
            self._values["enable_parameter"] = enable_parameter
        if frequency is not None:
            self._values["frequency"] = frequency
        if keep_command is not None:
            self._values["keep_command"] = keep_command
        if name is not None:
            self._values["name"] = name
        if parameters is not None:
            self._values["parameters"] = parameters
        if timed is not None:
            self._values["timed"] = timed
        if timeout is not None:
            self._values["timeout"] = timeout
        if working_dir is not None:
            self._values["working_dir"] = working_dir

    @builtins.property
    def command_content(self) -> builtins.str:
        """
        :Property:

        commandContent: The plaintext content or the Base64-encoded content of the script. The Base64-encoded script content cannot exceed 16 KB.
        You can enable the custom parameter function by setting EnableParameter=true in the script content:
        Define custom parameters in the {{}} format. Within {{}}, the spaces and line breaks before and after the name of the parameter are ignored.
        The number of custom parameters cannot exceed 20.
        A custom parameter name can contain only letters, digits, underscores (_), and hyphens (-). It is case insensitive.
        Each custom parameter key cannot exceed 64 bytes.
        """
        result = self._values.get("command_content")
        assert result is not None, "Required property 'command_content' is missing"
        return result

    @builtins.property
    def instance_ids(self) -> typing.List[builtins.str]:
        """
        :Property: instanceIds: The instance id list. Select up to 20 instances at a time.Instances status must be running.
        """
        result = self._values.get("instance_ids")
        assert result is not None, "Required property 'instance_ids' is missing"
        return result

    @builtins.property
    def type(self) -> builtins.str:
        """
        :Property:

        type: The language type of the O&M script. Valid values:
        RunBatScript: batch scripts for Windows instances
        RunPowerShellScript: PowerShell scripts for Windows instances
        RunShellScript: shell scripts for Linux instances
        """
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return result

    @builtins.property
    def content_encoding(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        contentEncoding: The encoding mode of script content (CommandContent). Valid values (case insensitive):
        PlainText: The script content is not encoded, and transmitted in plaintext.
        Base64: base64-encoded.
        Default value: PlainText. If the specified value of this parameter is invalid, PlainText is used by default.
        """
        result = self._values.get("content_encoding")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: The description of the script, which supports all character sets. It can be up to 512 characters in length.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def enable_parameter(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        enableParameter: Specifies whether the script contains custom parameters.
        Default value: false
        """
        result = self._values.get("enable_parameter")
        return result

    @builtins.property
    def frequency(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        frequency: The execution period of recurring tasks. If the Timed parameter is set to True, you must specify the Frequency parameter. The interval between two recurring tasks cannot be less than 10 seconds.
        The parameter value follows the cron expression. For more information, see Configure scheduled commands.
        """
        result = self._values.get("frequency")
        return result

    @builtins.property
    def keep_command(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        keepCommand: Specifies whether to retain the script after it is run. Valid values:
        true: The script is retained. You can call the InvokeCommand operation to run the script again, call the DescribeCommands operation to query the script, and call the DeleteCommands operation to delete the script. The retained script takes up the quota of Cloud Assistant scripts.
        false: The script is not retained. It is automatically deleted after running, without taking up the quota of Cloud Assistant scripts.
        Default value: false
        """
        result = self._values.get("keep_command")
        return result

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """
        :Property: name: The name of the script, which supports all character sets. It can be up to 128 characters in length.
        """
        result = self._values.get("name")
        return result

    @builtins.property
    def parameters(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property:

        parameters: The key-value pairs of custom parameters passed in when the script contains custom parameters.
        Number of custom parameters: 0 to 10.
        The key cannot be an empty string. It can be up to 64 characters in length.
        The value can be an empty string.
        After the custom parameters and the original script content are Base64 encoded, the total size cannot exceed 16 KB.
        The set of custom parameter names must be a subset of the parameter set that is defined when you created the script. You can use an empty string to represent the parameters that are not passed in.
        Default value: null, indicating that this parameter is canceled and customer parameters are disabled.
        """
        result = self._values.get("parameters")
        return result

    @builtins.property
    def timed(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        timed: Specifies whether to periodically run the script. Valid values:
        true: runs the script on a regular basis based on the value set for the Frequency parameter. The result of the previous execution task does not affect the next execution task.
        false: runs once only.
        Default value: false
        """
        result = self._values.get("timed")
        return result

    @builtins.property
    def timeout(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        timeout: The timeout period for script execution. Unit: seconds. A timeout error occurs when a script cannot be run because the process slows down, a specific module or the Cloud Assistant client does not exist. When the script times out, the script process is forcibly terminated.
        Default value: 60.
        """
        result = self._values.get("timeout")
        return result

    @builtins.property
    def working_dir(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        workingDir: The running directory of the script in the ECS instance.
        Default value:
        Linux instances: under the home directory of the administrator (root user): /root.
        Windows instances: under the directory where the process of the Cloud Assistant client is located, such as C:\\ProgramData\\aliyun\\assist$(version).
        """
        result = self._values.get("working_dir")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosRunCommandProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosSNatEntry(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosSNatEntry",
):
    """A ROS template type:  ``ALIYUN::ECS::SNatEntry``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosSNatEntryProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::SNatEntry``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosSNatEntry, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrSNatEntryId")
    def attr_s_nat_entry_id(self) -> typing.Any:
        """
        :Attribute: SNatEntryId: The id of created SNAT entry.
        """
        return jsii.get(self, "attrSNatEntryId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="sNatIp")
    def s_nat_ip(self) -> builtins.str:
        """
        :Property: sNatIp: Source IP, must belongs to bandwidth package internet IP
        """
        return jsii.get(self, "sNatIp")

    @s_nat_ip.setter # type: ignore
    def s_nat_ip(self, value: builtins.str) -> None:
        jsii.set(self, "sNatIp", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="sNatTableId")
    def s_nat_table_id(self) -> builtins.str:
        """
        :Property: sNatTableId: Create SNAT entry in specified SNAT table.
        """
        return jsii.get(self, "sNatTableId")

    @s_nat_table_id.setter # type: ignore
    def s_nat_table_id(self, value: builtins.str) -> None:
        jsii.set(self, "sNatTableId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="snatEntryName")
    def snat_entry_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: snatEntryName: he name of the SNAT rule is 2-128 characters long and must start with a letter or Chinese, but cannot begin with HTTP:// or https://.
        """
        return jsii.get(self, "snatEntryName")

    @snat_entry_name.setter # type: ignore
    def snat_entry_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "snatEntryName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="sourceCidr")
    def source_cidr(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourceCidr: Specifies the network segment of the switch. For example, 10.0.0.1/24. This parameter and the SourceVSwtichId parameter are mutually exclusive and cannot appear at the same time.
        """
        return jsii.get(self, "sourceCidr")

    @source_cidr.setter # type: ignore
    def source_cidr(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "sourceCidr", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="sourceVSwitchId")
    def source_v_switch_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourceVSwitchId: Allow which switch can access internet.
        """
        return jsii.get(self, "sourceVSwitchId")

    @source_v_switch_id.setter # type: ignore
    def source_v_switch_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "sourceVSwitchId", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosSNatEntryProps",
    jsii_struct_bases=[],
    name_mapping={
        "s_nat_ip": "sNatIp",
        "s_nat_table_id": "sNatTableId",
        "snat_entry_name": "snatEntryName",
        "source_cidr": "sourceCidr",
        "source_v_switch_id": "sourceVSwitchId",
    },
)
class RosSNatEntryProps:
    def __init__(
        self,
        *,
        s_nat_ip: builtins.str,
        s_nat_table_id: builtins.str,
        snat_entry_name: typing.Optional[builtins.str] = None,
        source_cidr: typing.Optional[builtins.str] = None,
        source_v_switch_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::SNatEntry``.

        :param s_nat_ip: 
        :param s_nat_table_id: 
        :param snat_entry_name: 
        :param source_cidr: 
        :param source_v_switch_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "s_nat_ip": s_nat_ip,
            "s_nat_table_id": s_nat_table_id,
        }
        if snat_entry_name is not None:
            self._values["snat_entry_name"] = snat_entry_name
        if source_cidr is not None:
            self._values["source_cidr"] = source_cidr
        if source_v_switch_id is not None:
            self._values["source_v_switch_id"] = source_v_switch_id

    @builtins.property
    def s_nat_ip(self) -> builtins.str:
        """
        :Property: sNatIp: Source IP, must belongs to bandwidth package internet IP
        """
        result = self._values.get("s_nat_ip")
        assert result is not None, "Required property 's_nat_ip' is missing"
        return result

    @builtins.property
    def s_nat_table_id(self) -> builtins.str:
        """
        :Property: sNatTableId: Create SNAT entry in specified SNAT table.
        """
        result = self._values.get("s_nat_table_id")
        assert result is not None, "Required property 's_nat_table_id' is missing"
        return result

    @builtins.property
    def snat_entry_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: snatEntryName: he name of the SNAT rule is 2-128 characters long and must start with a letter or Chinese, but cannot begin with HTTP:// or https://.
        """
        result = self._values.get("snat_entry_name")
        return result

    @builtins.property
    def source_cidr(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourceCidr: Specifies the network segment of the switch. For example, 10.0.0.1/24. This parameter and the SourceVSwtichId parameter are mutually exclusive and cannot appear at the same time.
        """
        result = self._values.get("source_cidr")
        return result

    @builtins.property
    def source_v_switch_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourceVSwitchId: Allow which switch can access internet.
        """
        result = self._values.get("source_v_switch_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosSNatEntryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosSSHKeyPair(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosSSHKeyPair",
):
    """A ROS template type:  ``ALIYUN::ECS::SSHKeyPair``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosSSHKeyPairProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::SSHKeyPair``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosSSHKeyPair, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrKeyPairFingerPrint")
    def attr_key_pair_finger_print(self) -> typing.Any:
        """
        :Attribute: KeyPairFingerPrint: The fingerprint of the key pair. The public key fingerprint format defined in RFC4716: MD5 message digest algorithm. Refer to http://tools.ietf.org/html/rfc4716.
        """
        return jsii.get(self, "attrKeyPairFingerPrint")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrKeyPairName")
    def attr_key_pair_name(self) -> typing.Any:
        """
        :Attribute: KeyPairName: SSH Key pair name.
        """
        return jsii.get(self, "attrKeyPairName")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateKeyBody")
    def attr_private_key_body(self) -> typing.Any:
        """
        :Attribute: PrivateKeyBody: The private key of the key pair. Content of the RSA private key in the PKCS#8 format of the unencrypted PEM encoding. Refer to: https://www.openssl.org/docs/apps/pkcs8.html.User only can get the private key one time when and only when SSH key pair is created.
        """
        return jsii.get(self, "attrPrivateKeyBody")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="keyPairName")
    def key_pair_name(self) -> builtins.str:
        """
        :Property: keyPairName: SSH key pair name. It must be unique. [2, 128] characters. All character sets are supported. Do not start with a special character, digit, http://, or https://. It can contain digits, ".", "_", or "-".
        """
        return jsii.get(self, "keyPairName")

    @key_pair_name.setter # type: ignore
    def key_pair_name(self, value: builtins.str) -> None:
        jsii.set(self, "keyPairName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="publicKeyBody")
    def public_key_body(self) -> typing.Optional[builtins.str]:
        """
        :Property: publicKeyBody: SSH Public key. If PublicKeyBody is specified, existed public key body will be imported instead of creating new SSH key pair.
        """
        return jsii.get(self, "publicKeyBody")

    @public_key_body.setter # type: ignore
    def public_key_body(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "publicKeyBody", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        return jsii.get(self, "resourceGroupId")

    @resource_group_id.setter # type: ignore
    def resource_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "resourceGroupId", value)


class RosSSHKeyPairAttachment(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosSSHKeyPairAttachment",
):
    """A ROS template type:  ``ALIYUN::ECS::SSHKeyPairAttachment``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosSSHKeyPairAttachmentProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::SSHKeyPairAttachment``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosSSHKeyPairAttachment, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        """A factory method that creates a new instance of this class from an object
containing the properties of this ROS resource."""
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="instanceIds")
    def instance_ids(
        self,
    ) -> typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]:
        """
        :Property: instanceIds: The comma delimited ECS instance id list. Only support Linux.
        """
        return jsii.get(self, "instanceIds")

    @instance_ids.setter # type: ignore
    def instance_ids(
        self,
        value: typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable],
    ) -> None:
        jsii.set(self, "instanceIds", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="keyPairName")
    def key_pair_name(self) -> builtins.str:
        """
        :Property: keyPairName: SSH key pair name.
        """
        return jsii.get(self, "keyPairName")

    @key_pair_name.setter # type: ignore
    def key_pair_name(self, value: builtins.str) -> None:
        jsii.set(self, "keyPairName", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosSSHKeyPairAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={"instance_ids": "instanceIds", "key_pair_name": "keyPairName"},
)
class RosSSHKeyPairAttachmentProps:
    def __init__(
        self,
        *,
        instance_ids: typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable],
        key_pair_name: builtins.str,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::SSHKeyPairAttachment``.

        :param instance_ids: 
        :param key_pair_name: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "instance_ids": instance_ids,
            "key_pair_name": key_pair_name,
        }

    @builtins.property
    def instance_ids(
        self,
    ) -> typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]:
        """
        :Property: instanceIds: The comma delimited ECS instance id list. Only support Linux.
        """
        result = self._values.get("instance_ids")
        assert result is not None, "Required property 'instance_ids' is missing"
        return result

    @builtins.property
    def key_pair_name(self) -> builtins.str:
        """
        :Property: keyPairName: SSH key pair name.
        """
        result = self._values.get("key_pair_name")
        assert result is not None, "Required property 'key_pair_name' is missing"
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosSSHKeyPairAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosSSHKeyPairProps",
    jsii_struct_bases=[],
    name_mapping={
        "key_pair_name": "keyPairName",
        "public_key_body": "publicKeyBody",
        "resource_group_id": "resourceGroupId",
    },
)
class RosSSHKeyPairProps:
    def __init__(
        self,
        *,
        key_pair_name: builtins.str,
        public_key_body: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::SSHKeyPair``.

        :param key_pair_name: 
        :param public_key_body: 
        :param resource_group_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "key_pair_name": key_pair_name,
        }
        if public_key_body is not None:
            self._values["public_key_body"] = public_key_body
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id

    @builtins.property
    def key_pair_name(self) -> builtins.str:
        """
        :Property: keyPairName: SSH key pair name. It must be unique. [2, 128] characters. All character sets are supported. Do not start with a special character, digit, http://, or https://. It can contain digits, ".", "_", or "-".
        """
        result = self._values.get("key_pair_name")
        assert result is not None, "Required property 'key_pair_name' is missing"
        return result

    @builtins.property
    def public_key_body(self) -> typing.Optional[builtins.str]:
        """
        :Property: publicKeyBody: SSH Public key. If PublicKeyBody is specified, existed public key body will be imported instead of creating new SSH key pair.
        """
        result = self._values.get("public_key_body")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosSSHKeyPairProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosSecurityGroup(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosSecurityGroup",
):
    """A ROS template type:  ``ALIYUN::ECS::SecurityGroup``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosSecurityGroupProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::SecurityGroup``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosSecurityGroup, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrSecurityGroupId")
    def attr_security_group_id(self) -> typing.Any:
        """
        :Attribute: SecurityGroupId: generated security group id for security group.
        """
        return jsii.get(self, "attrSecurityGroupId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="tags")
    def tags(self) -> ros_cdk_core.TagManager:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        return jsii.get(self, "tags")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the security group, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        return jsii.get(self, "resourceGroupId")

    @resource_group_id.setter # type: ignore
    def resource_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "resourceGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupEgress")
    def security_group_egress(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosSecurityGroup.SecurityGroupEgressProperty"]]]]:
        """
        :Property: securityGroupEgress: egress rules for the security group.
        """
        return jsii.get(self, "securityGroupEgress")

    @security_group_egress.setter # type: ignore
    def security_group_egress(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosSecurityGroup.SecurityGroupEgressProperty"]]]],
    ) -> None:
        jsii.set(self, "securityGroupEgress", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupIngress")
    def security_group_ingress(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosSecurityGroup.SecurityGroupIngressProperty"]]]]:
        """
        :Property: securityGroupIngress: Ingress rules for the security group.
        """
        return jsii.get(self, "securityGroupIngress")

    @security_group_ingress.setter # type: ignore
    def security_group_ingress(
        self,
        value: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, "RosSecurityGroup.SecurityGroupIngressProperty"]]]],
    ) -> None:
        jsii.set(self, "securityGroupIngress", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupName")
    def security_group_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupName: Display name of the security group, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        return jsii.get(self, "securityGroupName")

    @security_group_name.setter # type: ignore
    def security_group_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "securityGroupName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupType")
    def security_group_type(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        securityGroupType: The type of the security group. Valid values:
        normal: basic security group
        enterprise: advanced security group
        """
        return jsii.get(self, "securityGroupType")

    @security_group_type.setter # type: ignore
    def security_group_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "securityGroupType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcId: Physical ID of the VPC.
        """
        return jsii.get(self, "vpcId")

    @vpc_id.setter # type: ignore
    def vpc_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vpcId", value)

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosSecurityGroup.SecurityGroupEgressProperty",
        jsii_struct_bases=[],
        name_mapping={
            "ip_protocol": "ipProtocol",
            "port_range": "portRange",
            "description": "description",
            "dest_cidr_ip": "destCidrIp",
            "dest_group_id": "destGroupId",
            "dest_group_owner_id": "destGroupOwnerId",
            "ipv6_dest_cidr_ip": "ipv6DestCidrIp",
            "nic_type": "nicType",
            "policy": "policy",
            "priority": "priority",
            "security_group_id": "securityGroupId",
        },
    )
    class SecurityGroupEgressProperty:
        def __init__(
            self,
            *,
            ip_protocol: builtins.str,
            port_range: builtins.str,
            description: typing.Optional[builtins.str] = None,
            dest_cidr_ip: typing.Optional[builtins.str] = None,
            dest_group_id: typing.Optional[builtins.str] = None,
            dest_group_owner_id: typing.Optional[builtins.str] = None,
            ipv6_dest_cidr_ip: typing.Optional[builtins.str] = None,
            nic_type: typing.Optional[builtins.str] = None,
            policy: typing.Optional[builtins.str] = None,
            priority: typing.Optional[jsii.Number] = None,
            security_group_id: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param ip_protocol: 
            :param port_range: 
            :param description: 
            :param dest_cidr_ip: 
            :param dest_group_id: 
            :param dest_group_owner_id: 
            :param ipv6_dest_cidr_ip: 
            :param nic_type: 
            :param policy: 
            :param priority: 
            :param security_group_id: 
            """
            self._values: typing.Dict[str, typing.Any] = {
                "ip_protocol": ip_protocol,
                "port_range": port_range,
            }
            if description is not None:
                self._values["description"] = description
            if dest_cidr_ip is not None:
                self._values["dest_cidr_ip"] = dest_cidr_ip
            if dest_group_id is not None:
                self._values["dest_group_id"] = dest_group_id
            if dest_group_owner_id is not None:
                self._values["dest_group_owner_id"] = dest_group_owner_id
            if ipv6_dest_cidr_ip is not None:
                self._values["ipv6_dest_cidr_ip"] = ipv6_dest_cidr_ip
            if nic_type is not None:
                self._values["nic_type"] = nic_type
            if policy is not None:
                self._values["policy"] = policy
            if priority is not None:
                self._values["priority"] = priority
            if security_group_id is not None:
                self._values["security_group_id"] = security_group_id

        @builtins.property
        def ip_protocol(self) -> builtins.str:
            """
            :Property: ipProtocol: Ip protocol for in rule.
            """
            result = self._values.get("ip_protocol")
            assert result is not None, "Required property 'ip_protocol' is missing"
            return result

        @builtins.property
        def port_range(self) -> builtins.str:
            """
            :Property: portRange: Ip protocol relative port range. For tcp and udp, the port rang is [1,65535], using format '1/200'For icmp|gre|all protocel, the port range should be '-1/-1'
            """
            result = self._values.get("port_range")
            assert result is not None, "Required property 'port_range' is missing"
            return result

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            """
            :Property: description: Description of the security group rule, [1, 512] characters. The default is empty.
            """
            result = self._values.get("description")
            return result

        @builtins.property
        def dest_cidr_ip(self) -> typing.Optional[builtins.str]:
            """
            :Property: destCidrIp: Dest CIDR Ip Address range. Only IPV4 supported.
            """
            result = self._values.get("dest_cidr_ip")
            return result

        @builtins.property
        def dest_group_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: destGroupId: Dest Group Id
            """
            result = self._values.get("dest_group_id")
            return result

        @builtins.property
        def dest_group_owner_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: destGroupOwnerId: Dest Group Owner Account ID
            """
            result = self._values.get("dest_group_owner_id")
            return result

        @builtins.property
        def ipv6_dest_cidr_ip(self) -> typing.Optional[builtins.str]:
            """
            :Property:

            ipv6DestCidrIp: Destination IPv6 CIDR address segment. Supports IP address ranges in CIDR format and IPv6 format.
            Note Only VPC type IP addresses are supported.
            """
            result = self._values.get("ipv6_dest_cidr_ip")
            return result

        @builtins.property
        def nic_type(self) -> typing.Optional[builtins.str]:
            """
            :Property: nicType: Network type, could be 'internet' or 'intranet'. Default value is internet.
            """
            result = self._values.get("nic_type")
            return result

        @builtins.property
        def policy(self) -> typing.Optional[builtins.str]:
            """
            :Property: policy: Authorization policies, parameter values can be: accept (accepted access), drop (denied access). Default value is accept.
            """
            result = self._values.get("policy")
            return result

        @builtins.property
        def priority(self) -> typing.Optional[jsii.Number]:
            """
            :Property: priority: Authorization policies priority range[1, 100]
            """
            result = self._values.get("priority")
            return result

        @builtins.property
        def security_group_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: securityGroupId: Id of the security group.
            """
            result = self._values.get("security_group_id")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SecurityGroupEgressProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@alicloud/ros-cdk-ecs.RosSecurityGroup.SecurityGroupIngressProperty",
        jsii_struct_bases=[],
        name_mapping={
            "ip_protocol": "ipProtocol",
            "port_range": "portRange",
            "description": "description",
            "ipv6_source_cidr_ip": "ipv6SourceCidrIp",
            "nic_type": "nicType",
            "policy": "policy",
            "priority": "priority",
            "security_group_id": "securityGroupId",
            "source_cidr_ip": "sourceCidrIp",
            "source_group_id": "sourceGroupId",
            "source_group_owner_id": "sourceGroupOwnerId",
            "source_port_range": "sourcePortRange",
        },
    )
    class SecurityGroupIngressProperty:
        def __init__(
            self,
            *,
            ip_protocol: builtins.str,
            port_range: builtins.str,
            description: typing.Optional[builtins.str] = None,
            ipv6_source_cidr_ip: typing.Optional[builtins.str] = None,
            nic_type: typing.Optional[builtins.str] = None,
            policy: typing.Optional[builtins.str] = None,
            priority: typing.Optional[jsii.Number] = None,
            security_group_id: typing.Optional[builtins.str] = None,
            source_cidr_ip: typing.Optional[builtins.str] = None,
            source_group_id: typing.Optional[builtins.str] = None,
            source_group_owner_id: typing.Optional[builtins.str] = None,
            source_port_range: typing.Optional[builtins.str] = None,
        ) -> None:
            """
            :param ip_protocol: 
            :param port_range: 
            :param description: 
            :param ipv6_source_cidr_ip: 
            :param nic_type: 
            :param policy: 
            :param priority: 
            :param security_group_id: 
            :param source_cidr_ip: 
            :param source_group_id: 
            :param source_group_owner_id: 
            :param source_port_range: 
            """
            self._values: typing.Dict[str, typing.Any] = {
                "ip_protocol": ip_protocol,
                "port_range": port_range,
            }
            if description is not None:
                self._values["description"] = description
            if ipv6_source_cidr_ip is not None:
                self._values["ipv6_source_cidr_ip"] = ipv6_source_cidr_ip
            if nic_type is not None:
                self._values["nic_type"] = nic_type
            if policy is not None:
                self._values["policy"] = policy
            if priority is not None:
                self._values["priority"] = priority
            if security_group_id is not None:
                self._values["security_group_id"] = security_group_id
            if source_cidr_ip is not None:
                self._values["source_cidr_ip"] = source_cidr_ip
            if source_group_id is not None:
                self._values["source_group_id"] = source_group_id
            if source_group_owner_id is not None:
                self._values["source_group_owner_id"] = source_group_owner_id
            if source_port_range is not None:
                self._values["source_port_range"] = source_port_range

        @builtins.property
        def ip_protocol(self) -> builtins.str:
            """
            :Property: ipProtocol: Ip protocol for in rule.
            """
            result = self._values.get("ip_protocol")
            assert result is not None, "Required property 'ip_protocol' is missing"
            return result

        @builtins.property
        def port_range(self) -> builtins.str:
            """
            :Property: portRange: Ip protocol relative port range. For tcp and udp, the port rang is [1,65535], using format '1/200'For icmp|gre|all protocel, the port range should be '-1/-1'
            """
            result = self._values.get("port_range")
            assert result is not None, "Required property 'port_range' is missing"
            return result

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            """
            :Property: description: Description of the security group rule, [1, 512] characters. The default is empty.
            """
            result = self._values.get("description")
            return result

        @builtins.property
        def ipv6_source_cidr_ip(self) -> typing.Optional[builtins.str]:
            """
            :Property:

            ipv6SourceCidrIp: Source IPv6 CIDR address segment. Supports IP address ranges in CIDR format and IPv6 format.
            Note Only VPC type IP addresses are supported.
            """
            result = self._values.get("ipv6_source_cidr_ip")
            return result

        @builtins.property
        def nic_type(self) -> typing.Optional[builtins.str]:
            """
            :Property: nicType: Network type, could be 'internet' or 'intranet'. Default value is internet.
            """
            result = self._values.get("nic_type")
            return result

        @builtins.property
        def policy(self) -> typing.Optional[builtins.str]:
            """
            :Property: policy: Authorization policies, parameter values can be: accept (accepted access), drop (denied access). Default value is accept.
            """
            result = self._values.get("policy")
            return result

        @builtins.property
        def priority(self) -> typing.Optional[jsii.Number]:
            """
            :Property: priority: Authorization policies priority range[1, 100]
            """
            result = self._values.get("priority")
            return result

        @builtins.property
        def security_group_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: securityGroupId: Id of the security group.
            """
            result = self._values.get("security_group_id")
            return result

        @builtins.property
        def source_cidr_ip(self) -> typing.Optional[builtins.str]:
            """
            :Property: sourceCidrIp: Source CIDR Ip Address range. Only IPV4 supported.
            """
            result = self._values.get("source_cidr_ip")
            return result

        @builtins.property
        def source_group_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: sourceGroupId: Source Group Id
            """
            result = self._values.get("source_group_id")
            return result

        @builtins.property
        def source_group_owner_id(self) -> typing.Optional[builtins.str]:
            """
            :Property: sourceGroupOwnerId: Source Group Owner Account ID
            """
            result = self._values.get("source_group_owner_id")
            return result

        @builtins.property
        def source_port_range(self) -> typing.Optional[builtins.str]:
            """
            :Property: sourcePortRange: The range of the ports enabled by the source security group for the transport layer protocol. Valid values: TCP/UDP: Value range: 1 to 65535. The start port and the end port are separated by a slash (/). Correct example: 1/200. Incorrect example: 200/1.ICMP: -1/-1.GRE: -1/-1.ALL: -1/-1.
            """
            result = self._values.get("source_port_range")
            return result

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SecurityGroupIngressProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


class RosSecurityGroupClone(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosSecurityGroupClone",
):
    """A ROS template type:  ``ALIYUN::ECS::SecurityGroupClone``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosSecurityGroupCloneProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::SecurityGroupClone``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosSecurityGroupClone, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrSecurityGroupId")
    def attr_security_group_id(self) -> typing.Any:
        """
        :Attribute: SecurityGroupId: Generated security group id of new security group.
        """
        return jsii.get(self, "attrSecurityGroupId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="sourceSecurityGroupId")
    def source_security_group_id(self) -> builtins.str:
        """
        :Property: sourceSecurityGroupId: Source security group ID is used to copy properties to clone new security group. If the NetworkType and VpcId is not specified, the same security group will be cloned. If NetworkType or VpcId is specified, only proper security group rules will be cloned.
        """
        return jsii.get(self, "sourceSecurityGroupId")

    @source_security_group_id.setter # type: ignore
    def source_security_group_id(self, value: builtins.str) -> None:
        jsii.set(self, "sourceSecurityGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the security group, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="destinationRegionId")
    def destination_region_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: destinationRegionId: Clone security group to the specified region. Default to current region.
        """
        return jsii.get(self, "destinationRegionId")

    @destination_region_id.setter # type: ignore
    def destination_region_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "destinationRegionId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="networkType")
    def network_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: networkType: Clone new security group as classic network type. If the VpcId is specified, the value will be ignored.
        """
        return jsii.get(self, "networkType")

    @network_type.setter # type: ignore
    def network_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "networkType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        return jsii.get(self, "resourceGroupId")

    @resource_group_id.setter # type: ignore
    def resource_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "resourceGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupName")
    def security_group_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupName: Display name of the security group, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        return jsii.get(self, "securityGroupName")

    @security_group_name.setter # type: ignore
    def security_group_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "securityGroupName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupType")
    def security_group_type(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        securityGroupType: The type of the security group. Valid values:
        normal: basic security group
        enterprise: advanced security group
        """
        return jsii.get(self, "securityGroupType")

    @security_group_type.setter # type: ignore
    def security_group_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "securityGroupType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcId: Physical ID of the VPC.
        """
        return jsii.get(self, "vpcId")

    @vpc_id.setter # type: ignore
    def vpc_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vpcId", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosSecurityGroupCloneProps",
    jsii_struct_bases=[],
    name_mapping={
        "source_security_group_id": "sourceSecurityGroupId",
        "description": "description",
        "destination_region_id": "destinationRegionId",
        "network_type": "networkType",
        "resource_group_id": "resourceGroupId",
        "security_group_name": "securityGroupName",
        "security_group_type": "securityGroupType",
        "vpc_id": "vpcId",
    },
)
class RosSecurityGroupCloneProps:
    def __init__(
        self,
        *,
        source_security_group_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        destination_region_id: typing.Optional[builtins.str] = None,
        network_type: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_group_name: typing.Optional[builtins.str] = None,
        security_group_type: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::SecurityGroupClone``.

        :param source_security_group_id: 
        :param description: 
        :param destination_region_id: 
        :param network_type: 
        :param resource_group_id: 
        :param security_group_name: 
        :param security_group_type: 
        :param vpc_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "source_security_group_id": source_security_group_id,
        }
        if description is not None:
            self._values["description"] = description
        if destination_region_id is not None:
            self._values["destination_region_id"] = destination_region_id
        if network_type is not None:
            self._values["network_type"] = network_type
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_group_name is not None:
            self._values["security_group_name"] = security_group_name
        if security_group_type is not None:
            self._values["security_group_type"] = security_group_type
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def source_security_group_id(self) -> builtins.str:
        """
        :Property: sourceSecurityGroupId: Source security group ID is used to copy properties to clone new security group. If the NetworkType and VpcId is not specified, the same security group will be cloned. If NetworkType or VpcId is specified, only proper security group rules will be cloned.
        """
        result = self._values.get("source_security_group_id")
        assert result is not None, "Required property 'source_security_group_id' is missing"
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the security group, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def destination_region_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: destinationRegionId: Clone security group to the specified region. Default to current region.
        """
        result = self._values.get("destination_region_id")
        return result

    @builtins.property
    def network_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: networkType: Clone new security group as classic network type. If the VpcId is specified, the value will be ignored.
        """
        result = self._values.get("network_type")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def security_group_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupName: Display name of the security group, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("security_group_name")
        return result

    @builtins.property
    def security_group_type(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        securityGroupType: The type of the security group. Valid values:
        normal: basic security group
        enterprise: advanced security group
        """
        result = self._values.get("security_group_type")
        return result

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcId: Physical ID of the VPC.
        """
        result = self._values.get("vpc_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosSecurityGroupCloneProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosSecurityGroupEgress(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosSecurityGroupEgress",
):
    """A ROS template type:  ``ALIYUN::ECS::SecurityGroupEgress``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosSecurityGroupEgressProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::SecurityGroupEgress``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosSecurityGroupEgress, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        """A factory method that creates a new instance of this class from an object
containing the properties of this ROS resource."""
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ipProtocol")
    def ip_protocol(self) -> builtins.str:
        """
        :Property: ipProtocol: Ip protocol for in rule.
        """
        return jsii.get(self, "ipProtocol")

    @ip_protocol.setter # type: ignore
    def ip_protocol(self, value: builtins.str) -> None:
        jsii.set(self, "ipProtocol", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="portRange")
    def port_range(self) -> builtins.str:
        """
        :Property: portRange: Ip protocol relative port range. For tcp and udp, the port rang is [1,65535], using format '1/200'For icmp|gre|all protocel, the port range should be '-1/-1'
        """
        return jsii.get(self, "portRange")

    @port_range.setter # type: ignore
    def port_range(self, value: builtins.str) -> None:
        jsii.set(self, "portRange", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the security group rule, [1, 512] characters. The default is empty.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="destCidrIp")
    def dest_cidr_ip(self) -> typing.Optional[builtins.str]:
        """
        :Property: destCidrIp: Dest CIDR Ip Address range. Only IPV4 supported.
        """
        return jsii.get(self, "destCidrIp")

    @dest_cidr_ip.setter # type: ignore
    def dest_cidr_ip(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "destCidrIp", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="destGroupId")
    def dest_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: destGroupId: Dest Group Id
        """
        return jsii.get(self, "destGroupId")

    @dest_group_id.setter # type: ignore
    def dest_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "destGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="destGroupOwnerId")
    def dest_group_owner_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: destGroupOwnerId: Dest Group Owner Account ID
        """
        return jsii.get(self, "destGroupOwnerId")

    @dest_group_owner_id.setter # type: ignore
    def dest_group_owner_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "destGroupOwnerId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ipv6DestCidrIp")
    def ipv6_dest_cidr_ip(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        ipv6DestCidrIp: Destination IPv6 CIDR address segment. Supports IP address ranges in CIDR format and IPv6 format.
        Note Only VPC type IP addresses are supported.
        """
        return jsii.get(self, "ipv6DestCidrIp")

    @ipv6_dest_cidr_ip.setter # type: ignore
    def ipv6_dest_cidr_ip(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ipv6DestCidrIp", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="nicType")
    def nic_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: nicType: Network type, could be 'internet' or 'intranet'. Default value is internet.
        """
        return jsii.get(self, "nicType")

    @nic_type.setter # type: ignore
    def nic_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "nicType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="policy")
    def policy(self) -> typing.Optional[builtins.str]:
        """
        :Property: policy: Authorization policies, parameter values can be: accept (accepted access), drop (denied access). Default value is accept.
        """
        return jsii.get(self, "policy")

    @policy.setter # type: ignore
    def policy(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "policy", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="priority")
    def priority(self) -> typing.Optional[jsii.Number]:
        """
        :Property: priority: Authorization policies priority range[1, 100]
        """
        return jsii.get(self, "priority")

    @priority.setter # type: ignore
    def priority(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "priority", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupId")
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Id of the security group.
        """
        return jsii.get(self, "securityGroupId")

    @security_group_id.setter # type: ignore
    def security_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "securityGroupId", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosSecurityGroupEgressProps",
    jsii_struct_bases=[],
    name_mapping={
        "ip_protocol": "ipProtocol",
        "port_range": "portRange",
        "description": "description",
        "dest_cidr_ip": "destCidrIp",
        "dest_group_id": "destGroupId",
        "dest_group_owner_id": "destGroupOwnerId",
        "ipv6_dest_cidr_ip": "ipv6DestCidrIp",
        "nic_type": "nicType",
        "policy": "policy",
        "priority": "priority",
        "security_group_id": "securityGroupId",
    },
)
class RosSecurityGroupEgressProps:
    def __init__(
        self,
        *,
        ip_protocol: builtins.str,
        port_range: builtins.str,
        description: typing.Optional[builtins.str] = None,
        dest_cidr_ip: typing.Optional[builtins.str] = None,
        dest_group_id: typing.Optional[builtins.str] = None,
        dest_group_owner_id: typing.Optional[builtins.str] = None,
        ipv6_dest_cidr_ip: typing.Optional[builtins.str] = None,
        nic_type: typing.Optional[builtins.str] = None,
        policy: typing.Optional[builtins.str] = None,
        priority: typing.Optional[jsii.Number] = None,
        security_group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::SecurityGroupEgress``.

        :param ip_protocol: 
        :param port_range: 
        :param description: 
        :param dest_cidr_ip: 
        :param dest_group_id: 
        :param dest_group_owner_id: 
        :param ipv6_dest_cidr_ip: 
        :param nic_type: 
        :param policy: 
        :param priority: 
        :param security_group_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "ip_protocol": ip_protocol,
            "port_range": port_range,
        }
        if description is not None:
            self._values["description"] = description
        if dest_cidr_ip is not None:
            self._values["dest_cidr_ip"] = dest_cidr_ip
        if dest_group_id is not None:
            self._values["dest_group_id"] = dest_group_id
        if dest_group_owner_id is not None:
            self._values["dest_group_owner_id"] = dest_group_owner_id
        if ipv6_dest_cidr_ip is not None:
            self._values["ipv6_dest_cidr_ip"] = ipv6_dest_cidr_ip
        if nic_type is not None:
            self._values["nic_type"] = nic_type
        if policy is not None:
            self._values["policy"] = policy
        if priority is not None:
            self._values["priority"] = priority
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id

    @builtins.property
    def ip_protocol(self) -> builtins.str:
        """
        :Property: ipProtocol: Ip protocol for in rule.
        """
        result = self._values.get("ip_protocol")
        assert result is not None, "Required property 'ip_protocol' is missing"
        return result

    @builtins.property
    def port_range(self) -> builtins.str:
        """
        :Property: portRange: Ip protocol relative port range. For tcp and udp, the port rang is [1,65535], using format '1/200'For icmp|gre|all protocel, the port range should be '-1/-1'
        """
        result = self._values.get("port_range")
        assert result is not None, "Required property 'port_range' is missing"
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the security group rule, [1, 512] characters. The default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def dest_cidr_ip(self) -> typing.Optional[builtins.str]:
        """
        :Property: destCidrIp: Dest CIDR Ip Address range. Only IPV4 supported.
        """
        result = self._values.get("dest_cidr_ip")
        return result

    @builtins.property
    def dest_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: destGroupId: Dest Group Id
        """
        result = self._values.get("dest_group_id")
        return result

    @builtins.property
    def dest_group_owner_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: destGroupOwnerId: Dest Group Owner Account ID
        """
        result = self._values.get("dest_group_owner_id")
        return result

    @builtins.property
    def ipv6_dest_cidr_ip(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        ipv6DestCidrIp: Destination IPv6 CIDR address segment. Supports IP address ranges in CIDR format and IPv6 format.
        Note Only VPC type IP addresses are supported.
        """
        result = self._values.get("ipv6_dest_cidr_ip")
        return result

    @builtins.property
    def nic_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: nicType: Network type, could be 'internet' or 'intranet'. Default value is internet.
        """
        result = self._values.get("nic_type")
        return result

    @builtins.property
    def policy(self) -> typing.Optional[builtins.str]:
        """
        :Property: policy: Authorization policies, parameter values can be: accept (accepted access), drop (denied access). Default value is accept.
        """
        result = self._values.get("policy")
        return result

    @builtins.property
    def priority(self) -> typing.Optional[jsii.Number]:
        """
        :Property: priority: Authorization policies priority range[1, 100]
        """
        result = self._values.get("priority")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Id of the security group.
        """
        result = self._values.get("security_group_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosSecurityGroupEgressProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosSecurityGroupIngress(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosSecurityGroupIngress",
):
    """A ROS template type:  ``ALIYUN::ECS::SecurityGroupIngress``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosSecurityGroupIngressProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::SecurityGroupIngress``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosSecurityGroupIngress, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        """A factory method that creates a new instance of this class from an object
containing the properties of this ROS resource."""
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ipProtocol")
    def ip_protocol(self) -> builtins.str:
        """
        :Property: ipProtocol: Ip protocol for in rule.
        """
        return jsii.get(self, "ipProtocol")

    @ip_protocol.setter # type: ignore
    def ip_protocol(self, value: builtins.str) -> None:
        jsii.set(self, "ipProtocol", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="portRange")
    def port_range(self) -> builtins.str:
        """
        :Property: portRange: Ip protocol relative port range. For tcp and udp, the port rang is [1,65535], using format '1/200'For icmp|gre|all protocel, the port range should be '-1/-1'
        """
        return jsii.get(self, "portRange")

    @port_range.setter # type: ignore
    def port_range(self, value: builtins.str) -> None:
        jsii.set(self, "portRange", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the security group rule, [1, 512] characters. The default is empty.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ipv6SourceCidrIp")
    def ipv6_source_cidr_ip(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        ipv6SourceCidrIp: Source IPv6 CIDR address segment. Supports IP address ranges in CIDR format and IPv6 format.
        Note Only VPC type IP addresses are supported.
        """
        return jsii.get(self, "ipv6SourceCidrIp")

    @ipv6_source_cidr_ip.setter # type: ignore
    def ipv6_source_cidr_ip(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ipv6SourceCidrIp", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="nicType")
    def nic_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: nicType: Network type, could be 'internet' or 'intranet'. Default value is internet.
        """
        return jsii.get(self, "nicType")

    @nic_type.setter # type: ignore
    def nic_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "nicType", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="policy")
    def policy(self) -> typing.Optional[builtins.str]:
        """
        :Property: policy: Authorization policies, parameter values can be: accept (accepted access), drop (denied access). Default value is accept.
        """
        return jsii.get(self, "policy")

    @policy.setter # type: ignore
    def policy(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "policy", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="priority")
    def priority(self) -> typing.Optional[jsii.Number]:
        """
        :Property: priority: Authorization policies priority range[1, 100]
        """
        return jsii.get(self, "priority")

    @priority.setter # type: ignore
    def priority(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "priority", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="securityGroupId")
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Id of the security group.
        """
        return jsii.get(self, "securityGroupId")

    @security_group_id.setter # type: ignore
    def security_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "securityGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="sourceCidrIp")
    def source_cidr_ip(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourceCidrIp: Source CIDR Ip Address range. Only IPV4 supported.
        """
        return jsii.get(self, "sourceCidrIp")

    @source_cidr_ip.setter # type: ignore
    def source_cidr_ip(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "sourceCidrIp", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="sourceGroupId")
    def source_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourceGroupId: Source Group Id
        """
        return jsii.get(self, "sourceGroupId")

    @source_group_id.setter # type: ignore
    def source_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "sourceGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="sourceGroupOwnerId")
    def source_group_owner_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourceGroupOwnerId: Source Group Owner Account ID
        """
        return jsii.get(self, "sourceGroupOwnerId")

    @source_group_owner_id.setter # type: ignore
    def source_group_owner_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "sourceGroupOwnerId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="sourcePortRange")
    def source_port_range(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourcePortRange: The range of the ports enabled by the source security group for the transport layer protocol. Valid values: TCP/UDP: Value range: 1 to 65535. The start port and the end port are separated by a slash (/). Correct example: 1/200. Incorrect example: 200/1.ICMP: -1/-1.GRE: -1/-1.ALL: -1/-1.
        """
        return jsii.get(self, "sourcePortRange")

    @source_port_range.setter # type: ignore
    def source_port_range(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "sourcePortRange", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosSecurityGroupIngressProps",
    jsii_struct_bases=[],
    name_mapping={
        "ip_protocol": "ipProtocol",
        "port_range": "portRange",
        "description": "description",
        "ipv6_source_cidr_ip": "ipv6SourceCidrIp",
        "nic_type": "nicType",
        "policy": "policy",
        "priority": "priority",
        "security_group_id": "securityGroupId",
        "source_cidr_ip": "sourceCidrIp",
        "source_group_id": "sourceGroupId",
        "source_group_owner_id": "sourceGroupOwnerId",
        "source_port_range": "sourcePortRange",
    },
)
class RosSecurityGroupIngressProps:
    def __init__(
        self,
        *,
        ip_protocol: builtins.str,
        port_range: builtins.str,
        description: typing.Optional[builtins.str] = None,
        ipv6_source_cidr_ip: typing.Optional[builtins.str] = None,
        nic_type: typing.Optional[builtins.str] = None,
        policy: typing.Optional[builtins.str] = None,
        priority: typing.Optional[jsii.Number] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        source_cidr_ip: typing.Optional[builtins.str] = None,
        source_group_id: typing.Optional[builtins.str] = None,
        source_group_owner_id: typing.Optional[builtins.str] = None,
        source_port_range: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::SecurityGroupIngress``.

        :param ip_protocol: 
        :param port_range: 
        :param description: 
        :param ipv6_source_cidr_ip: 
        :param nic_type: 
        :param policy: 
        :param priority: 
        :param security_group_id: 
        :param source_cidr_ip: 
        :param source_group_id: 
        :param source_group_owner_id: 
        :param source_port_range: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "ip_protocol": ip_protocol,
            "port_range": port_range,
        }
        if description is not None:
            self._values["description"] = description
        if ipv6_source_cidr_ip is not None:
            self._values["ipv6_source_cidr_ip"] = ipv6_source_cidr_ip
        if nic_type is not None:
            self._values["nic_type"] = nic_type
        if policy is not None:
            self._values["policy"] = policy
        if priority is not None:
            self._values["priority"] = priority
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if source_cidr_ip is not None:
            self._values["source_cidr_ip"] = source_cidr_ip
        if source_group_id is not None:
            self._values["source_group_id"] = source_group_id
        if source_group_owner_id is not None:
            self._values["source_group_owner_id"] = source_group_owner_id
        if source_port_range is not None:
            self._values["source_port_range"] = source_port_range

    @builtins.property
    def ip_protocol(self) -> builtins.str:
        """
        :Property: ipProtocol: Ip protocol for in rule.
        """
        result = self._values.get("ip_protocol")
        assert result is not None, "Required property 'ip_protocol' is missing"
        return result

    @builtins.property
    def port_range(self) -> builtins.str:
        """
        :Property: portRange: Ip protocol relative port range. For tcp and udp, the port rang is [1,65535], using format '1/200'For icmp|gre|all protocel, the port range should be '-1/-1'
        """
        result = self._values.get("port_range")
        assert result is not None, "Required property 'port_range' is missing"
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the security group rule, [1, 512] characters. The default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def ipv6_source_cidr_ip(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        ipv6SourceCidrIp: Source IPv6 CIDR address segment. Supports IP address ranges in CIDR format and IPv6 format.
        Note Only VPC type IP addresses are supported.
        """
        result = self._values.get("ipv6_source_cidr_ip")
        return result

    @builtins.property
    def nic_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: nicType: Network type, could be 'internet' or 'intranet'. Default value is internet.
        """
        result = self._values.get("nic_type")
        return result

    @builtins.property
    def policy(self) -> typing.Optional[builtins.str]:
        """
        :Property: policy: Authorization policies, parameter values can be: accept (accepted access), drop (denied access). Default value is accept.
        """
        result = self._values.get("policy")
        return result

    @builtins.property
    def priority(self) -> typing.Optional[jsii.Number]:
        """
        :Property: priority: Authorization policies priority range[1, 100]
        """
        result = self._values.get("priority")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Id of the security group.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def source_cidr_ip(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourceCidrIp: Source CIDR Ip Address range. Only IPV4 supported.
        """
        result = self._values.get("source_cidr_ip")
        return result

    @builtins.property
    def source_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourceGroupId: Source Group Id
        """
        result = self._values.get("source_group_id")
        return result

    @builtins.property
    def source_group_owner_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourceGroupOwnerId: Source Group Owner Account ID
        """
        result = self._values.get("source_group_owner_id")
        return result

    @builtins.property
    def source_port_range(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourcePortRange: The range of the ports enabled by the source security group for the transport layer protocol. Valid values: TCP/UDP: Value range: 1 to 65535. The start port and the end port are separated by a slash (/). Correct example: 1/200. Incorrect example: 200/1.ICMP: -1/-1.GRE: -1/-1.ALL: -1/-1.
        """
        result = self._values.get("source_port_range")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosSecurityGroupIngressProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosSecurityGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "resource_group_id": "resourceGroupId",
        "security_group_egress": "securityGroupEgress",
        "security_group_ingress": "securityGroupIngress",
        "security_group_name": "securityGroupName",
        "security_group_type": "securityGroupType",
        "tags": "tags",
        "vpc_id": "vpcId",
    },
)
class RosSecurityGroupProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_group_egress: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosSecurityGroup.SecurityGroupEgressProperty]]]] = None,
        security_group_ingress: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosSecurityGroup.SecurityGroupIngressProperty]]]] = None,
        security_group_name: typing.Optional[builtins.str] = None,
        security_group_type: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.List[ros_cdk_core.RosTag]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::SecurityGroup``.

        :param description: 
        :param resource_group_id: 
        :param security_group_egress: 
        :param security_group_ingress: 
        :param security_group_name: 
        :param security_group_type: 
        :param tags: 
        :param vpc_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_group_egress is not None:
            self._values["security_group_egress"] = security_group_egress
        if security_group_ingress is not None:
            self._values["security_group_ingress"] = security_group_ingress
        if security_group_name is not None:
            self._values["security_group_name"] = security_group_name
        if security_group_type is not None:
            self._values["security_group_type"] = security_group_type
        if tags is not None:
            self._values["tags"] = tags
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the security group, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def security_group_egress(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosSecurityGroup.SecurityGroupEgressProperty]]]]:
        """
        :Property: securityGroupEgress: egress rules for the security group.
        """
        result = self._values.get("security_group_egress")
        return result

    @builtins.property
    def security_group_ingress(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosSecurityGroup.SecurityGroupIngressProperty]]]]:
        """
        :Property: securityGroupIngress: Ingress rules for the security group.
        """
        result = self._values.get("security_group_ingress")
        return result

    @builtins.property
    def security_group_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupName: Display name of the security group, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("security_group_name")
        return result

    @builtins.property
    def security_group_type(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        securityGroupType: The type of the security group. Valid values:
        normal: basic security group
        enterprise: advanced security group
        """
        result = self._values.get("security_group_type")
        return result

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[ros_cdk_core.RosTag]]:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcId: Physical ID of the VPC.
        """
        result = self._values.get("vpc_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosSecurityGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosSnapshot(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosSnapshot",
):
    """A ROS template type:  ``ALIYUN::ECS::Snapshot``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosSnapshotProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::Snapshot``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosSnapshot, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrSnapshotId")
    def attr_snapshot_id(self) -> typing.Any:
        """
        :Attribute: SnapshotId: The snapshot ID.
        """
        return jsii.get(self, "attrSnapshotId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="diskId")
    def disk_id(self) -> builtins.str:
        """
        :Property: diskId: Indicates the ID of the specified disk.
        """
        return jsii.get(self, "diskId")

    @disk_id.setter # type: ignore
    def disk_id(self, value: builtins.str) -> None:
        jsii.set(self, "diskId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: The description of a snapshot can be 2 to 256 characters in length and cannot begin with http:// or https://. The description will appear on the console. By default, the value is zero.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="snapshotName")
    def snapshot_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: snapshotName: The name of the snapshot, [2, 128] English or Chinese characters. It must begin with an uppercase/lowercase letter or a Chinese character, and may contain numbers, '_' or '-'. It cannot begin with http:// or https://.
        """
        return jsii.get(self, "snapshotName")

    @snapshot_name.setter # type: ignore
    def snapshot_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "snapshotName", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="timeout")
    def timeout(self) -> typing.Optional[jsii.Number]:
        """
        :Property: timeout: The number of minutes to wait for create snapshot.
        """
        return jsii.get(self, "timeout")

    @timeout.setter # type: ignore
    def timeout(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "timeout", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosSnapshotProps",
    jsii_struct_bases=[],
    name_mapping={
        "disk_id": "diskId",
        "description": "description",
        "snapshot_name": "snapshotName",
        "timeout": "timeout",
    },
)
class RosSnapshotProps:
    def __init__(
        self,
        *,
        disk_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        snapshot_name: typing.Optional[builtins.str] = None,
        timeout: typing.Optional[jsii.Number] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::Snapshot``.

        :param disk_id: 
        :param description: 
        :param snapshot_name: 
        :param timeout: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "disk_id": disk_id,
        }
        if description is not None:
            self._values["description"] = description
        if snapshot_name is not None:
            self._values["snapshot_name"] = snapshot_name
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def disk_id(self) -> builtins.str:
        """
        :Property: diskId: Indicates the ID of the specified disk.
        """
        result = self._values.get("disk_id")
        assert result is not None, "Required property 'disk_id' is missing"
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: The description of a snapshot can be 2 to 256 characters in length and cannot begin with http:// or https://. The description will appear on the console. By default, the value is zero.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def snapshot_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: snapshotName: The name of the snapshot, [2, 128] English or Chinese characters. It must begin with an uppercase/lowercase letter or a Chinese character, and may contain numbers, '_' or '-'. It cannot begin with http:// or https://.
        """
        result = self._values.get("snapshot_name")
        return result

    @builtins.property
    def timeout(self) -> typing.Optional[jsii.Number]:
        """
        :Property: timeout: The number of minutes to wait for create snapshot.
        """
        result = self._values.get("timeout")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosSnapshotProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosVPC(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosVPC",
):
    """A ROS template type:  ``ALIYUN::ECS::VPC``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosVPCProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::VPC``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosVPC, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrRouteTableId")
    def attr_route_table_id(self) -> typing.Any:
        """
        :Attribute: RouteTableId: The router table id of created VPC.
        """
        return jsii.get(self, "attrRouteTableId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrVpcId")
    def attr_vpc_id(self) -> typing.Any:
        """
        :Attribute: VpcId: Id of created VPC.
        """
        return jsii.get(self, "attrVpcId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrVRouterId")
    def attr_v_router_id(self) -> typing.Any:
        """
        :Attribute: VRouterId: Router id of created VPC.
        """
        return jsii.get(self, "attrVRouterId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="tags")
    def tags(self) -> ros_cdk_core.TagManager:
        """
        :Property: tags: Tags to attach to vpc. Max support 20 tags to add during create vpc. Each tag with two properties Key and Value, and Key is required.
        """
        return jsii.get(self, "tags")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="cidrBlock")
    def cidr_block(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        cidrBlock: The IP address range of the VPC in the CIDR block form. You can use the following IP address ranges and their subnets:
        10.0.0.0/8
        172.16.0.0/12 (Default)
        192.168.0.0/16
        """
        return jsii.get(self, "cidrBlock")

    @cidr_block.setter # type: ignore
    def cidr_block(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "cidrBlock", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the vpc, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableIpv6")
    def enable_ipv6(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: enableIpv6: Whether to enable an IPv6 network cidr, the value is:False (default): not turned on.True: On.
        """
        return jsii.get(self, "enableIpv6")

    @enable_ipv6.setter # type: ignore
    def enable_ipv6(
        self,
        value: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]],
    ) -> None:
        jsii.set(self, "enableIpv6", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        """
        :Property: ipv6CidrBlock: IPv6 network cidr of the VPC.
        """
        return jsii.get(self, "ipv6CidrBlock")

    @ipv6_cidr_block.setter # type: ignore
    def ipv6_cidr_block(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ipv6CidrBlock", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="resourceGroupId")
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        return jsii.get(self, "resourceGroupId")

    @resource_group_id.setter # type: ignore
    def resource_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "resourceGroupId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="vpcName")
    def vpc_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcName: Display name of the vpc instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        return jsii.get(self, "vpcName")

    @vpc_name.setter # type: ignore
    def vpc_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vpcName", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosVPCProps",
    jsii_struct_bases=[],
    name_mapping={
        "cidr_block": "cidrBlock",
        "description": "description",
        "enable_ipv6": "enableIpv6",
        "ipv6_cidr_block": "ipv6CidrBlock",
        "resource_group_id": "resourceGroupId",
        "tags": "tags",
        "vpc_name": "vpcName",
    },
)
class RosVPCProps:
    def __init__(
        self,
        *,
        cidr_block: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        enable_ipv6: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        ipv6_cidr_block: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.List[ros_cdk_core.RosTag]] = None,
        vpc_name: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::VPC``.

        :param cidr_block: 
        :param description: 
        :param enable_ipv6: 
        :param ipv6_cidr_block: 
        :param resource_group_id: 
        :param tags: 
        :param vpc_name: 
        """
        self._values: typing.Dict[str, typing.Any] = {}
        if cidr_block is not None:
            self._values["cidr_block"] = cidr_block
        if description is not None:
            self._values["description"] = description
        if enable_ipv6 is not None:
            self._values["enable_ipv6"] = enable_ipv6
        if ipv6_cidr_block is not None:
            self._values["ipv6_cidr_block"] = ipv6_cidr_block
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if tags is not None:
            self._values["tags"] = tags
        if vpc_name is not None:
            self._values["vpc_name"] = vpc_name

    @builtins.property
    def cidr_block(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        cidrBlock: The IP address range of the VPC in the CIDR block form. You can use the following IP address ranges and their subnets:
        10.0.0.0/8
        172.16.0.0/12 (Default)
        192.168.0.0/16
        """
        result = self._values.get("cidr_block")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the vpc, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def enable_ipv6(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: enableIpv6: Whether to enable an IPv6 network cidr, the value is:False (default): not turned on.True: On.
        """
        result = self._values.get("enable_ipv6")
        return result

    @builtins.property
    def ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        """
        :Property: ipv6CidrBlock: IPv6 network cidr of the VPC.
        """
        result = self._values.get("ipv6_cidr_block")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[ros_cdk_core.RosTag]]:
        """
        :Property: tags: Tags to attach to vpc. Max support 20 tags to add during create vpc. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def vpc_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcName: Display name of the vpc instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("vpc_name")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosVPCProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RosVSwitch(
    ros_cdk_core.RosResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RosVSwitch",
):
    """A ROS template type:  ``ALIYUN::ECS::VSwitch``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RosVSwitchProps",
        enable_resource_property_constraint: builtins.bool,
    ) -> None:
        """Create a new ``ALIYUN::ECS::VSwitch``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RosVSwitch, self, [scope, id, props, enable_resource_property_constraint])

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        """
        :param props: -
        """
        return jsii.invoke(self, "renderProperties", [props])

    @jsii.python.classproperty # type: ignore
    @jsii.member(jsii_name="ROS_RESOURCE_TYPE_NAME")
    def ROS_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        """The resource type name for this resource class."""
        return jsii.sget(cls, "ROS_RESOURCE_TYPE_NAME")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrCidrBlock")
    def attr_cidr_block(self) -> typing.Any:
        """
        :Attribute: CidrBlock: CIDR Block of created VSwitch
        """
        return jsii.get(self, "attrCidrBlock")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrIpv6CidrBlock")
    def attr_ipv6_cidr_block(self) -> typing.Any:
        """
        :Attribute: Ipv6CidrBlock: The IPv6 network segment of the VSwitch
        """
        return jsii.get(self, "attrIpv6CidrBlock")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrVSwitchId")
    def attr_v_switch_id(self) -> typing.Any:
        """
        :Attribute: VSwitchId: Id of created VSwitch.
        """
        return jsii.get(self, "attrVSwitchId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="rosProperties")
    def _ros_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return jsii.get(self, "rosProperties")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="tags")
    def tags(self) -> ros_cdk_core.TagManager:
        """
        :Property: tags: Tags to attach to vswitch. Max support 20 tags to add during create vswitch. Each tag with two properties Key and Value, and Key is required.
        """
        return jsii.get(self, "tags")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="cidrBlock")
    def cidr_block(self) -> builtins.str:
        """
        :Property: cidrBlock: CIDR Block of created VSwitch, It must belong to itself VPC CIDR block.
        """
        return jsii.get(self, "cidrBlock")

    @cidr_block.setter # type: ignore
    def cidr_block(self, value: builtins.str) -> None:
        jsii.set(self, "cidrBlock", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="enableResourcePropertyConstraint")
    def enable_resource_property_constraint(self) -> builtins.bool:
        return jsii.get(self, "enableResourcePropertyConstraint")

    @enable_resource_property_constraint.setter # type: ignore
    def enable_resource_property_constraint(self, value: builtins.bool) -> None:
        jsii.set(self, "enableResourcePropertyConstraint", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> builtins.str:
        """
        :Property: vpcId: VPC id to create vswtich.
        """
        return jsii.get(self, "vpcId")

    @vpc_id.setter # type: ignore
    def vpc_id(self, value: builtins.str) -> None:
        jsii.set(self, "vpcId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="zoneId")
    def zone_id(self) -> builtins.str:
        """
        :Property: zoneId: The availability zone in which the VSwitch will be created.
        """
        return jsii.get(self, "zoneId")

    @zone_id.setter # type: ignore
    def zone_id(self, value: builtins.str) -> None:
        jsii.set(self, "zoneId", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the VSwitch, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        return jsii.get(self, "description")

    @description.setter # type: ignore
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        ipv6CidrBlock: The IPv6 network segment of the switch supports the last 8 bits of the VPC IPv6 network segment. Value: 0-255 (decimal).
        The IPv6 segment mask of the switch defaults to 64 bits.
        """
        return jsii.get(self, "ipv6CidrBlock")

    @ipv6_cidr_block.setter # type: ignore
    def ipv6_cidr_block(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "ipv6CidrBlock", value)

    @builtins.property # type: ignore
    @jsii.member(jsii_name="vSwitchName")
    def v_switch_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: vSwitchName: Display name of the vSwitch instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        return jsii.get(self, "vSwitchName")

    @v_switch_name.setter # type: ignore
    def v_switch_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vSwitchName", value)


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RosVSwitchProps",
    jsii_struct_bases=[],
    name_mapping={
        "cidr_block": "cidrBlock",
        "vpc_id": "vpcId",
        "zone_id": "zoneId",
        "description": "description",
        "ipv6_cidr_block": "ipv6CidrBlock",
        "tags": "tags",
        "v_switch_name": "vSwitchName",
    },
)
class RosVSwitchProps:
    def __init__(
        self,
        *,
        cidr_block: builtins.str,
        vpc_id: builtins.str,
        zone_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        ipv6_cidr_block: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.List[ros_cdk_core.RosTag]] = None,
        v_switch_name: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::VSwitch``.

        :param cidr_block: 
        :param vpc_id: 
        :param zone_id: 
        :param description: 
        :param ipv6_cidr_block: 
        :param tags: 
        :param v_switch_name: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "cidr_block": cidr_block,
            "vpc_id": vpc_id,
            "zone_id": zone_id,
        }
        if description is not None:
            self._values["description"] = description
        if ipv6_cidr_block is not None:
            self._values["ipv6_cidr_block"] = ipv6_cidr_block
        if tags is not None:
            self._values["tags"] = tags
        if v_switch_name is not None:
            self._values["v_switch_name"] = v_switch_name

    @builtins.property
    def cidr_block(self) -> builtins.str:
        """
        :Property: cidrBlock: CIDR Block of created VSwitch, It must belong to itself VPC CIDR block.
        """
        result = self._values.get("cidr_block")
        assert result is not None, "Required property 'cidr_block' is missing"
        return result

    @builtins.property
    def vpc_id(self) -> builtins.str:
        """
        :Property: vpcId: VPC id to create vswtich.
        """
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return result

    @builtins.property
    def zone_id(self) -> builtins.str:
        """
        :Property: zoneId: The availability zone in which the VSwitch will be created.
        """
        result = self._values.get("zone_id")
        assert result is not None, "Required property 'zone_id' is missing"
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the VSwitch, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def ipv6_cidr_block(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        ipv6CidrBlock: The IPv6 network segment of the switch supports the last 8 bits of the VPC IPv6 network segment. Value: 0-255 (decimal).
        The IPv6 segment mask of the switch defaults to 64 bits.
        """
        result = self._values.get("ipv6_cidr_block")
        return result

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[ros_cdk_core.RosTag]]:
        """
        :Property: tags: Tags to attach to vswitch. Max support 20 tags to add during create vswitch. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def v_switch_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: vSwitchName: Display name of the vSwitch instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("v_switch_name")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RosVSwitchProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Route(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.Route",
):
    """A ROS resource type:  ``ALIYUN::ECS::Route``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RouteProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::Route``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(Route, self, [scope, id, props, enable_resource_property_constraint])


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RouteProps",
    jsii_struct_bases=[],
    name_mapping={
        "destination_cidr_block": "destinationCidrBlock",
        "route_id": "routeId",
        "route_table_id": "routeTableId",
        "next_hop_id": "nextHopId",
        "next_hop_list": "nextHopList",
        "next_hop_type": "nextHopType",
    },
)
class RouteProps:
    def __init__(
        self,
        *,
        destination_cidr_block: builtins.str,
        route_id: builtins.str,
        route_table_id: builtins.str,
        next_hop_id: typing.Optional[builtins.str] = None,
        next_hop_list: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosRoute.NextHopListProperty]]]] = None,
        next_hop_type: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::Route``.

        :param destination_cidr_block: 
        :param route_id: 
        :param route_table_id: 
        :param next_hop_id: 
        :param next_hop_list: 
        :param next_hop_type: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "destination_cidr_block": destination_cidr_block,
            "route_id": route_id,
            "route_table_id": route_table_id,
        }
        if next_hop_id is not None:
            self._values["next_hop_id"] = next_hop_id
        if next_hop_list is not None:
            self._values["next_hop_list"] = next_hop_list
        if next_hop_type is not None:
            self._values["next_hop_type"] = next_hop_type

    @builtins.property
    def destination_cidr_block(self) -> builtins.str:
        """
        :Property: destinationCidrBlock: The RouteEntry's target network segment.
        """
        result = self._values.get("destination_cidr_block")
        assert result is not None, "Required property 'destination_cidr_block' is missing"
        return result

    @builtins.property
    def route_id(self) -> builtins.str:
        """
        :Property: routeId: RouteId of created route entry.
        """
        result = self._values.get("route_id")
        assert result is not None, "Required property 'route_id' is missing"
        return result

    @builtins.property
    def route_table_id(self) -> builtins.str:
        """
        :Property: routeTableId: RouteTableId of created route entry.
        """
        result = self._values.get("route_table_id")
        assert result is not None, "Required property 'route_table_id' is missing"
        return result

    @builtins.property
    def next_hop_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: nextHopId: The route entry's next hop. When the NextHopList is specified, the value will be ignored.
        """
        result = self._values.get("next_hop_id")
        return result

    @builtins.property
    def next_hop_list(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosRoute.NextHopListProperty]]]]:
        """
        :Property: nextHopList: The route entry's next hop list. If router is virtual border router, the value will be ignore. The list should contain 2-4 next hop. NextHopId of each next hop must be RouterInterface that VRouter forwards to VBR.
        """
        result = self._values.get("next_hop_list")
        return result

    @builtins.property
    def next_hop_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: nextHopType: The next hop type. Available value options: Instance | Tunnel | HaVip | RouterInterface. The default value is Instance.When the NextHopList is specified, the value will be ignored.
        """
        result = self._values.get("next_hop_type")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RouteProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RunCommand(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.RunCommand",
):
    """A ROS resource type:  ``ALIYUN::ECS::RunCommand``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "RunCommandProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::RunCommand``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(RunCommand, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrCommandId")
    def attr_command_id(self) -> typing.Any:
        """
        :Attribute: CommandId: The id of command created.
        """
        return jsii.get(self, "attrCommandId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrInvokeId")
    def attr_invoke_id(self) -> typing.Any:
        """
        :Attribute: InvokeId: The invoke id of command.
        """
        return jsii.get(self, "attrInvokeId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.RunCommandProps",
    jsii_struct_bases=[],
    name_mapping={
        "command_content": "commandContent",
        "instance_ids": "instanceIds",
        "type": "type",
        "content_encoding": "contentEncoding",
        "description": "description",
        "enable_parameter": "enableParameter",
        "frequency": "frequency",
        "keep_command": "keepCommand",
        "name": "name",
        "parameters": "parameters",
        "timed": "timed",
        "timeout": "timeout",
        "working_dir": "workingDir",
    },
)
class RunCommandProps:
    def __init__(
        self,
        *,
        command_content: builtins.str,
        instance_ids: typing.List[builtins.str],
        type: builtins.str,
        content_encoding: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        enable_parameter: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        frequency: typing.Optional[builtins.str] = None,
        keep_command: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        name: typing.Optional[builtins.str] = None,
        parameters: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.Mapping[builtins.str, typing.Any]]] = None,
        timed: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        timeout: typing.Optional[jsii.Number] = None,
        working_dir: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::RunCommand``.

        :param command_content: 
        :param instance_ids: 
        :param type: 
        :param content_encoding: 
        :param description: 
        :param enable_parameter: 
        :param frequency: 
        :param keep_command: 
        :param name: 
        :param parameters: 
        :param timed: 
        :param timeout: 
        :param working_dir: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "command_content": command_content,
            "instance_ids": instance_ids,
            "type": type,
        }
        if content_encoding is not None:
            self._values["content_encoding"] = content_encoding
        if description is not None:
            self._values["description"] = description
        if enable_parameter is not None:
            self._values["enable_parameter"] = enable_parameter
        if frequency is not None:
            self._values["frequency"] = frequency
        if keep_command is not None:
            self._values["keep_command"] = keep_command
        if name is not None:
            self._values["name"] = name
        if parameters is not None:
            self._values["parameters"] = parameters
        if timed is not None:
            self._values["timed"] = timed
        if timeout is not None:
            self._values["timeout"] = timeout
        if working_dir is not None:
            self._values["working_dir"] = working_dir

    @builtins.property
    def command_content(self) -> builtins.str:
        """
        :Property:

        commandContent: The plaintext content or the Base64-encoded content of the script. The Base64-encoded script content cannot exceed 16 KB.
        You can enable the custom parameter function by setting EnableParameter=true in the script content:
        Define custom parameters in the {{}} format. Within {{}}, the spaces and line breaks before and after the name of the parameter are ignored.
        The number of custom parameters cannot exceed 20.
        A custom parameter name can contain only letters, digits, underscores (_), and hyphens (-). It is case insensitive.
        Each custom parameter key cannot exceed 64 bytes.
        """
        result = self._values.get("command_content")
        assert result is not None, "Required property 'command_content' is missing"
        return result

    @builtins.property
    def instance_ids(self) -> typing.List[builtins.str]:
        """
        :Property: instanceIds: The instance id list. Select up to 20 instances at a time.Instances status must be running.
        """
        result = self._values.get("instance_ids")
        assert result is not None, "Required property 'instance_ids' is missing"
        return result

    @builtins.property
    def type(self) -> builtins.str:
        """
        :Property:

        type: The language type of the O&M script. Valid values:
        RunBatScript: batch scripts for Windows instances
        RunPowerShellScript: PowerShell scripts for Windows instances
        RunShellScript: shell scripts for Linux instances
        """
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return result

    @builtins.property
    def content_encoding(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        contentEncoding: The encoding mode of script content (CommandContent). Valid values (case insensitive):
        PlainText: The script content is not encoded, and transmitted in plaintext.
        Base64: base64-encoded.
        Default value: PlainText. If the specified value of this parameter is invalid, PlainText is used by default.
        """
        result = self._values.get("content_encoding")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: The description of the script, which supports all character sets. It can be up to 512 characters in length.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def enable_parameter(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        enableParameter: Specifies whether the script contains custom parameters.
        Default value: false
        """
        result = self._values.get("enable_parameter")
        return result

    @builtins.property
    def frequency(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        frequency: The execution period of recurring tasks. If the Timed parameter is set to True, you must specify the Frequency parameter. The interval between two recurring tasks cannot be less than 10 seconds.
        The parameter value follows the cron expression. For more information, see Configure scheduled commands.
        """
        result = self._values.get("frequency")
        return result

    @builtins.property
    def keep_command(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        keepCommand: Specifies whether to retain the script after it is run. Valid values:
        true: The script is retained. You can call the InvokeCommand operation to run the script again, call the DescribeCommands operation to query the script, and call the DeleteCommands operation to delete the script. The retained script takes up the quota of Cloud Assistant scripts.
        false: The script is not retained. It is automatically deleted after running, without taking up the quota of Cloud Assistant scripts.
        Default value: false
        """
        result = self._values.get("keep_command")
        return result

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """
        :Property: name: The name of the script, which supports all character sets. It can be up to 128 characters in length.
        """
        result = self._values.get("name")
        return result

    @builtins.property
    def parameters(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property:

        parameters: The key-value pairs of custom parameters passed in when the script contains custom parameters.
        Number of custom parameters: 0 to 10.
        The key cannot be an empty string. It can be up to 64 characters in length.
        The value can be an empty string.
        After the custom parameters and the original script content are Base64 encoded, the total size cannot exceed 16 KB.
        The set of custom parameter names must be a subset of the parameter set that is defined when you created the script. You can use an empty string to represent the parameters that are not passed in.
        Default value: null, indicating that this parameter is canceled and customer parameters are disabled.
        """
        result = self._values.get("parameters")
        return result

    @builtins.property
    def timed(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property:

        timed: Specifies whether to periodically run the script. Valid values:
        true: runs the script on a regular basis based on the value set for the Frequency parameter. The result of the previous execution task does not affect the next execution task.
        false: runs once only.
        Default value: false
        """
        result = self._values.get("timed")
        return result

    @builtins.property
    def timeout(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        timeout: The timeout period for script execution. Unit: seconds. A timeout error occurs when a script cannot be run because the process slows down, a specific module or the Cloud Assistant client does not exist. When the script times out, the script process is forcibly terminated.
        Default value: 60.
        """
        result = self._values.get("timeout")
        return result

    @builtins.property
    def working_dir(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        workingDir: The running directory of the script in the ECS instance.
        Default value:
        Linux instances: under the home directory of the administrator (root user): /root.
        Windows instances: under the directory where the process of the Cloud Assistant client is located, such as C:\\ProgramData\\aliyun\\assist$(version).
        """
        result = self._values.get("working_dir")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunCommandProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SNatEntry(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.SNatEntry",
):
    """A ROS resource type:  ``ALIYUN::ECS::SNatEntry``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "SNatEntryProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::SNatEntry``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(SNatEntry, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrSNatEntryId")
    def attr_s_nat_entry_id(self) -> typing.Any:
        """
        :Attribute: SNatEntryId: The id of created SNAT entry.
        """
        return jsii.get(self, "attrSNatEntryId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.SNatEntryProps",
    jsii_struct_bases=[],
    name_mapping={
        "s_nat_ip": "sNatIp",
        "s_nat_table_id": "sNatTableId",
        "snat_entry_name": "snatEntryName",
        "source_cidr": "sourceCidr",
        "source_v_switch_id": "sourceVSwitchId",
    },
)
class SNatEntryProps:
    def __init__(
        self,
        *,
        s_nat_ip: builtins.str,
        s_nat_table_id: builtins.str,
        snat_entry_name: typing.Optional[builtins.str] = None,
        source_cidr: typing.Optional[builtins.str] = None,
        source_v_switch_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::SNatEntry``.

        :param s_nat_ip: 
        :param s_nat_table_id: 
        :param snat_entry_name: 
        :param source_cidr: 
        :param source_v_switch_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "s_nat_ip": s_nat_ip,
            "s_nat_table_id": s_nat_table_id,
        }
        if snat_entry_name is not None:
            self._values["snat_entry_name"] = snat_entry_name
        if source_cidr is not None:
            self._values["source_cidr"] = source_cidr
        if source_v_switch_id is not None:
            self._values["source_v_switch_id"] = source_v_switch_id

    @builtins.property
    def s_nat_ip(self) -> builtins.str:
        """
        :Property: sNatIp: Source IP, must belongs to bandwidth package internet IP
        """
        result = self._values.get("s_nat_ip")
        assert result is not None, "Required property 's_nat_ip' is missing"
        return result

    @builtins.property
    def s_nat_table_id(self) -> builtins.str:
        """
        :Property: sNatTableId: Create SNAT entry in specified SNAT table.
        """
        result = self._values.get("s_nat_table_id")
        assert result is not None, "Required property 's_nat_table_id' is missing"
        return result

    @builtins.property
    def snat_entry_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: snatEntryName: he name of the SNAT rule is 2-128 characters long and must start with a letter or Chinese, but cannot begin with HTTP:// or https://.
        """
        result = self._values.get("snat_entry_name")
        return result

    @builtins.property
    def source_cidr(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourceCidr: Specifies the network segment of the switch. For example, 10.0.0.1/24. This parameter and the SourceVSwtichId parameter are mutually exclusive and cannot appear at the same time.
        """
        result = self._values.get("source_cidr")
        return result

    @builtins.property
    def source_v_switch_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourceVSwitchId: Allow which switch can access internet.
        """
        result = self._values.get("source_v_switch_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SNatEntryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SSHKeyPair(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.SSHKeyPair",
):
    """A ROS resource type:  ``ALIYUN::ECS::SSHKeyPair``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "SSHKeyPairProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::SSHKeyPair``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(SSHKeyPair, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrKeyPairFingerPrint")
    def attr_key_pair_finger_print(self) -> typing.Any:
        """
        :Attribute: KeyPairFingerPrint: The fingerprint of the key pair. The public key fingerprint format defined in RFC4716: MD5 message digest algorithm. Refer to http://tools.ietf.org/html/rfc4716.
        """
        return jsii.get(self, "attrKeyPairFingerPrint")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrKeyPairName")
    def attr_key_pair_name(self) -> typing.Any:
        """
        :Attribute: KeyPairName: SSH Key pair name.
        """
        return jsii.get(self, "attrKeyPairName")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrPrivateKeyBody")
    def attr_private_key_body(self) -> typing.Any:
        """
        :Attribute: PrivateKeyBody: The private key of the key pair. Content of the RSA private key in the PKCS#8 format of the unencrypted PEM encoding. Refer to: https://www.openssl.org/docs/apps/pkcs8.html.User only can get the private key one time when and only when SSH key pair is created.
        """
        return jsii.get(self, "attrPrivateKeyBody")


class SSHKeyPairAttachment(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.SSHKeyPairAttachment",
):
    """A ROS resource type:  ``ALIYUN::ECS::SSHKeyPairAttachment``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "SSHKeyPairAttachmentProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::SSHKeyPairAttachment``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(SSHKeyPairAttachment, self, [scope, id, props, enable_resource_property_constraint])


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.SSHKeyPairAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={"instance_ids": "instanceIds", "key_pair_name": "keyPairName"},
)
class SSHKeyPairAttachmentProps:
    def __init__(
        self,
        *,
        instance_ids: typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable],
        key_pair_name: builtins.str,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::SSHKeyPairAttachment``.

        :param instance_ids: 
        :param key_pair_name: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "instance_ids": instance_ids,
            "key_pair_name": key_pair_name,
        }

    @builtins.property
    def instance_ids(
        self,
    ) -> typing.Union[typing.List[typing.Any], ros_cdk_core.IResolvable]:
        """
        :Property: instanceIds: The comma delimited ECS instance id list. Only support Linux.
        """
        result = self._values.get("instance_ids")
        assert result is not None, "Required property 'instance_ids' is missing"
        return result

    @builtins.property
    def key_pair_name(self) -> builtins.str:
        """
        :Property: keyPairName: SSH key pair name.
        """
        result = self._values.get("key_pair_name")
        assert result is not None, "Required property 'key_pair_name' is missing"
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SSHKeyPairAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.SSHKeyPairProps",
    jsii_struct_bases=[],
    name_mapping={
        "key_pair_name": "keyPairName",
        "public_key_body": "publicKeyBody",
        "resource_group_id": "resourceGroupId",
    },
)
class SSHKeyPairProps:
    def __init__(
        self,
        *,
        key_pair_name: builtins.str,
        public_key_body: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::SSHKeyPair``.

        :param key_pair_name: 
        :param public_key_body: 
        :param resource_group_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "key_pair_name": key_pair_name,
        }
        if public_key_body is not None:
            self._values["public_key_body"] = public_key_body
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id

    @builtins.property
    def key_pair_name(self) -> builtins.str:
        """
        :Property: keyPairName: SSH key pair name. It must be unique. [2, 128] characters. All character sets are supported. Do not start with a special character, digit, http://, or https://. It can contain digits, ".", "_", or "-".
        """
        result = self._values.get("key_pair_name")
        assert result is not None, "Required property 'key_pair_name' is missing"
        return result

    @builtins.property
    def public_key_body(self) -> typing.Optional[builtins.str]:
        """
        :Property: publicKeyBody: SSH Public key. If PublicKeyBody is specified, existed public key body will be imported instead of creating new SSH key pair.
        """
        result = self._values.get("public_key_body")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SSHKeyPairProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SecurityGroup(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.SecurityGroup",
):
    """A ROS resource type:  ``ALIYUN::ECS::SecurityGroup``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: typing.Optional["SecurityGroupProps"] = None,
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::SecurityGroup``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(SecurityGroup, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrSecurityGroupId")
    def attr_security_group_id(self) -> typing.Any:
        """
        :Attribute: SecurityGroupId: generated security group id for security group.
        """
        return jsii.get(self, "attrSecurityGroupId")


class SecurityGroupClone(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.SecurityGroupClone",
):
    """A ROS resource type:  ``ALIYUN::ECS::SecurityGroupClone``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "SecurityGroupCloneProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::SecurityGroupClone``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(SecurityGroupClone, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrSecurityGroupId")
    def attr_security_group_id(self) -> typing.Any:
        """
        :Attribute: SecurityGroupId: Generated security group id of new security group.
        """
        return jsii.get(self, "attrSecurityGroupId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.SecurityGroupCloneProps",
    jsii_struct_bases=[],
    name_mapping={
        "source_security_group_id": "sourceSecurityGroupId",
        "description": "description",
        "destination_region_id": "destinationRegionId",
        "network_type": "networkType",
        "resource_group_id": "resourceGroupId",
        "security_group_name": "securityGroupName",
        "security_group_type": "securityGroupType",
        "vpc_id": "vpcId",
    },
)
class SecurityGroupCloneProps:
    def __init__(
        self,
        *,
        source_security_group_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        destination_region_id: typing.Optional[builtins.str] = None,
        network_type: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_group_name: typing.Optional[builtins.str] = None,
        security_group_type: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::SecurityGroupClone``.

        :param source_security_group_id: 
        :param description: 
        :param destination_region_id: 
        :param network_type: 
        :param resource_group_id: 
        :param security_group_name: 
        :param security_group_type: 
        :param vpc_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "source_security_group_id": source_security_group_id,
        }
        if description is not None:
            self._values["description"] = description
        if destination_region_id is not None:
            self._values["destination_region_id"] = destination_region_id
        if network_type is not None:
            self._values["network_type"] = network_type
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_group_name is not None:
            self._values["security_group_name"] = security_group_name
        if security_group_type is not None:
            self._values["security_group_type"] = security_group_type
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def source_security_group_id(self) -> builtins.str:
        """
        :Property: sourceSecurityGroupId: Source security group ID is used to copy properties to clone new security group. If the NetworkType and VpcId is not specified, the same security group will be cloned. If NetworkType or VpcId is specified, only proper security group rules will be cloned.
        """
        result = self._values.get("source_security_group_id")
        assert result is not None, "Required property 'source_security_group_id' is missing"
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the security group, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def destination_region_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: destinationRegionId: Clone security group to the specified region. Default to current region.
        """
        result = self._values.get("destination_region_id")
        return result

    @builtins.property
    def network_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: networkType: Clone new security group as classic network type. If the VpcId is specified, the value will be ignored.
        """
        result = self._values.get("network_type")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def security_group_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupName: Display name of the security group, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("security_group_name")
        return result

    @builtins.property
    def security_group_type(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        securityGroupType: The type of the security group. Valid values:
        normal: basic security group
        enterprise: advanced security group
        """
        result = self._values.get("security_group_type")
        return result

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcId: Physical ID of the VPC.
        """
        result = self._values.get("vpc_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityGroupCloneProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SecurityGroupEgress(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.SecurityGroupEgress",
):
    """A ROS resource type:  ``ALIYUN::ECS::SecurityGroupEgress``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "SecurityGroupEgressProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::SecurityGroupEgress``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(SecurityGroupEgress, self, [scope, id, props, enable_resource_property_constraint])


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.SecurityGroupEgressProps",
    jsii_struct_bases=[],
    name_mapping={
        "ip_protocol": "ipProtocol",
        "port_range": "portRange",
        "description": "description",
        "dest_cidr_ip": "destCidrIp",
        "dest_group_id": "destGroupId",
        "dest_group_owner_id": "destGroupOwnerId",
        "ipv6_dest_cidr_ip": "ipv6DestCidrIp",
        "nic_type": "nicType",
        "policy": "policy",
        "priority": "priority",
        "security_group_id": "securityGroupId",
    },
)
class SecurityGroupEgressProps:
    def __init__(
        self,
        *,
        ip_protocol: builtins.str,
        port_range: builtins.str,
        description: typing.Optional[builtins.str] = None,
        dest_cidr_ip: typing.Optional[builtins.str] = None,
        dest_group_id: typing.Optional[builtins.str] = None,
        dest_group_owner_id: typing.Optional[builtins.str] = None,
        ipv6_dest_cidr_ip: typing.Optional[builtins.str] = None,
        nic_type: typing.Optional[builtins.str] = None,
        policy: typing.Optional[builtins.str] = None,
        priority: typing.Optional[jsii.Number] = None,
        security_group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::SecurityGroupEgress``.

        :param ip_protocol: 
        :param port_range: 
        :param description: 
        :param dest_cidr_ip: 
        :param dest_group_id: 
        :param dest_group_owner_id: 
        :param ipv6_dest_cidr_ip: 
        :param nic_type: 
        :param policy: 
        :param priority: 
        :param security_group_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "ip_protocol": ip_protocol,
            "port_range": port_range,
        }
        if description is not None:
            self._values["description"] = description
        if dest_cidr_ip is not None:
            self._values["dest_cidr_ip"] = dest_cidr_ip
        if dest_group_id is not None:
            self._values["dest_group_id"] = dest_group_id
        if dest_group_owner_id is not None:
            self._values["dest_group_owner_id"] = dest_group_owner_id
        if ipv6_dest_cidr_ip is not None:
            self._values["ipv6_dest_cidr_ip"] = ipv6_dest_cidr_ip
        if nic_type is not None:
            self._values["nic_type"] = nic_type
        if policy is not None:
            self._values["policy"] = policy
        if priority is not None:
            self._values["priority"] = priority
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id

    @builtins.property
    def ip_protocol(self) -> builtins.str:
        """
        :Property: ipProtocol: Ip protocol for in rule.
        """
        result = self._values.get("ip_protocol")
        assert result is not None, "Required property 'ip_protocol' is missing"
        return result

    @builtins.property
    def port_range(self) -> builtins.str:
        """
        :Property: portRange: Ip protocol relative port range. For tcp and udp, the port rang is [1,65535], using format '1/200'For icmp|gre|all protocel, the port range should be '-1/-1'
        """
        result = self._values.get("port_range")
        assert result is not None, "Required property 'port_range' is missing"
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the security group rule, [1, 512] characters. The default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def dest_cidr_ip(self) -> typing.Optional[builtins.str]:
        """
        :Property: destCidrIp: Dest CIDR Ip Address range. Only IPV4 supported.
        """
        result = self._values.get("dest_cidr_ip")
        return result

    @builtins.property
    def dest_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: destGroupId: Dest Group Id
        """
        result = self._values.get("dest_group_id")
        return result

    @builtins.property
    def dest_group_owner_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: destGroupOwnerId: Dest Group Owner Account ID
        """
        result = self._values.get("dest_group_owner_id")
        return result

    @builtins.property
    def ipv6_dest_cidr_ip(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        ipv6DestCidrIp: Destination IPv6 CIDR address segment. Supports IP address ranges in CIDR format and IPv6 format.
        Note Only VPC type IP addresses are supported.
        """
        result = self._values.get("ipv6_dest_cidr_ip")
        return result

    @builtins.property
    def nic_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: nicType: Network type, could be 'internet' or 'intranet'. Default value is internet.
        """
        result = self._values.get("nic_type")
        return result

    @builtins.property
    def policy(self) -> typing.Optional[builtins.str]:
        """
        :Property: policy: Authorization policies, parameter values can be: accept (accepted access), drop (denied access). Default value is accept.
        """
        result = self._values.get("policy")
        return result

    @builtins.property
    def priority(self) -> typing.Optional[jsii.Number]:
        """
        :Property: priority: Authorization policies priority range[1, 100]
        """
        result = self._values.get("priority")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Id of the security group.
        """
        result = self._values.get("security_group_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityGroupEgressProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SecurityGroupIngress(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.SecurityGroupIngress",
):
    """A ROS resource type:  ``ALIYUN::ECS::SecurityGroupIngress``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "SecurityGroupIngressProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::SecurityGroupIngress``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(SecurityGroupIngress, self, [scope, id, props, enable_resource_property_constraint])


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.SecurityGroupIngressProps",
    jsii_struct_bases=[],
    name_mapping={
        "ip_protocol": "ipProtocol",
        "port_range": "portRange",
        "description": "description",
        "ipv6_source_cidr_ip": "ipv6SourceCidrIp",
        "nic_type": "nicType",
        "policy": "policy",
        "priority": "priority",
        "security_group_id": "securityGroupId",
        "source_cidr_ip": "sourceCidrIp",
        "source_group_id": "sourceGroupId",
        "source_group_owner_id": "sourceGroupOwnerId",
        "source_port_range": "sourcePortRange",
    },
)
class SecurityGroupIngressProps:
    def __init__(
        self,
        *,
        ip_protocol: builtins.str,
        port_range: builtins.str,
        description: typing.Optional[builtins.str] = None,
        ipv6_source_cidr_ip: typing.Optional[builtins.str] = None,
        nic_type: typing.Optional[builtins.str] = None,
        policy: typing.Optional[builtins.str] = None,
        priority: typing.Optional[jsii.Number] = None,
        security_group_id: typing.Optional[builtins.str] = None,
        source_cidr_ip: typing.Optional[builtins.str] = None,
        source_group_id: typing.Optional[builtins.str] = None,
        source_group_owner_id: typing.Optional[builtins.str] = None,
        source_port_range: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::SecurityGroupIngress``.

        :param ip_protocol: 
        :param port_range: 
        :param description: 
        :param ipv6_source_cidr_ip: 
        :param nic_type: 
        :param policy: 
        :param priority: 
        :param security_group_id: 
        :param source_cidr_ip: 
        :param source_group_id: 
        :param source_group_owner_id: 
        :param source_port_range: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "ip_protocol": ip_protocol,
            "port_range": port_range,
        }
        if description is not None:
            self._values["description"] = description
        if ipv6_source_cidr_ip is not None:
            self._values["ipv6_source_cidr_ip"] = ipv6_source_cidr_ip
        if nic_type is not None:
            self._values["nic_type"] = nic_type
        if policy is not None:
            self._values["policy"] = policy
        if priority is not None:
            self._values["priority"] = priority
        if security_group_id is not None:
            self._values["security_group_id"] = security_group_id
        if source_cidr_ip is not None:
            self._values["source_cidr_ip"] = source_cidr_ip
        if source_group_id is not None:
            self._values["source_group_id"] = source_group_id
        if source_group_owner_id is not None:
            self._values["source_group_owner_id"] = source_group_owner_id
        if source_port_range is not None:
            self._values["source_port_range"] = source_port_range

    @builtins.property
    def ip_protocol(self) -> builtins.str:
        """
        :Property: ipProtocol: Ip protocol for in rule.
        """
        result = self._values.get("ip_protocol")
        assert result is not None, "Required property 'ip_protocol' is missing"
        return result

    @builtins.property
    def port_range(self) -> builtins.str:
        """
        :Property: portRange: Ip protocol relative port range. For tcp and udp, the port rang is [1,65535], using format '1/200'For icmp|gre|all protocel, the port range should be '-1/-1'
        """
        result = self._values.get("port_range")
        assert result is not None, "Required property 'port_range' is missing"
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the security group rule, [1, 512] characters. The default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def ipv6_source_cidr_ip(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        ipv6SourceCidrIp: Source IPv6 CIDR address segment. Supports IP address ranges in CIDR format and IPv6 format.
        Note Only VPC type IP addresses are supported.
        """
        result = self._values.get("ipv6_source_cidr_ip")
        return result

    @builtins.property
    def nic_type(self) -> typing.Optional[builtins.str]:
        """
        :Property: nicType: Network type, could be 'internet' or 'intranet'. Default value is internet.
        """
        result = self._values.get("nic_type")
        return result

    @builtins.property
    def policy(self) -> typing.Optional[builtins.str]:
        """
        :Property: policy: Authorization policies, parameter values can be: accept (accepted access), drop (denied access). Default value is accept.
        """
        result = self._values.get("policy")
        return result

    @builtins.property
    def priority(self) -> typing.Optional[jsii.Number]:
        """
        :Property: priority: Authorization policies priority range[1, 100]
        """
        result = self._values.get("priority")
        return result

    @builtins.property
    def security_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupId: Id of the security group.
        """
        result = self._values.get("security_group_id")
        return result

    @builtins.property
    def source_cidr_ip(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourceCidrIp: Source CIDR Ip Address range. Only IPV4 supported.
        """
        result = self._values.get("source_cidr_ip")
        return result

    @builtins.property
    def source_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourceGroupId: Source Group Id
        """
        result = self._values.get("source_group_id")
        return result

    @builtins.property
    def source_group_owner_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourceGroupOwnerId: Source Group Owner Account ID
        """
        result = self._values.get("source_group_owner_id")
        return result

    @builtins.property
    def source_port_range(self) -> typing.Optional[builtins.str]:
        """
        :Property: sourcePortRange: The range of the ports enabled by the source security group for the transport layer protocol. Valid values: TCP/UDP: Value range: 1 to 65535. The start port and the end port are separated by a slash (/). Correct example: 1/200. Incorrect example: 200/1.ICMP: -1/-1.GRE: -1/-1.ALL: -1/-1.
        """
        result = self._values.get("source_port_range")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityGroupIngressProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.SecurityGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "resource_group_id": "resourceGroupId",
        "security_group_egress": "securityGroupEgress",
        "security_group_ingress": "securityGroupIngress",
        "security_group_name": "securityGroupName",
        "security_group_type": "securityGroupType",
        "tags": "tags",
        "vpc_id": "vpcId",
    },
)
class SecurityGroupProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_group_egress: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosSecurityGroup.SecurityGroupEgressProperty]]]] = None,
        security_group_ingress: typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosSecurityGroup.SecurityGroupIngressProperty]]]] = None,
        security_group_name: typing.Optional[builtins.str] = None,
        security_group_type: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::SecurityGroup``.

        :param description: 
        :param resource_group_id: 
        :param security_group_egress: 
        :param security_group_ingress: 
        :param security_group_name: 
        :param security_group_type: 
        :param tags: 
        :param vpc_id: 
        """
        self._values: typing.Dict[str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_group_egress is not None:
            self._values["security_group_egress"] = security_group_egress
        if security_group_ingress is not None:
            self._values["security_group_ingress"] = security_group_ingress
        if security_group_name is not None:
            self._values["security_group_name"] = security_group_name
        if security_group_type is not None:
            self._values["security_group_type"] = security_group_type
        if tags is not None:
            self._values["tags"] = tags
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the security group, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def security_group_egress(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosSecurityGroup.SecurityGroupEgressProperty]]]]:
        """
        :Property: securityGroupEgress: egress rules for the security group.
        """
        result = self._values.get("security_group_egress")
        return result

    @builtins.property
    def security_group_ingress(
        self,
    ) -> typing.Optional[typing.Union[ros_cdk_core.IResolvable, typing.List[typing.Union[ros_cdk_core.IResolvable, RosSecurityGroup.SecurityGroupIngressProperty]]]]:
        """
        :Property: securityGroupIngress: Ingress rules for the security group.
        """
        result = self._values.get("security_group_ingress")
        return result

    @builtins.property
    def security_group_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: securityGroupName: Display name of the security group, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("security_group_name")
        return result

    @builtins.property
    def security_group_type(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        securityGroupType: The type of the security group. Valid values:
        normal: basic security group
        enterprise: advanced security group
        """
        result = self._values.get("security_group_type")
        return result

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property: tags: Tags to attach to instance. Max support 20 tags to add during create instance. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcId: Physical ID of the VPC.
        """
        result = self._values.get("vpc_id")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Snapshot(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.Snapshot",
):
    """A ROS resource type:  ``ALIYUN::ECS::Snapshot``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "SnapshotProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::Snapshot``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(Snapshot, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrSnapshotId")
    def attr_snapshot_id(self) -> typing.Any:
        """
        :Attribute: SnapshotId: The snapshot ID.
        """
        return jsii.get(self, "attrSnapshotId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.SnapshotProps",
    jsii_struct_bases=[],
    name_mapping={
        "disk_id": "diskId",
        "description": "description",
        "snapshot_name": "snapshotName",
        "timeout": "timeout",
    },
)
class SnapshotProps:
    def __init__(
        self,
        *,
        disk_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        snapshot_name: typing.Optional[builtins.str] = None,
        timeout: typing.Optional[jsii.Number] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::Snapshot``.

        :param disk_id: 
        :param description: 
        :param snapshot_name: 
        :param timeout: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "disk_id": disk_id,
        }
        if description is not None:
            self._values["description"] = description
        if snapshot_name is not None:
            self._values["snapshot_name"] = snapshot_name
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def disk_id(self) -> builtins.str:
        """
        :Property: diskId: Indicates the ID of the specified disk.
        """
        result = self._values.get("disk_id")
        assert result is not None, "Required property 'disk_id' is missing"
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: The description of a snapshot can be 2 to 256 characters in length and cannot begin with http:// or https://. The description will appear on the console. By default, the value is zero.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def snapshot_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: snapshotName: The name of the snapshot, [2, 128] English or Chinese characters. It must begin with an uppercase/lowercase letter or a Chinese character, and may contain numbers, '_' or '-'. It cannot begin with http:// or https://.
        """
        result = self._values.get("snapshot_name")
        return result

    @builtins.property
    def timeout(self) -> typing.Optional[jsii.Number]:
        """
        :Property: timeout: The number of minutes to wait for create snapshot.
        """
        result = self._values.get("timeout")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnapshotProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.VPCProps",
    jsii_struct_bases=[],
    name_mapping={
        "cidr_block": "cidrBlock",
        "description": "description",
        "enable_ipv6": "enableIpv6",
        "ipv6_cidr_block": "ipv6CidrBlock",
        "resource_group_id": "resourceGroupId",
        "tags": "tags",
        "vpc_name": "vpcName",
    },
)
class VPCProps:
    def __init__(
        self,
        *,
        cidr_block: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        enable_ipv6: typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]] = None,
        ipv6_cidr_block: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]] = None,
        vpc_name: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::VPC``.

        :param cidr_block: 
        :param description: 
        :param enable_ipv6: 
        :param ipv6_cidr_block: 
        :param resource_group_id: 
        :param tags: 
        :param vpc_name: 
        """
        self._values: typing.Dict[str, typing.Any] = {}
        if cidr_block is not None:
            self._values["cidr_block"] = cidr_block
        if description is not None:
            self._values["description"] = description
        if enable_ipv6 is not None:
            self._values["enable_ipv6"] = enable_ipv6
        if ipv6_cidr_block is not None:
            self._values["ipv6_cidr_block"] = ipv6_cidr_block
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if tags is not None:
            self._values["tags"] = tags
        if vpc_name is not None:
            self._values["vpc_name"] = vpc_name

    @builtins.property
    def cidr_block(self) -> typing.Optional[builtins.str]:
        """
        :Property:

        cidrBlock: The IP address range of the VPC in the CIDR block form. You can use the following IP address ranges and their subnets:
        10.0.0.0/8
        172.16.0.0/12 (Default)
        192.168.0.0/16
        """
        result = self._values.get("cidr_block")
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the vpc, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def enable_ipv6(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, ros_cdk_core.IResolvable]]:
        """
        :Property: enableIpv6: Whether to enable an IPv6 network cidr, the value is:False (default): not turned on.True: On.
        """
        result = self._values.get("enable_ipv6")
        return result

    @builtins.property
    def ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        """
        :Property: ipv6CidrBlock: IPv6 network cidr of the VPC.
        """
        result = self._values.get("ipv6_cidr_block")
        return result

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        """
        :Property: resourceGroupId: Resource group id.
        """
        result = self._values.get("resource_group_id")
        return result

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property: tags: Tags to attach to vpc. Max support 20 tags to add during create vpc. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def vpc_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: vpcName: Display name of the vpc instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("vpc_name")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VPCProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VSwitch(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.VSwitch",
):
    """A ROS resource type:  ``ALIYUN::ECS::VSwitch``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: "VSwitchProps",
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::VSwitch``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(VSwitch, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrCidrBlock")
    def attr_cidr_block(self) -> typing.Any:
        """
        :Attribute: CidrBlock: CIDR Block of created VSwitch
        """
        return jsii.get(self, "attrCidrBlock")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrIpv6CidrBlock")
    def attr_ipv6_cidr_block(self) -> typing.Any:
        """
        :Attribute: Ipv6CidrBlock: The IPv6 network segment of the VSwitch
        """
        return jsii.get(self, "attrIpv6CidrBlock")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrVSwitchId")
    def attr_v_switch_id(self) -> typing.Any:
        """
        :Attribute: VSwitchId: Id of created VSwitch.
        """
        return jsii.get(self, "attrVSwitchId")


@jsii.data_type(
    jsii_type="@alicloud/ros-cdk-ecs.VSwitchProps",
    jsii_struct_bases=[],
    name_mapping={
        "cidr_block": "cidrBlock",
        "vpc_id": "vpcId",
        "zone_id": "zoneId",
        "description": "description",
        "ipv6_cidr_block": "ipv6CidrBlock",
        "tags": "tags",
        "v_switch_name": "vSwitchName",
    },
)
class VSwitchProps:
    def __init__(
        self,
        *,
        cidr_block: builtins.str,
        vpc_id: builtins.str,
        zone_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        ipv6_cidr_block: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]] = None,
        v_switch_name: typing.Optional[builtins.str] = None,
    ) -> None:
        """Properties for defining a ``ALIYUN::ECS::VSwitch``.

        :param cidr_block: 
        :param vpc_id: 
        :param zone_id: 
        :param description: 
        :param ipv6_cidr_block: 
        :param tags: 
        :param v_switch_name: 
        """
        self._values: typing.Dict[str, typing.Any] = {
            "cidr_block": cidr_block,
            "vpc_id": vpc_id,
            "zone_id": zone_id,
        }
        if description is not None:
            self._values["description"] = description
        if ipv6_cidr_block is not None:
            self._values["ipv6_cidr_block"] = ipv6_cidr_block
        if tags is not None:
            self._values["tags"] = tags
        if v_switch_name is not None:
            self._values["v_switch_name"] = v_switch_name

    @builtins.property
    def cidr_block(self) -> builtins.str:
        """
        :Property: cidrBlock: CIDR Block of created VSwitch, It must belong to itself VPC CIDR block.
        """
        result = self._values.get("cidr_block")
        assert result is not None, "Required property 'cidr_block' is missing"
        return result

    @builtins.property
    def vpc_id(self) -> builtins.str:
        """
        :Property: vpcId: VPC id to create vswtich.
        """
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return result

    @builtins.property
    def zone_id(self) -> builtins.str:
        """
        :Property: zoneId: The availability zone in which the VSwitch will be created.
        """
        result = self._values.get("zone_id")
        assert result is not None, "Required property 'zone_id' is missing"
        return result

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        """
        :Property: description: Description of the VSwitch, [2, 256] characters. Do not fill or empty, the default is empty.
        """
        result = self._values.get("description")
        return result

    @builtins.property
    def ipv6_cidr_block(self) -> typing.Optional[jsii.Number]:
        """
        :Property:

        ipv6CidrBlock: The IPv6 network segment of the switch supports the last 8 bits of the VPC IPv6 network segment. Value: 0-255 (decimal).
        The IPv6 segment mask of the switch defaults to 64 bits.
        """
        result = self._values.get("ipv6_cidr_block")
        return result

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]]:
        """
        :Property: tags: Tags to attach to vswitch. Max support 20 tags to add during create vswitch. Each tag with two properties Key and Value, and Key is required.
        """
        result = self._values.get("tags")
        return result

    @builtins.property
    def v_switch_name(self) -> typing.Optional[builtins.str]:
        """
        :Property: vSwitchName: Display name of the vSwitch instance, [2, 128] English or Chinese characters, must start with a letter or Chinese in size, can contain numbers, '_' or '.', '-'
        """
        result = self._values.get("v_switch_name")
        return result

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VSwitchProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Vpc(
    ros_cdk_core.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@alicloud/ros-cdk-ecs.Vpc",
):
    """A ROS resource type:  ``ALIYUN::ECS::VPC``."""

    def __init__(
        self,
        scope: ros_cdk_core.Construct,
        id: builtins.str,
        props: typing.Optional[VPCProps] = None,
        enable_resource_property_constraint: typing.Optional[builtins.bool] = None,
    ) -> None:
        """Create a new ``ALIYUN::ECS::VPC``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param props: - resource properties.
        :param enable_resource_property_constraint: -
        """
        jsii.create(Vpc, self, [scope, id, props, enable_resource_property_constraint])

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrRouteTableId")
    def attr_route_table_id(self) -> typing.Any:
        """
        :Attribute: RouteTableId: The router table id of created VPC.
        """
        return jsii.get(self, "attrRouteTableId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrVpcId")
    def attr_vpc_id(self) -> typing.Any:
        """
        :Attribute: VpcId: Id of created VPC.
        """
        return jsii.get(self, "attrVpcId")

    @builtins.property # type: ignore
    @jsii.member(jsii_name="attrVRouterId")
    def attr_v_router_id(self) -> typing.Any:
        """
        :Attribute: VRouterId: Router id of created VPC.
        """
        return jsii.get(self, "attrVRouterId")


__all__ = [
    "AssignIpv6Addresses",
    "AssignIpv6AddressesProps",
    "AssignPrivateIpAddresses",
    "AssignPrivateIpAddressesProps",
    "AutoProvisioningGroup",
    "AutoProvisioningGroupProps",
    "AutoSnapshotPolicy",
    "AutoSnapshotPolicyProps",
    "BandwidthPackage",
    "BandwidthPackageProps",
    "Command",
    "CommandProps",
    "CopyImage",
    "CopyImageProps",
    "CustomImage",
    "CustomImageProps",
    "DedicatedHost",
    "DedicatedHostProps",
    "DeploymentSet",
    "DeploymentSetProps",
    "Disk",
    "DiskAttachment",
    "DiskAttachmentProps",
    "DiskProps",
    "ForwardEntry",
    "ForwardEntryProps",
    "HpcCluster",
    "HpcClusterProps",
    "Instance",
    "InstanceClone",
    "InstanceCloneProps",
    "InstanceGroup",
    "InstanceGroupClone",
    "InstanceGroupCloneProps",
    "InstanceGroupProps",
    "InstanceProps",
    "Invocation",
    "InvocationProps",
    "JoinSecurityGroup",
    "JoinSecurityGroupProps",
    "LaunchTemplate",
    "LaunchTemplateProps",
    "NetworkInterface",
    "NetworkInterfaceAttachment",
    "NetworkInterfaceAttachmentProps",
    "NetworkInterfacePermission",
    "NetworkInterfacePermissionProps",
    "NetworkInterfaceProps",
    "PrepayInstance",
    "PrepayInstanceGroupClone",
    "PrepayInstanceGroupCloneProps",
    "PrepayInstanceProps",
    "RosAssignIpv6Addresses",
    "RosAssignIpv6AddressesProps",
    "RosAssignPrivateIpAddresses",
    "RosAssignPrivateIpAddressesProps",
    "RosAutoProvisioningGroup",
    "RosAutoProvisioningGroupProps",
    "RosAutoSnapshotPolicy",
    "RosAutoSnapshotPolicyProps",
    "RosBandwidthPackage",
    "RosBandwidthPackageProps",
    "RosCommand",
    "RosCommandProps",
    "RosCopyImage",
    "RosCopyImageProps",
    "RosCustomImage",
    "RosCustomImageProps",
    "RosDedicatedHost",
    "RosDedicatedHostProps",
    "RosDeploymentSet",
    "RosDeploymentSetProps",
    "RosDisk",
    "RosDiskAttachment",
    "RosDiskAttachmentProps",
    "RosDiskProps",
    "RosForwardEntry",
    "RosForwardEntryProps",
    "RosHpcCluster",
    "RosHpcClusterProps",
    "RosInstance",
    "RosInstanceClone",
    "RosInstanceCloneProps",
    "RosInstanceGroup",
    "RosInstanceGroupClone",
    "RosInstanceGroupCloneProps",
    "RosInstanceGroupProps",
    "RosInstanceProps",
    "RosInvocation",
    "RosInvocationProps",
    "RosJoinSecurityGroup",
    "RosJoinSecurityGroupProps",
    "RosLaunchTemplate",
    "RosLaunchTemplateProps",
    "RosNetworkInterface",
    "RosNetworkInterfaceAttachment",
    "RosNetworkInterfaceAttachmentProps",
    "RosNetworkInterfacePermission",
    "RosNetworkInterfacePermissionProps",
    "RosNetworkInterfaceProps",
    "RosPrepayInstance",
    "RosPrepayInstanceGroupClone",
    "RosPrepayInstanceGroupCloneProps",
    "RosPrepayInstanceProps",
    "RosRoute",
    "RosRouteProps",
    "RosRunCommand",
    "RosRunCommandProps",
    "RosSNatEntry",
    "RosSNatEntryProps",
    "RosSSHKeyPair",
    "RosSSHKeyPairAttachment",
    "RosSSHKeyPairAttachmentProps",
    "RosSSHKeyPairProps",
    "RosSecurityGroup",
    "RosSecurityGroupClone",
    "RosSecurityGroupCloneProps",
    "RosSecurityGroupEgress",
    "RosSecurityGroupEgressProps",
    "RosSecurityGroupIngress",
    "RosSecurityGroupIngressProps",
    "RosSecurityGroupProps",
    "RosSnapshot",
    "RosSnapshotProps",
    "RosVPC",
    "RosVPCProps",
    "RosVSwitch",
    "RosVSwitchProps",
    "Route",
    "RouteProps",
    "RunCommand",
    "RunCommandProps",
    "SNatEntry",
    "SNatEntryProps",
    "SSHKeyPair",
    "SSHKeyPairAttachment",
    "SSHKeyPairAttachmentProps",
    "SSHKeyPairProps",
    "SecurityGroup",
    "SecurityGroupClone",
    "SecurityGroupCloneProps",
    "SecurityGroupEgress",
    "SecurityGroupEgressProps",
    "SecurityGroupIngress",
    "SecurityGroupIngressProps",
    "SecurityGroupProps",
    "Snapshot",
    "SnapshotProps",
    "VPCProps",
    "VSwitch",
    "VSwitchProps",
    "Vpc",
]

publication.publish()
